<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>htgs: Tutorial 1</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">htgs
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tutorial1.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Tutorial 1 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#objectives">Objectives </a></li>
<li class="level1"><a href="#api-used">API Used </a></li>
<li class="level1"><a href="#implementation">Implementation </a><ul><li class="level2"><a href="#data">Data</a><ul><li class="level3"><a href="#input-data">Input data implementation</a></li>
<li class="level3"><a href="#output-data">Output data implementation</a></li>
<li class="level3"><a href="#data-notes">Notes</a></li>
</ul>
</li>
<li class="level2"><a href="#tasks">Tasks</a><ul><li class="level3"><a href="#addtask-implementation">AddTask Implementation</a></li>
<li class="level3"><a href="#task-notes">Notes</a></li>
</ul>
</li>
<li class="level2"><a href="#create-and-execute-taskgraph">Creating and Executing a TaskGraph</a><ul><li class="level3"><a href="#main-function">Main function (create and execute TaskGraph)</a></li>
<li class="level3"><a href="#taskgraph-notes">Notes</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#summary">Summary </a></li>
</ul>
</div>
<div class="textblock"><p>In this tutorial we will be introducing the basics of the Hybrid Task Graph Scheduler (HTGS) API.</p>
<p>The source code for the tutorial is found in "test/tutorial1"</p>
<p>We will be implementing a simple add function to add two numbers and return the result. This is a test case just to introduce the API and how to work with it.</p>
<h1><a class="anchor" id="objectives"></a>
Objectives </h1>
<ol type="1">
<li>How to represent data: (input and output)<ul>
<li>How to customize the priority of data</li>
</ul>
</li>
<li>How to operate on data with an ITask</li>
<li>How to add an ITask to a TaskGraph</li>
<li>How to add data into a TaskGraph</li>
<li>How to process data from a TaskGraph</li>
</ol>
<h1><a class="anchor" id="api-used"></a>
API Used </h1>
<ul>
<li>&lt;<a class="el" href="_i_data_8hpp.html" title="Implements the IData class, which is used for all data types entering/leaving a task graph...">htgs/api/IData.hpp</a>&gt;</li>
<li>&lt;<a class="el" href="_i_task_8hpp.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs/api/ITask.hpp</a>&gt;</li>
<li>&lt;<a class="el" href="_task_graph_8hpp.html" title="Implements the TaskGraph class responsible for managing ITask connections. ">htgs/api/TaskGraph.hpp</a>&gt;</li>
<li>&lt;<a class="el" href="_runtime_8hpp.html" title="Spawns threads and binds them to the appropriate ITask within a TaskGraph. ">htgs/api/Runtime.hpp</a>&gt;</li>
</ul>
<h1><a class="anchor" id="implementation"></a>
Implementation </h1>
<p>Below we will go into detail on each of the components needed to implement the algorithm x+y=z. Before we implement any code, we must analyze the algorithm and transform it into a dataflow graph. The dataflow graph provides a high level view of the algorithm such as data dependencies, control flow, and compute instances.</p>
<p>Algorithm: <img class="formulaInl" alt="$x+y=z$" src="form_0.png"/></p>
<p>Dataflow graph:</p>
<div class="image">
<img src="figures/tut1XY-dataflow.png"  alt="XY Dataflow"/>
</div>
<p>TaskGraph:</p>
<div class="image">
<img src="figures/tut1XY-taskgraph.png"  alt="XY Taskgraph"/>
</div>
<p>We transform the dataflow graph into a TaskGraph. We have two input types for the x+y operation, so we will compose the inputs into a single object to hold both x and y data. The result of the graph is a single value, so another data object is used to hold the ouput. There will be one compute task, which is responsible for the operation x+y.</p>
<h2><a class="anchor" id="data"></a>
Data</h2>
<p>The algorithm we are implementing adds two numbers and returns a result. One data class will be responsible for passing the two numbers to the Task and another data class will store the output. <b>Data is defined by inheriting the IData interface.</b></p>
<p>When data is passed from Task to Task it is inserted into a <a class="el" href="classhtgs_1_1_connector.html">Connector</a>, which uses a FIFO queue to hold data (transformed into a priority queue using the USE_PRIORITY_QUEUE directive)</p>
<p>If a Task expects multiple input values, then IData acts as a container where each of those input values is a single object.</p>
<p>All data in HTGS is represented as <a class="el" href="classhtgs_1_1_i_data.html">IData</a>. IData is an interface and contains only one (optional) virtual function: <a class="el" href="classhtgs_1_1_i_data.html#ac87beac9eae940d991735615274007e0">IData::compare</a>. Compare can be used to customize the ordering of data in the Connector's queue. <b>Priority is enabled only if the USE_PRIORITY_QUEUE directive is defined.</b></p>
<h3><a class="anchor" id="input-data"></a>
Input data implementation</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_i_data_8hpp.html">htgs/api/IData.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>InputData : <span class="keyword">public</span> <a class="code" href="classhtgs_1_1_i_data.html">htgs::IData</a></div>
<div class="line">{</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  InputData(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y) : x(x), y(y) {}</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">int</span> getX()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> x; }</div>
<div class="line">  <span class="keywordtype">int</span> getY()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> y; }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">int</span> x;</div>
<div class="line">  <span class="keywordtype">int</span> y;</div>
<div class="line"></div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="output-data"></a>
Output data implementation</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_i_data_8hpp.html">htgs/api/IData.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>OutputData : <span class="keyword">public</span> <a class="code" href="classhtgs_1_1_i_data.html">htgs::IData</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  OutputData(<span class="keywordtype">int</span> result) : IData(result),  result(result) {}</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">int</span> getResult()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> result; }</div>
<div class="line"></div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">int</span> result;</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="data-notes"></a>
Notes</h3>
<ul>
<li>IData can contain multiple input data being sent to an ITask</li>
<li>Assuming USE_PRIORITY_QUEUE directive is defined<ul>
<li>Uses order constructor for IData, which will provide an ordering based on the lowest value first.</li>
<li>The ordering can be customized if the <a class="el" href="classhtgs_1_1_i_data.html#ac87beac9eae940d991735615274007e0">IData::compare</a> function is overriden</li>
</ul>
</li>
</ul>
<p>Example altering the order of data to highest value first (USE_PRIORITY_QUEUE directive to enable priority): </p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> compare(<span class="keyword">const</span> std::shared_ptr&lt;OutputData&gt; p2)<span class="keyword"> const </span>{</div>
<div class="line">    <span class="comment">// getOrder() is inherited from the htgs::IData class</span></div>
<div class="line">    <span class="keywordflow">return</span> this-&gt;getOrder() &lt; p2-&gt;getOrder();</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="tasks"></a>
Tasks</h2>
<p>To implement the add function of the algorithm, we will only be needing one Task. <b>A Task is defined by inheriting the ITask interface.</b></p>
<p>Data is sent to/from an ITask through a TaskScheduler. The TaskScheduler manages the ITask's input/output Connectors. The input is passed to the <a class="el" href="classhtgs_1_1_i_task.html#a78776a659308572e84760e6e36a2520d">ITask::executeTask</a> function. The output is processed by calling the <a class="el" href="classhtgs_1_1_i_task.html#a64952b7c68e97d84c97c7b15a0b032aa">ITask::addResult</a> function from within the executeTask function.</p>
<p>The TaskScheduler is setup when adding an ITask to a TaskGraph. Multi-threading for an ITask is defined by the constructor for the ITask. Other options such as polling for data or initiating execution without data is also within various constructors for the ITask. These features are demonstrated in the next tutorial.</p>
<p>The ordering of the data entering/leaving an ITask can be customized using the USE_PRIORITY_QUEUE directive and by defining the priority of IData through its compare function or order constructor.</p>
<p>Every ITask has an input type and and output type. These types are defined by the first and second template parameters, respectively.</p>
<p>There are 5 mandatory functions that every ITask must implement:</p>
<p>1) <a class="el" href="classhtgs_1_1_i_task.html#abe832ff8732822f3fcbf72314d3bf109">ITask::initialize(pipelineId, ...)</a></p>
<ul>
<li>Called immediately when the thread that is bound to its TaskScheduler begins executing. Two variations available. One for simple initialization and other to aid in more advanced components such as work stealing. The basic usage of the initialize is to allocate local memory to be used by an ITask. This memory should be freed in the shutdown function. If the ITask is in an [ExecutionPipeline](<a class="el" href="classhtgs_1_1_execution_pipeline.html" title="The ExecutionPipeline class is used to duplicate task graphs, such that each duplicate executes concu...">htgs::ExecutionPipeline</a>), then the pipelineId indicate which pipeline the Task belongs to. This will be shown and used in a future tutorial.</li>
</ul>
<p>2) <a class="el" href="classhtgs_1_1_i_task.html#a248459b62405a6ea5bb733e2ddece2ef">ITask::shutdown()</a></p>
<ul>
<li>Called when the ITask::isTerminated function returns true. At this point the thread bound to the Task is about to terminate. Often used to deallocate local ITask memory.</li>
</ul>
<p>3) <a class="el" href="classhtgs_1_1_i_task.html#a78776a659308572e84760e6e36a2520d">ITask::executeTask(data)</a></p>
<ul>
<li>Function to process input data. Using the <a class="el" href="classhtgs_1_1_i_task.html#a64952b7c68e97d84c97c7b15a0b032aa">ITask::addResult</a> function, output data is sent to the next connected Task.</li>
</ul>
<p>4) <a class="el" href="classhtgs_1_1_i_task.html#acaedf1466b238036d880efcbf1feafe6">ITask::copy()</a></p>
<ul>
<li>Creates a copy of the ITask. Called during the <a class="el" href="classhtgs_1_1_runtime.html">Runtime</a> when a Task is being copied and bound to a thread. This function is used for concurrency/multithreading. If data is shared among ITask's that are copied, then proper synchronization may be required to manage that data.</li>
</ul>
<p>5) <a class="el" href="classhtgs_1_1_i_task.html#a4a3eb066af852acba199bfea764434b8">ITask::isTerminated(inputConnector)</a></p>
<ul>
<li>Determines if the Task is ready to be terminated. In most cases, the ITask should use the input <a class="el" href="classhtgs_1_1_connector.html" title="Manages the input/output of IData between Tasks. ">htgs::Connector</a>, which is passed as a parameter to isTerminated. The <a class="el" href="classhtgs_1_1_connector.html#a08ff806f4a9a9aca7767961bcacfc88d">Connector::isInputTerminated</a> function can be used by the ITask to check if all producers for the connector have finished sending data and the data queue is empty.</li>
</ul>
<p>The interaction between the ITask, TaskScheduler, and TaskScheduler's thread is shown below:</p>
<div class="image">
<img src="figures/tut1-itask-callgraph.png"  style="width: 80%; height: 80%"/>
</div>
<h3><a class="anchor" id="addtask-implementation"></a>
AddTask Implementation</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;../data/InputData.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;../data/OutputData.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_i_task_8hpp.html">htgs/api/ITask.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>AddTask : <span class="keyword">public</span> <a class="code" href="classhtgs_1_1_i_task.html">htgs::ITask</a>&lt;InputData, OutputData&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classhtgs_1_1_i_task.html#abe832ff8732822f3fcbf72314d3bf109">initialize</a>(<span class="keywordtype">int</span> pipelineId, <span class="keywordtype">int</span> numPipeline) { }</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classhtgs_1_1_i_task.html#a248459b62405a6ea5bb733e2ddece2ef">shutdown</a>() { }</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classhtgs_1_1_i_task.html#a78776a659308572e84760e6e36a2520d">executeTask</a>(std::shared_ptr&lt;InputData&gt; data) {</div>
<div class="line">        <span class="comment">// Adds x + y</span></div>
<div class="line">        <span class="keywordtype">int</span> sum = data-&gt;getX() + data-&gt;getY();</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Sends data along output edge</span></div>
<div class="line">        this-&gt;<a class="code" href="classhtgs_1_1_i_task.html#a64952b7c68e97d84c97c7b15a0b032aa">addResult</a>(<span class="keyword">new</span> OutputData(sum));</div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">virtual</span> AddTask *<a class="code" href="classhtgs_1_1_i_task.html#acaedf1466b238036d880efcbf1feafe6">copy</a>() {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">new</span> AddTask();</div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classhtgs_1_1_i_task.html#a4a3eb066af852acba199bfea764434b8">isTerminated</a>(std::shared_ptr&lt;htgs::BaseConnector&gt; inputConnector) {</div>
<div class="line">        <span class="keywordflow">return</span> inputConnector-&gt;isInputTerminated();</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="task-notes"></a>
Notes</h3>
<ul>
<li>The input and output types of the ITask are defined by the first and second template parameters, respectively.</li>
<li>Memory leaks are avoided by using the C++11 std::shared_ptr class. When adding data with addResult, the memory pointer allocated will be automatically wrapped into a shared_ptr to ensure it gets freed once all references have finished referring to it.</li>
<li>There are two variations of the initialize function. In most cases the basic version should be only be used</li>
</ul>
<h2><a class="anchor" id="create-and-execute-taskgraph"></a>
Creating and Executing a TaskGraph</h2>
<p>The TaskGraph is used to connect Tasks with their TaskSchedulers and connect the TaskSchedulers together using Connectors.</p>
<p>There are five functions available to connect an ITask to another ITask in a TaskGraph.</p>
<p>1) <a class="el" href="classhtgs_1_1_task_graph.html#ae86df3ba7ed64101ec7523a0775b7947">TaskGraph::addGraphInputConsumer(iTask)</a></p>
<ul>
<li>Sets the iTask to be the consumer of input that enters the TaskGraph (The input type of the TaskGraph, must match the input type of the Task)</li>
</ul>
<p>2) <a class="el" href="classhtgs_1_1_task_graph.html#ad9ee57959ed601eb7d5c67d4c2f6450f">TaskGraph::addGraphOutputProducer(iTask)</a></p>
<ul>
<li>Sets the iTask to be the producer of output that leaves the TaskGraph (the output type of the TaskGraph, must match the output type of the Task)</li>
</ul>
<p>3) <a class="el" href="classhtgs_1_1_task_graph.html#a88a428a714464c9c757668d3544c4328">TaskGraph::addEdge(iTaskProducer, iTaskConsumer)</a></p>
<ul>
<li>Connects two Task's together (The output type of the producer, must match the input type of the consumer)</li>
</ul>
<p>4) <a class="el" href="classhtgs_1_1_task_graph.html#a06dc23492237350c4ce8036818e5d984">TaskGraph::addRule(bookkeeper, iTaskConsumer, iRule)</a></p>
<ul>
<li>Adds a rule to a bookkeeper for sending data to a consumer (demonstrated in a future tutorial)</li>
</ul>
<p>5) <a class="el" href="classhtgs_1_1_task_graph.html#a49108102e5ae88e7a18ceeac3b2083c4">TaskGraph::addCustomEdge(iCustomEdge)</a></p>
<ul>
<li>Creates a customized connection between a producer and consumer (demonstrated in a future tutorial)</li>
</ul>
<p>Every TaskGraph has an input type and output type to allow sending/receiving data to/from a TaskGraph. In this tutorial we will be demonstrating this functionality.</p>
<p>There are three steps necessary for adding data to a graph and ensuring the graph will finish executing.</p>
<ol type="1">
<li>Specify the ITask that will be processing the input data with <a class="el" href="classhtgs_1_1_task_graph.html#ae86df3ba7ed64101ec7523a0775b7947">TaskGraph::addGraphInputConsumer</a></li>
<li>Increment the number of producers with <a class="el" href="classhtgs_1_1_task_graph.html#a1dfcadb07611c7c71ef5d09ce59bc8c6">TaskGraph::incrementGraphInputProducer</a></li>
<li>When there is no more data to be produced: <a class="el" href="classhtgs_1_1_task_graph.html#a269aec3b063044df915f7d9fe30b6650">TaskGraph::finishedProducingData</a></li>
</ol>
<p>If <a class="el" href="classhtgs_1_1_task_graph.html#a1dfcadb07611c7c71ef5d09ce59bc8c6">TaskGraph::incrementGraphInputProducer</a> is specified and <a class="el" href="classhtgs_1_1_task_graph.html#a269aec3b063044df915f7d9fe30b6650">TaskGraph::finishedProducingData</a> is never called, then the TaskGraph will not finish executing.</p>
<p>To process the output of a TaskGraph use the <a class="el" href="classhtgs_1_1_task_graph.html#aa222a7e8f5d3fe0a29bfb85e90203c34">TaskGraph::consumeData</a> function. To determine if there is no more data being produced by the TaskGraph, use the <a class="el" href="classhtgs_1_1_task_graph.html#a0ad46b99c6a98747464100e1a739a419">TaskGraph::isOutputTerminated</a> function.</p>
<p>To execute a TaskGraph, the TaskGraph is managed by the <a class="el" href="classhtgs_1_1_runtime.html">Runtime</a>. The Runtime will create threads, which are bound to TaskSchedulers. If a Task has more than one thread specified, then the Runtime will duplicate the Task such that each thread will be responsible for a separate instance of the Task.</p>
<p>If there are complications when running a TaskGraph, the TaskGraph can be saved as a dot file with the function <a class="el" href="classhtgs_1_1_task_graph.html#ab9d7313ea0dee54eecc8e0d22dcf4dab">TaskGraph::writeDotToFile</a>, which can be visually shown with the following command 'dot -Tpng &lt;filename&gt; -o &lt;filename&gt;.png'. The dot command is provided in the <a href="http://www.graphviz.org/">GraphViz software</a>. Below is an example dot file that is generated and the associated image representation:</p>
<p>Dot file generated using "taskGraph-&gt;writeDotToFile("tutorial1.dot")": </p>
<div class="fragment"><div class="line">digraph {</div>
<div class="line">node[shape=record, fontsize=10, fontname=<span class="stringliteral">&quot;Verdana&quot;</span>];</div>
<div class="line">edge[fontsize=10, fontname=<span class="stringliteral">&quot;Verdana&quot;</span>];</div>
<div class="line">graph [compound=<span class="keyword">true</span>];</div>
<div class="line">x10f6380 -&gt; x10f6010;</div>
<div class="line">x10f6380[label=<span class="stringliteral">&quot;&quot;</span>,shape=box,style=filled,color=black,width=.2,height=.2];</div>
<div class="line">x10f6010 -&gt; x10f6720;</div>
<div class="line">x10f6720[label=<span class="stringliteral">&quot;&quot;</span>,shape=box,style=filled,color=black,width=.2,height=.2];</div>
<div class="line">x10f6010[label=<span class="stringliteral">&quot;x+y=z&quot;</span>];</div>
<div class="line">}</div>
</div><!-- fragment --><p>And the image generated with GraphViz using "dot -Tpng tutorial1.dot -o tutorial1.png" </p>
<div class="image">
<img src="figures/tutorial1.png"  alt="Tutorial1 TaskGraph"/>
</div>
<h3><a class="anchor" id="main-function"></a>
Main function (create and execute TaskGraph)</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_task_graph_8hpp.html">htgs/api/TaskGraph.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_runtime_8hpp.html">htgs/api/Runtime.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;tasks/AddTask.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Creates the Task</span></div>
<div class="line">    AddTask *addTask = <span class="keyword">new</span> AddTask();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Creates the TaskGraph</span></div>
<div class="line">    <span class="keyword">auto</span> taskGraph = <span class="keyword">new</span> <a class="code" href="classhtgs_1_1_task_graph.html">htgs::TaskGraph&lt;InputData, OutputData&gt;</a>();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Declares that AddTask will be processing the input of a TaskGraph</span></div>
<div class="line">    taskGraph-&gt;<a class="code" href="classhtgs_1_1_task_graph.html#ae86df3ba7ed64101ec7523a0775b7947">addGraphInputConsumer</a>(addTask);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Declares that AddTask will be producing data for the output of a TaskGraph</span></div>
<div class="line">    taskGraph-&gt;addGraphOutputProducer(addTask);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Increments the number of producers (the main thread will be producing data)</span></div>
<div class="line">    taskGraph-&gt;incrementGraphInputProducer();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Launch the taskGraph</span></div>
<div class="line">    <span class="keyword">auto</span> runtime = <span class="keyword">new</span> <a class="code" href="classhtgs_1_1_runtime.html">htgs::Runtime</a>(taskGraph);</div>
<div class="line"></div>
<div class="line">    runtime-&gt;executeRuntime();</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">int</span> numData = 10;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Main thread producing data</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numData; i++)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">auto</span> inputData = <span class="keyword">new</span> InputData(i, i);</div>
<div class="line">        taskGraph-&gt;produceData(inputData);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Indicate that the main thread has finished producing data</span></div>
<div class="line">    taskGraph-&gt;finishedProducingData();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Wait until the runtime has finished processing data</span></div>
<div class="line">    runtime-&gt;waitForRuntime();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Process the ouput of the TaskGraph until no more data is available</span></div>
<div class="line">    <span class="keywordflow">while</span> (!taskGraph-&gt;isOutputTerminated())</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">auto</span> data = taskGraph-&gt;consumeData();</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">int</span> result = data-&gt;getResult();</div>
<div class="line"></div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Release all memory for the graph</span></div>
<div class="line">    <span class="keyword">delete</span> runtime;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Sample execution: </p>
<div class="fragment"><div class="line">./tutorial1</div>
<div class="line">Result: 0</div>
<div class="line">Result: 2</div>
<div class="line">Result: 4</div>
<div class="line">Result: 6</div>
<div class="line">Result: 8</div>
<div class="line">Result: 10</div>
<div class="line">Result: 12</div>
<div class="line">Result: 14</div>
<div class="line">Result: 16</div>
<div class="line">Result: 18</div>
</div><!-- fragment --><h3><a class="anchor" id="taskgraph-notes"></a>
Notes</h3>
<ul>
<li>The input and output types for each Task being added must match based on the way they are being added into a TaskGraph<ul>
<li>Example 1: addEdge types match based on output of producer and input of consumer</li>
<li>Example 2: addGraphInputConsumer types match based on input of graph and input on consumer</li>
</ul>
</li>
<li>To release all memory for HTGS, you only need to delete the runtime.</li>
<li>Threading is managed by the runtime, which will spawn threads and join on them.</li>
<li>If the main thread or some other component is producing data for a TaskGraph:<ol type="1">
<li>Specify the ITask that will be processing the input data with <a class="el" href="classhtgs_1_1_task_graph.html#ae86df3ba7ed64101ec7523a0775b7947">TaskGraph::addGraphInputConsumer</a></li>
<li>Increment the number of producers with <a class="el" href="classhtgs_1_1_task_graph.html#a1dfcadb07611c7c71ef5d09ce59bc8c6">TaskGraph::incrementGraphInputProducer</a></li>
<li>When there is no more data to be produced: <a class="el" href="classhtgs_1_1_task_graph.html#a269aec3b063044df915f7d9fe30b6650">TaskGraph::finishedProducingData</a></li>
</ol>
</li>
<li>Use the <a class="el" href="classhtgs_1_1_task_graph.html#aa222a7e8f5d3fe0a29bfb85e90203c34">TaskGraph::consumeData</a> function to retrieve the output from a TaskGraph.</li>
<li>Use the <a class="el" href="classhtgs_1_1_task_graph.html#a0ad46b99c6a98747464100e1a739a419">TaskGraph::isOutputTerminated</a> function to check if the TaskGraph has finished producing data.</li>
</ul>
<h1><a class="anchor" id="summary"></a>
Summary </h1>
<p>In this tutorial, we looked at the basics of the HTGS API.</p>
<ul>
<li>Data using IData</li>
<li>Compute Functions using the ITask interface</li>
<li>Creating a TaskGraph</li>
<li>Executing a TaskGraph</li>
<li>Sending data into a TaskGraph</li>
<li>Processing data produced by a TaskGraph</li>
</ul>
<p>In the next tutorial, we will introduce two operations that assist in representing algorithms that contain dependencies and strict memory limitations: (1) Bookkeeper and (2) MemoryManager.</p>
<p>Additional information:</p>
<ul>
<li>Header files that begin the 'I' denote interfaces; examples: <a class="el" href="classhtgs_1_1_i_data.html">IData</a> and <a class="el" href="classhtgs_1_1_i_task.html">ITask</a></li>
<li>An ITask is managed by a TaskScheduler which works with Task's input and output Connectors, and calls the underlying ITask API.</li>
<li>Tasks are connected through <a class="el" href="classhtgs_1_1_connector.html">Connectors</a>, which are setup when adding an ITask to a <a class="el" href="classhtgs_1_1_task_graph.html">TaskGraph</a>.</li>
<li>When transforming an algorithm into a TaskGraph, it helps to create a dataflow representation first to aid in understanding data dependencies. This is particularly useful when setting up IData and as will be seen in the next tutorial Bookkeeper rules and MemoryManagers. </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
