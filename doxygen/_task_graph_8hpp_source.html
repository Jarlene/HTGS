<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>htgs: /home/tjb3/phd-research/HTGS-dev/src/htgs/api/TaskGraph.hpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">htgs
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_task_graph_8hpp_source.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">TaskGraph.hpp</div>  </div>
</div><!--header-->
<div class="contents">
<a href="_task_graph_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment">// NIST-developed software is provided by NIST as a public service. You may use, copy and distribute copies of the software in any medium, provided that you keep intact this entire notice. You may improve, modify and create derivative works of the software or any portion of the software, and you may copy and distribute such modifications or works. Modified works should carry a notice stating that you changed the software and should note the date and nature of any such change. Please explicitly acknowledge the National Institute of Standards and Technology as the source of the software.</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment">// NIST-developed software is expressly provided &quot;AS IS.&quot; NIST MAKES NO WARRANTY OF ANY KIND, EXPRESS, IMPLIED, IN FACT OR ARISING BY OPERATION OF LAW, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTY OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT AND DATA ACCURACY. NIST NEITHER REPRESENTS NOR WARRANTS THAT THE OPERATION OF THE SOFTWARE WILL BE UNINTERRUPTED OR ERROR-FREE, OR THAT ANY DEFECTS WILL BE CORRECTED. NIST DOES NOT WARRANT OR MAKE ANY REPRESENTATIONS REGARDING THE USE OF THE SOFTWARE OR THE RESULTS THEREOF, INCLUDING BUT NOT LIMITED TO THE CORRECTNESS, ACCURACY, RELIABILITY, OR USEFULNESS OF THE SOFTWARE.</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment">// You are solely responsible for determining the appropriateness of using and distributing the software and you assume all risks associated with its use, including but not limited to the risks and costs of program errors, compliance with applicable laws, damage to or loss of data, programs or equipment, and the unavailability or interruption of operation. This software is not intended to be used in any situation where a failure could cause risk of injury or damage to property. The software developed by NIST employees is not subject to copyright protection within the United States.</span></div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="comment"></span><span class="preprocessor">#ifndef HTGS_TASKGRAPH_HPP</span></div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="preprocessor">#define HTGS_TASKGRAPH_HPP</span></div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="preprocessor">#include &lt;htgs/core/graph/edge/ProducerConsumerEdge.hpp&gt;</span></div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="preprocessor">#include &lt;htgs/core/graph/edge/RuleEdge.hpp&gt;</span></div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="preprocessor">#include &lt;htgs/core/graph/edge/MemoryEdge.hpp&gt;</span></div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="_void_memory_allocator_8hpp.html">htgs/core/memory/VoidMemoryAllocator.hpp</a>&gt;</span></div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="keyword">namespace </span>htgs {</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;<span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> U&gt;</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;<span class="keyword">class </span>TaskGraph: <span class="keyword">public</span> AnyTaskGraph {</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;  static_assert(std::is_base_of&lt;IData, T&gt;::value, <span class="stringliteral">&quot;T must derive from IData&quot;</span>);</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;  static_assert(std::is_base_of&lt;IData, U&gt;::value, <span class="stringliteral">&quot;U must derive from IData&quot;</span>);</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160; <span class="keyword">public</span>:</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;</div>
<div class="line"><a name="l00127"></a><span class="lineno"><a class="line" href="classhtgs_1_1_task_graph.html#aae29ebfc63282162af4e88eaf4c103c9">  127</a></span>&#160;  <a class="code" href="classhtgs_1_1_task_graph.html#aae29ebfc63282162af4e88eaf4c103c9">TaskGraph</a>() : <a class="code" href="classhtgs_1_1_any_task_graph.html">AnyTaskGraph</a>(0, 1) {</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    this-&gt;<a class="code" href="classhtgs_1_1_task_graph.html#a839fa5eee17aa8dde3e25586984c5369">input</a> = std::shared_ptr&lt;Connector&lt;T&gt;&gt;(<span class="keyword">new</span> <a class="code" href="classhtgs_1_1_connector.html">Connector&lt;T&gt;</a>());</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;    this-&gt;<a class="code" href="classhtgs_1_1_task_graph.html#a7c35ca0b3e8f5e33f276479210e28320">output</a> = std::shared_ptr&lt;Connector&lt;U&gt;&gt;(<span class="keyword">new</span> <a class="code" href="classhtgs_1_1_connector.html">Connector&lt;U&gt;</a>());</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;    <a class="code" href="classhtgs_1_1_task_graph.html#a73c039d4e4517f84d5b311871157584e">graphConsumerTaskManager</a> = <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;    <a class="code" href="classhtgs_1_1_task_graph.html#ac60eb3eb99b077b53ff3a68eb43a5c8e">graphProducerTaskManager</a> = <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;    <a class="code" href="classhtgs_1_1_task_graph.html#a9530b9db723598005535c53049a9c24e">edges</a> = <span class="keyword">new</span> std::list&lt;EdgeDescriptor *&gt;();</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;  }</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;</div>
<div class="line"><a name="l00140"></a><span class="lineno"><a class="line" href="classhtgs_1_1_task_graph.html#a5e88c706326e36faf5cc705c1d7ed345">  140</a></span>&#160;  <a class="code" href="classhtgs_1_1_task_graph.html#a5e88c706326e36faf5cc705c1d7ed345">TaskGraph</a>(<span class="keywordtype">size_t</span> <a class="code" href="classhtgs_1_1_any_task_graph.html#adb3a8cf583ac0b03687c2e37f85b3616">pipelineId</a>, <span class="keywordtype">size_t</span> <a class="code" href="classhtgs_1_1_any_task_graph.html#aa22ef2947e9b30e47c83701acfc06b5b">numPipelines</a>) : <a class="code" href="classhtgs_1_1_any_task_graph.html">AnyTaskGraph</a>(pipelineId, numPipelines) {</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;    this-&gt;<a class="code" href="classhtgs_1_1_task_graph.html#a839fa5eee17aa8dde3e25586984c5369">input</a> = std::shared_ptr&lt;Connector&lt;T&gt;&gt;(<span class="keyword">new</span> <a class="code" href="classhtgs_1_1_connector.html">Connector&lt;T&gt;</a>());</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;    this-&gt;<a class="code" href="classhtgs_1_1_task_graph.html#a7c35ca0b3e8f5e33f276479210e28320">output</a> = std::shared_ptr&lt;Connector&lt;U&gt;&gt;(<span class="keyword">new</span> <a class="code" href="classhtgs_1_1_connector.html">Connector&lt;U&gt;</a>());</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;    <a class="code" href="classhtgs_1_1_task_graph.html#a73c039d4e4517f84d5b311871157584e">graphConsumerTaskManager</a> = <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;    <a class="code" href="classhtgs_1_1_task_graph.html#ac60eb3eb99b077b53ff3a68eb43a5c8e">graphProducerTaskManager</a> = <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;    <a class="code" href="classhtgs_1_1_task_graph.html#a9530b9db723598005535c53049a9c24e">edges</a> = <span class="keyword">new</span> std::list&lt;EdgeDescriptor *&gt;();</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;  }</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;<span class="comment">//  /**</span></div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;<span class="comment">//   * Constructs a TaskGraph with the specified input and output Connector.</span></div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;<span class="comment">//   * @param input</span></div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;<span class="comment">//   * @param output</span></div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;<span class="comment">//   */</span></div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;<span class="comment">//   // TODO: Is this constructor necessary . . . (should be pipeline Id as alternate version . . .)</span></div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;<span class="comment">//  TaskGraph(std::shared_ptr&lt;Connector&lt;T&gt;&gt; input, std::shared_ptr&lt;Connector&lt;U&gt;&gt; output) : AnyTaskGraph() {</span></div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;<span class="comment">//    this-&gt;input = input;</span></div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;<span class="comment">//    this-&gt;output = output;</span></div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;<span class="comment">//    graphConsumerTaskManager = nullptr;</span></div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;<span class="comment">//    graphProducerTaskManager = nullptr;</span></div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;<span class="comment">//    edges = new std::list&lt;EdgeDescriptor *&gt;();</span></div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;<span class="comment"></span><span class="comment">//  }</span></div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;</div>
<div class="line"><a name="l00198"></a><span class="lineno"><a class="line" href="classhtgs_1_1_task_graph.html#ad89bcb6c378447e939df51b49a2c07ce">  198</a></span>&#160;  <a class="code" href="classhtgs_1_1_task_graph.html#ad89bcb6c378447e939df51b49a2c07ce">~TaskGraph</a>()<span class="keyword"> override </span>{</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> edge : *<a class="code" href="classhtgs_1_1_task_graph.html#a9530b9db723598005535c53049a9c24e">edges</a>)</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;    {</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;      <span class="keywordflow">if</span> (edge != <span class="keyword">nullptr</span>)</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;      {</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;        <span class="keyword">delete</span> edge;</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;        edge = <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;      }</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;    }</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;    <span class="keyword">delete</span> <a class="code" href="classhtgs_1_1_task_graph.html#a9530b9db723598005535c53049a9c24e">edges</a>;</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;    edges = <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;<span class="comment">//    delete iRuleMap;</span></div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;<span class="comment">//    iRuleMap = nullptr;</span></div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;    <span class="comment">// ONLY release memory for things inside graph (edges/vertices)</span></div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;<span class="comment">//    for (AnyTaskScheduler *task : *vertices) {</span></div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;<span class="comment">//      if (task != nullptr) {</span></div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;<span class="comment">//        delete task;</span></div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;<span class="comment">//        task = nullptr;</span></div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;<span class="comment">//      }</span></div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;<span class="comment">//    for (ProducerConsumerKey *pck : *producerConsumerKeys) {</span></div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;<span class="comment">//      if (pck != nullptr) {</span></div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;<span class="comment">//        delete pck;</span></div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;<span class="comment">//        pck = nullptr;</span></div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;<span class="comment">//      }</span></div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;<span class="comment">//    for (BookkeeperKey *bkk : *bookkeeperKeys) {</span></div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;<span class="comment">//      if (bkk != nullptr) {</span></div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;<span class="comment">//        delete bkk;</span></div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;<span class="comment">//        bkk = nullptr;</span></div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;<span class="comment">//      }</span></div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;<span class="comment">//    for (MemoryManagerKey *mmk : *memoryManagerKeys) {</span></div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;<span class="comment">//      if (mmk != nullptr) {</span></div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;<span class="comment">//        delete mmk;</span></div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;<span class="comment">//        mmk = nullptr;</span></div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;<span class="comment">//      }</span></div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;<span class="comment">//    for (CustomEdgePair pair : *customEdgeList) {</span></div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;<span class="comment">//      if (pair.second != nullptr) {</span></div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;<span class="comment">//        delete pair.second;</span></div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;<span class="comment">//        pair.second = nullptr;</span></div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;<span class="comment">//      }</span></div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;<span class="comment">//    delete graphInputConsumers;</span></div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;<span class="comment">//    graphInputConsumers = nullptr;</span></div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;<span class="comment">//    delete graphOutputProducers;</span></div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;<span class="comment">//    graphOutputProducers = nullptr;</span></div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;<span class="comment">//    delete edges;</span></div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;<span class="comment">//    edges = nullptr;</span></div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;<span class="comment">//    delete vertices;</span></div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;<span class="comment">//    vertices = nullptr;</span></div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;<span class="comment">//    delete producerConsumerKeys;</span></div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;<span class="comment">//    producerConsumerKeys = nullptr;</span></div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;<span class="comment">//    delete bookkeeperKeys;</span></div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;<span class="comment">//    bookkeeperKeys = nullptr;</span></div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;<span class="comment">//    delete memoryManagerKeys;</span></div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;<span class="comment">//    memoryManagerKeys = nullptr;</span></div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;<span class="comment">//    delete consumerTaskConnectorMap;</span></div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;<span class="comment">//    consumerTaskConnectorMap = nullptr;</span></div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;<span class="comment">//    delete memAllocMap;</span></div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;<span class="comment">//    memAllocMap = nullptr;</span></div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;<span class="comment">//    for (MemGetterPair p : *memGetterMap)</span></div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;<span class="comment">//    {</span></div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;<span class="comment">//      delete p.second;</span></div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;<span class="comment">//      p.second = nullptr;</span></div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;<span class="comment">//    delete memGetterMap;</span></div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;<span class="comment">//    memGetterMap = nullptr;</span></div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;<span class="comment">//    delete iTaskMap;</span></div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;<span class="comment">//    iTaskMap = nullptr;</span></div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;<span class="comment">//    delete ruleEdgeMap;</span></div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;<span class="comment">//    ruleEdgeMap = nullptr;</span></div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;<span class="comment">//    delete customEdgeList;</span></div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;<span class="comment">//    customEdgeList = nullptr;</span></div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;  }</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;  <a class="code" href="classhtgs_1_1_task_graph.html">TaskGraph&lt;T, U&gt;</a> *copy(<span class="keywordtype">size_t</span> <a class="code" href="classhtgs_1_1_any_task_graph.html#adb3a8cf583ac0b03687c2e37f85b3616">pipelineId</a>, <span class="keywordtype">size_t</span> <a class="code" href="classhtgs_1_1_any_task_graph.html#aa22ef2947e9b30e47c83701acfc06b5b">numPipelines</a>)</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;  {</div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;    <span class="keywordflow">return</span> copy(pipelineId, numPipelines, <span class="keyword">nullptr</span>, <span class="keyword">nullptr</span>);</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;  }</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;  TaskGraph&lt;T, U&gt; *copy(<span class="keywordtype">size_t</span> <a class="code" href="classhtgs_1_1_any_task_graph.html#adb3a8cf583ac0b03687c2e37f85b3616">pipelineId</a>, <span class="keywordtype">size_t</span> <a class="code" href="classhtgs_1_1_any_task_graph.html#aa22ef2947e9b30e47c83701acfc06b5b">numPipelines</a>, std::shared_ptr&lt;Connector&lt;T&gt;&gt; <a class="code" href="classhtgs_1_1_task_graph.html#a839fa5eee17aa8dde3e25586984c5369">input</a>, std::shared_ptr&lt;Connector&lt;U&gt;&gt; <a class="code" href="classhtgs_1_1_task_graph.html#a7c35ca0b3e8f5e33f276479210e28320">output</a>)</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;  {</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;    TaskGraph&lt;T, U&gt; *graphCopy = <span class="keyword">new</span> TaskGraph&lt;T, U&gt;(<a class="code" href="classhtgs_1_1_any_task_graph.html#adb3a8cf583ac0b03687c2e37f85b3616">pipelineId</a>, <a class="code" href="classhtgs_1_1_any_task_graph.html#aa22ef2947e9b30e47c83701acfc06b5b">numPipelines</a>);</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;    <span class="comment">// Copy the tasks to form lookup between old ITasks and new copies</span></div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;    graphCopy-&gt;copyTasks(this-&gt;<a class="code" href="classhtgs_1_1_any_task_graph.html#a5e2c111406e04640fd8841658cca55a0">getTaskManagers</a>());</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;</div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classhtgs_1_1_task_graph.html#a839fa5eee17aa8dde3e25586984c5369">input</a> != <span class="keyword">nullptr</span>)</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;    {</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;      graphCopy-&gt;setInputConnector(<a class="code" href="classhtgs_1_1_task_graph.html#a839fa5eee17aa8dde3e25586984c5369">input</a>);</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;    }</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classhtgs_1_1_task_graph.html#a7c35ca0b3e8f5e33f276479210e28320">output</a> != <span class="keyword">nullptr</span>)</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;    {</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;      graphCopy-&gt;setOutputConnector(<a class="code" href="classhtgs_1_1_task_graph.html#a7c35ca0b3e8f5e33f276479210e28320">output</a>);</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;    }</div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;</div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;    <span class="comment">// Copy the graph producer and consumer tasks</span></div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;    graphCopy-&gt;copyAndUpdateGraphConsumerTask(this-&gt;<a class="code" href="classhtgs_1_1_task_graph.html#a73c039d4e4517f84d5b311871157584e">graphConsumerTaskManager</a>);</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;    graphCopy-&gt;copyAndUpdateGraphProducerTask(this-&gt;<a class="code" href="classhtgs_1_1_task_graph.html#ac60eb3eb99b077b53ff3a68eb43a5c8e">graphProducerTaskManager</a>);</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;    <span class="keywordflow">for</span> (EdgeDescriptor *edgeDescriptor : *<a class="code" href="classhtgs_1_1_task_graph.html#a9530b9db723598005535c53049a9c24e">edges</a>)</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;    {</div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;      <span class="comment">// Copy the edge, using the graph copy as a reference for where to get task copies</span></div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;      EdgeDescriptor *edgeCopy = edgeDescriptor-&gt;copy(graphCopy);</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;</div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;      <span class="comment">// Apply the edge on the graph copy</span></div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;      edgeCopy-&gt;applyEdge(graphCopy);</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;      graphCopy-&gt;addEdgeDescriptor(edgeCopy);</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;    }</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;    <span class="keywordflow">return</span> graphCopy;</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;  }</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;</div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;  <span class="keyword">template</span>&lt;<span class="keyword">class</span> V, <span class="keyword">class</span> W, <span class="keyword">class</span> X&gt;</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;  <span class="keywordtype">void</span> addEdge(ITask&lt;V, W&gt; *producer, ITask&lt;W, X&gt; *consumer)</div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;  {</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;    <span class="keyword">auto</span> pce = <span class="keyword">new</span> ProducerConsumerEdge&lt;V, W, X&gt;(producer, consumer);</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;    pce-&gt;applyEdge(<span class="keyword">this</span>);</div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;    this-&gt;addEdgeDescriptor(pce);</div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;  }</div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;  <span class="keyword">template</span>&lt;<span class="keyword">class</span> V, <span class="keyword">class</span> IRuleType, <span class="keyword">class</span> W, <span class="keyword">class</span> X&gt;</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;  <span class="keywordtype">void</span> addRuleEdge(Bookkeeper&lt;V&gt; *bookkeeper, std::shared_ptr&lt;IRuleType&gt; rule, ITask&lt;W, X&gt; *consumer)</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;  {</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;    static_assert(std::is_base_of&lt;IRule&lt;V, W&gt;, IRuleType&gt;::value, <span class="stringliteral">&quot;Type mismatch for IRule&lt;V, W&gt;, V must match the input type of the bookkeeper and W must match the input type of the consumer!&quot;</span>);</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;    std::shared_ptr&lt;IRule&lt;V, W&gt;&gt; ruleCast = std::static_pointer_cast&lt;IRule&lt;V, W&gt;&gt;(rule);</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;    <span class="keyword">auto</span> re = <span class="keyword">new</span> RuleEdge&lt;V, W, X&gt;(bookkeeper, ruleCast, consumer);</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;    re-&gt;applyEdge(<span class="keyword">this</span>);</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;    this-&gt;addEdgeDescriptor(re);</div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;  }</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;<span class="preprocessor">#ifdef USE_CUDA</span></div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;</div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;  <span class="keyword">template</span> &lt;<span class="keyword">class</span> IMemoryAllocatorType&gt;</div>
<div class="line"><a name="l00363"></a><span class="lineno"><a class="line" href="classhtgs_1_1_task_graph.html#a85eb1e4c7ffd8732046a2ec0a37a91a6">  363</a></span>&#160;  <span class="keywordtype">void</span> <a class="code" href="classhtgs_1_1_task_graph.html#a85eb1e4c7ffd8732046a2ec0a37a91a6">addCudaMemoryManagerEdge</a>(std::string name, <a class="code" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *memoryEdges, <a class="code" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *releaseMemoryEdges,</div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;          std::shared_ptr&lt;IMemoryAllocatorType&gt; allocator, <span class="keywordtype">size_t</span> memoryPoolSize, MMType type, CUcontext * contexts) {</div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;    static_assert(std::is_base_of&lt;<a class="code" href="classhtgs_1_1_i_memory_allocator.html">IMemoryAllocator&lt;V&gt;</a>, IMemoryAllocatorType&gt;::value, <span class="stringliteral">&quot;Type mismatch for allocator, allocator must be a MemoryAllocator!&quot;</span>);</div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;</div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;    std::shared_ptr&lt;IMemoryAllocator&lt;V&gt;&gt; memAllocator = std::static_pointer_cast&lt;<a class="code" href="classhtgs_1_1_i_memory_allocator.html">IMemoryAllocator&lt;V&gt;</a>&gt;(allocator);</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;</div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;    <a class="code" href="classhtgs_1_1_memory_manager.html">MemoryManager&lt;V&gt;</a> *memoryManager = <span class="keyword">new</span> <a class="code" href="classhtgs_1_1_cuda_memory_manager.html">CudaMemoryManager&lt;V&gt;</a>(name, contexts, memoryPoolSize, memAllocator, type);</div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;</div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;</div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;    <a class="code" href="classhtgs_1_1_memory_edge.html">MemoryEdge&lt;V&gt;</a> *memEdge = <span class="keyword">new</span> <a class="code" href="classhtgs_1_1_memory_edge.html">MemoryEdge&lt;V&gt;</a>(name, getMemoryTask, releaseMemoryTask, memoryManager);</div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;    memEdge-&gt;applyEdge(<span class="keyword">this</span>);</div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;    this-&gt;addEdgeDescriptor(memEdge);</div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;  }</div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;</div>
<div class="line"><a name="l00386"></a><span class="lineno"><a class="line" href="classhtgs_1_1_task_graph.html#afeb08f2cdf202215129b6f2b2d9e59ab">  386</a></span>&#160;  <span class="keywordtype">void</span> <a class="code" href="classhtgs_1_1_task_graph.html#afeb08f2cdf202215129b6f2b2d9e59ab">addUserManagedMemoryManagerEdge</a>(std::string name,</div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;                                       <a class="code" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *getMemoryTask,</div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;                                       <a class="code" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *releaseMemoryTask,</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;                                       <span class="keywordtype">size_t</span> memoryPoolSize) {</div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;    <span class="keyword">auto</span> voidAllocator = std::make_shared&lt;VoidMemoryAllocator&gt;();</div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;    <a class="code" href="classhtgs_1_1_memory_manager.html">MemoryManager&lt;void *&gt;</a> *memoryManager = <span class="keyword">new</span> <a class="code" href="classhtgs_1_1_memory_manager.html">MemoryManager&lt;void *&gt;</a>(name, memoryPoolSize, voidAllocator, MMType::UserManaged);</div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;</div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;    <a class="code" href="classhtgs_1_1_memory_edge.html">MemoryEdge&lt;void *&gt;</a> *memEdge = <span class="keyword">new</span> <a class="code" href="classhtgs_1_1_memory_edge.html">MemoryEdge&lt;void *&gt;</a>(name, getMemoryTask, releaseMemoryTask, memoryManager);</div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;    memEdge-&gt;applyEdge(<span class="keyword">this</span>);</div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;    this-&gt;addEdgeDescriptor(memEdge);</div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;  }</div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;</div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;  <span class="keyword">template</span>&lt;<span class="keyword">class</span> V, <span class="keyword">class</span> IMemoryAllocatorType&gt;</div>
<div class="line"><a name="l00410"></a><span class="lineno"><a class="line" href="classhtgs_1_1_task_graph.html#a1b84e93e1a7221ffa0d4b35b55e817f9">  410</a></span>&#160;  <span class="keywordtype">void</span> <a class="code" href="classhtgs_1_1_task_graph.html#a1b84e93e1a7221ffa0d4b35b55e817f9">addMemoryManagerEdge</a>(std::string name, <a class="code" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *getMemoryTask, <a class="code" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *releaseMemoryTask,</div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;                            std::shared_ptr&lt;IMemoryAllocatorType&gt; allocator, <span class="keywordtype">size_t</span> memoryPoolSize, MMType type) {</div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;    static_assert(std::is_base_of&lt;<a class="code" href="classhtgs_1_1_i_memory_allocator.html">IMemoryAllocator&lt;V&gt;</a>, IMemoryAllocatorType&gt;::value, <span class="stringliteral">&quot;Type mismatch for allocator, allocator must be a MemoryAllocator!&quot;</span>);</div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;</div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;    std::shared_ptr&lt;IMemoryAllocator&lt;V&gt;&gt; memAllocator = std::static_pointer_cast&lt;<a class="code" href="classhtgs_1_1_i_memory_allocator.html">IMemoryAllocator&lt;V&gt;</a>&gt;(allocator);</div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;</div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;    <a class="code" href="classhtgs_1_1_memory_manager.html">MemoryManager&lt;V&gt;</a> *memoryManager = <span class="keyword">new</span> <a class="code" href="classhtgs_1_1_memory_manager.html">MemoryManager&lt;V&gt;</a>(name, memoryPoolSize, memAllocator, type);</div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;</div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;    <a class="code" href="classhtgs_1_1_memory_edge.html">MemoryEdge&lt;V&gt;</a> *memEdge = <span class="keyword">new</span> <a class="code" href="classhtgs_1_1_memory_edge.html">MemoryEdge&lt;V&gt;</a>(name, getMemoryTask, releaseMemoryTask, memoryManager);</div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;    memEdge-&gt;applyEdge(<span class="keyword">this</span>);</div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;    this-&gt;addEdgeDescriptor(memEdge);</div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;  }</div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;</div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;</div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;  <a class="code" href="classhtgs_1_1_any_task_scheduler.html">AnyTaskScheduler</a> *getGraphConsumerTaskManager()<span class="keyword"> override </span>{</div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;    <span class="keywordflow">return</span> this-&gt;<a class="code" href="classhtgs_1_1_task_graph.html#a73c039d4e4517f84d5b311871157584e">graphConsumerTaskManager</a>;</div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;  }</div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;</div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;  AnyTaskScheduler *getGraphProducerTaskManager()<span class="keyword"> override </span>{</div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;    <span class="keywordflow">return</span> this-&gt;<a class="code" href="classhtgs_1_1_task_graph.html#ac60eb3eb99b077b53ff3a68eb43a5c8e">graphProducerTaskManager</a>;</div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;  }</div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;</div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;  std::shared_ptr&lt;AnyConnector&gt; getInputConnector()<span class="keyword"> override </span>{</div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;    <span class="keywordflow">return</span> this-&gt;<a class="code" href="classhtgs_1_1_task_graph.html#a839fa5eee17aa8dde3e25586984c5369">input</a>;</div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;  }</div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;</div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;  std::shared_ptr&lt;AnyConnector&gt; getOutputConnector()<span class="keyword"> override </span>{</div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;    <span class="keywordflow">return</span> this-&gt;<a class="code" href="classhtgs_1_1_task_graph.html#a7c35ca0b3e8f5e33f276479210e28320">output</a>;</div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;  }</div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;</div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;  <span class="keywordtype">void</span> setInputConnector(std::shared_ptr&lt;Connector&lt;T&gt;&gt; <a class="code" href="classhtgs_1_1_task_graph.html#a839fa5eee17aa8dde3e25586984c5369">input</a>) {</div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;    this-&gt;<a class="code" href="classhtgs_1_1_task_graph.html#a839fa5eee17aa8dde3e25586984c5369">input</a> = <a class="code" href="classhtgs_1_1_task_graph.html#a839fa5eee17aa8dde3e25586984c5369">input</a>;</div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;  }</div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;</div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;  <span class="keywordtype">void</span> setOutputConnector(std::shared_ptr&lt;Connector&lt;T&gt;&gt; <a class="code" href="classhtgs_1_1_task_graph.html#a7c35ca0b3e8f5e33f276479210e28320">output</a>) {</div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;    this-&gt;<a class="code" href="classhtgs_1_1_task_graph.html#a7c35ca0b3e8f5e33f276479210e28320">output</a> = <a class="code" href="classhtgs_1_1_task_graph.html#a7c35ca0b3e8f5e33f276479210e28320">output</a>;</div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;  }</div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;</div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;  <span class="keywordtype">void</span> incrementGraphProducer()</div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;  {</div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;    this-&gt;<a class="code" href="classhtgs_1_1_task_graph.html#a839fa5eee17aa8dde3e25586984c5369">input</a>-&gt;incrementInputTaskCount();</div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;  }</div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;</div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;  <span class="keywordtype">void</span> finishedProducingData()</div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;  {</div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;    this-&gt;<a class="code" href="classhtgs_1_1_task_graph.html#a839fa5eee17aa8dde3e25586984c5369">input</a>-&gt;producerFinished();</div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;  }</div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;</div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;  <span class="keyword">template</span>&lt;<span class="keyword">class</span> W&gt;</div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;  <span class="keywordtype">void</span> setGraphConsumerTask(ITask&lt;T, W&gt; *task)</div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;  {</div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;    <span class="comment">// TODO: Number of active connections for Connector</span></div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;    <span class="comment">// TODO: Check about setting connector to nullptr for previous task</span></div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;<span class="comment">//    if (this-&gt;graphConsumerTaskManager != nullptr)</span></div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;<span class="comment">//      this-&gt;graphConsumerTaskManager-&gt;setInputConnector(nullptr);</span></div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;</div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;    this-&gt;<a class="code" href="classhtgs_1_1_task_graph.html#a73c039d4e4517f84d5b311871157584e">graphConsumerTaskManager</a> = this-&gt;getTaskManager(task);</div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;</div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;    this-&gt;<a class="code" href="classhtgs_1_1_task_graph.html#a73c039d4e4517f84d5b311871157584e">graphConsumerTaskManager</a>-&gt;<a class="code" href="classhtgs_1_1_any_task_scheduler.html#afbed88d7a0cbd49d184a385892775694">setInputConnector</a>(this-&gt;<a class="code" href="classhtgs_1_1_task_graph.html#a839fa5eee17aa8dde3e25586984c5369">input</a>);</div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;</div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;  }</div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;</div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;  <span class="keyword">template</span>&lt;<span class="keyword">class</span> W&gt;</div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;  <span class="keywordtype">void</span> setGraphProducerTask(ITask&lt;W, U&gt; * task)</div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;  {</div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;    <span class="comment">// TODO: Number of active connections for Connector</span></div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;    <span class="comment">// TODO: Check about setting connector to nullptr for previous task</span></div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;<span class="comment">//    if (this-&gt;graphProducerTaskManager != nullptr)</span></div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;<span class="comment">//      this-&gt;graphProducerTaskManager-&gt;setOutputConnector(nullptr);</span></div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;</div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;    <span class="keywordflow">if</span> (this-&gt;<a class="code" href="classhtgs_1_1_task_graph.html#ac60eb3eb99b077b53ff3a68eb43a5c8e">graphProducerTaskManager</a> == <span class="keyword">nullptr</span>)</div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;    {</div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;      this-&gt;<a class="code" href="classhtgs_1_1_task_graph.html#a7c35ca0b3e8f5e33f276479210e28320">output</a>-&gt;incrementInputTaskCount();</div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;    }</div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;</div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;    this-&gt;<a class="code" href="classhtgs_1_1_task_graph.html#ac60eb3eb99b077b53ff3a68eb43a5c8e">graphProducerTaskManager</a> = this-&gt;getTaskManager(task);</div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;</div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;    this-&gt;<a class="code" href="classhtgs_1_1_task_graph.html#ac60eb3eb99b077b53ff3a68eb43a5c8e">graphProducerTaskManager</a>-&gt;<a class="code" href="classhtgs_1_1_any_task_scheduler.html#a2b72dda29cceb6699050458cdbf473cc">setOutputConnector</a>(this-&gt;<a class="code" href="classhtgs_1_1_task_graph.html#a7c35ca0b3e8f5e33f276479210e28320">output</a>);</div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;  }</div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;</div>
<div class="line"><a name="l00499"></a><span class="lineno"><a class="line" href="classhtgs_1_1_task_graph.html#a15b4bb176539081a1a74428aaa337ed5">  499</a></span>&#160;  <span class="keywordtype">void</span> <a class="code" href="classhtgs_1_1_task_graph.html#a15b4bb176539081a1a74428aaa337ed5">produceData</a>(T *data) {</div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;    std::shared_ptr&lt;T&gt; dataPtr = std::shared_ptr&lt;T&gt;(data);</div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;    this-&gt;<a class="code" href="classhtgs_1_1_task_graph.html#a839fa5eee17aa8dde3e25586984c5369">input</a>-&gt;produceData(dataPtr);</div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;  }</div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;</div>
<div class="line"><a name="l00511"></a><span class="lineno"><a class="line" href="classhtgs_1_1_task_graph.html#a2d896acdc5a27ed9db6340cd2b5995ed">  511</a></span>&#160;  <span class="keywordtype">void</span> <a class="code" href="classhtgs_1_1_task_graph.html#a2d896acdc5a27ed9db6340cd2b5995ed">produceData</a>(std::shared_ptr&lt;T&gt; data) {</div>
<div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;    this-&gt;<a class="code" href="classhtgs_1_1_task_graph.html#a839fa5eee17aa8dde3e25586984c5369">input</a>-&gt;produceData(data);</div>
<div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;  }</div>
<div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;</div>
<div class="line"><a name="l00522"></a><span class="lineno"><a class="line" href="classhtgs_1_1_task_graph.html#a538cbbc552965902fec6faac67766fbf">  522</a></span>&#160;  <span class="keywordtype">void</span> <a class="code" href="classhtgs_1_1_task_graph.html#a538cbbc552965902fec6faac67766fbf">produceData</a>(std::list&lt;std::shared_ptr&lt;T&gt;&gt; *dataList) {</div>
<div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;    this-&gt;<a class="code" href="classhtgs_1_1_task_graph.html#a839fa5eee17aa8dde3e25586984c5369">input</a>-&gt;produceData(dataList);</div>
<div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;    <span class="keywordflow">if</span> (this-&gt;<a class="code" href="classhtgs_1_1_task_graph.html#a839fa5eee17aa8dde3e25586984c5369">input</a>-&gt;isInputTerminated())</div>
<div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;      this-&gt;<a class="code" href="classhtgs_1_1_task_graph.html#a839fa5eee17aa8dde3e25586984c5369">input</a>-&gt;wakeupConsumer();</div>
<div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;  }</div>
<div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;</div>
<div class="line"><a name="l00537"></a><span class="lineno"><a class="line" href="classhtgs_1_1_task_graph.html#aa222a7e8f5d3fe0a29bfb85e90203c34">  537</a></span>&#160;  std::shared_ptr&lt;U&gt; <a class="code" href="classhtgs_1_1_task_graph.html#aa222a7e8f5d3fe0a29bfb85e90203c34">consumeData</a>() {</div>
<div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;    <span class="keywordflow">return</span> this-&gt;<a class="code" href="classhtgs_1_1_task_graph.html#a7c35ca0b3e8f5e33f276479210e28320">output</a>-&gt;consumeData();</div>
<div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;  }</div>
<div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;</div>
<div class="line"><a name="l00546"></a><span class="lineno"><a class="line" href="classhtgs_1_1_task_graph.html#a994884edaae94574d64ee9fd5d0fd7a4">  546</a></span>&#160;  std::shared_ptr&lt;U&gt; <a class="code" href="classhtgs_1_1_task_graph.html#a994884edaae94574d64ee9fd5d0fd7a4">pollData</a>(<span class="keywordtype">long</span> microTimeout) {</div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;    <span class="keywordflow">return</span> this-&gt;<a class="code" href="classhtgs_1_1_task_graph.html#a7c35ca0b3e8f5e33f276479210e28320">output</a>-&gt;pollConsumeData(microTimeout);</div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;  }</div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;</div>
<div class="line"><a name="l00556"></a><span class="lineno"><a class="line" href="classhtgs_1_1_task_graph.html#a0ad46b99c6a98747464100e1a739a419">  556</a></span>&#160;  <span class="keywordtype">bool</span> <a class="code" href="classhtgs_1_1_task_graph.html#a0ad46b99c6a98747464100e1a739a419">isOutputTerminated</a>() {</div>
<div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;    <span class="keywordflow">return</span> this-&gt;<a class="code" href="classhtgs_1_1_task_graph.html#a7c35ca0b3e8f5e33f276479210e28320">output</a>-&gt;isInputTerminated();</div>
<div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;  }</div>
<div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;</div>
<div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;<span class="comment">//  /**</span></div>
<div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;<span class="comment">//   * Writes the dot representation of the task graph to disk</span></div>
<div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;<span class="comment">//   * @param file the file path (will not create directories)</span></div>
<div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;<span class="comment">//   */</span></div>
<div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;<span class="comment">//  void writeDotToFile(std::string file) {</span></div>
<div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;<span class="comment">//    writeDotToFile(file, 0);</span></div>
<div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;<span class="comment">//  void writeDotToFile(std::string file, int flags) {</span></div>
<div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;<span class="comment">//    std::ofstream f(file);</span></div>
<div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;<span class="comment">//    f &lt;&lt; genDotGraph(flags);</span></div>
<div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;<span class="comment">//    f.flush();</span></div>
<div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;<span class="comment">//    std::cout &lt;&lt; &quot;Writing dot file for task graph to &quot; &lt;&lt; file &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;<span class="comment">//  /**</span></div>
<div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;<span class="comment">//   * Generate the content only of the graph (excludes all graph definitions and attributes)</span></div>
<div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;<span class="comment">//   */</span></div>
<div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;<span class="comment">//  std::string genDotGraphContent(int flags) {</span></div>
<div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;<span class="comment">//    std::ostringstream oss;</span></div>
<div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;<span class="comment">//    for (AnyTaskScheduler *bTask : *vertices) {</span></div>
<div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;<span class="comment">//      oss &lt;&lt; bTask-&gt;getDot(flags);</span></div>
<div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;<span class="comment">//    if ((flags &amp; DOTGEN_FLAG_HIDE_MEM_EDGES) != 0) {</span></div>
<div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;<span class="comment">//      if (memReleaser-&gt;size() &gt; 0) {</span></div>
<div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;<span class="comment">//        for (const auto &amp;kv : *this-&gt;memReleaser) {</span></div>
<div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;<span class="comment">//          auto connector = kv.second-&gt;at(this-&gt;pipelineId);</span></div>
<div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;<span class="comment">//          oss &lt;&lt; std::string(&quot;mainThread&quot;) &lt;&lt; &quot; -&gt; &quot; &lt;&lt; connector-&gt;getDotId() &lt;&lt; &quot;;&quot; &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;<span class="comment">//        }</span></div>
<div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;<span class="comment">//        oss &lt;&lt; &quot;mainThread[label=\&quot;Main Thread\&quot;];\n&quot;;</span></div>
<div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;<span class="comment">//      }</span></div>
<div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;<span class="comment">//    return oss.str();</span></div>
<div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;<span class="comment">//  /**</span></div>
<div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;<span class="comment">//   * Generates the dot graph as a string</span></div>
<div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;<span class="comment">//   */</span></div>
<div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;<span class="comment">//  std::string genDotGraph(int flags) {</span></div>
<div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;<span class="comment">//    std::ostringstream oss;</span></div>
<div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;<span class="comment">//    oss &lt;&lt; &quot;digraph { rankdir=\&quot;TB\&quot;&quot; &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;<span class="comment">//    oss &lt;&lt; &quot;forcelabels=true;&quot; &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;<span class="comment">//    oss &lt;&lt; &quot;node[shape=record, fontsize=10, fontname=\&quot;Verdana\&quot;];&quot; &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;<span class="comment">//    oss &lt;&lt; &quot;edge[fontsize=10, fontname=\&quot;Verdana\&quot;];&quot; &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;<span class="comment">//    oss &lt;&lt; &quot;graph [compound=true];&quot; &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;<span class="comment">//    for (AnyTaskScheduler *bTask : *vertices) {</span></div>
<div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;<span class="comment">//      oss &lt;&lt; bTask-&gt;getDot(flags);</span></div>
<div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;<span class="comment">//    if (this-&gt;graphInputConsumers-&gt;size() &gt; 0)</span></div>
<div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;<span class="comment">//      oss &lt;&lt; this-&gt;input-&gt;getDotId() &lt;&lt; &quot;[label=\&quot;Graph Input\n&quot; &lt;&lt; this-&gt;input-&gt;getProducerCount() &lt;&lt;  (((DOTGEN_FLAG_SHOW_IN_OUT_TYPES &amp; flags) != 0) ? (&quot;\n&quot;+this-&gt;input-&gt;typeName()) : &quot;&quot;) &lt;&lt; &quot;\&quot;];&quot; &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;<span class="comment">//    if (this-&gt;graphOutputProducers-&gt;size() &gt; 0)</span></div>
<div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;<span class="comment">//      oss &lt;&lt; &quot;{ rank = sink; &quot; &lt;&lt; this-&gt;output-&gt;getDotId() &lt;&lt; &quot;[label=\&quot;Graph Output\n&quot; &lt;&lt; this-&gt;output-&gt;getProducerCount() &lt;&lt;  (((DOTGEN_FLAG_SHOW_IN_OUT_TYPES &amp; flags) != 0) ? (&quot;\n&quot;+this-&gt;output-&gt;typeName()) : &quot;&quot;) &lt;&lt; &quot;\&quot;]; }&quot; &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;<span class="comment">//    if ((flags &amp; DOTGEN_FLAG_HIDE_MEM_EDGES) == 0) {</span></div>
<div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;<span class="comment">//      if (memReleaser-&gt;size() &gt; 0) {</span></div>
<div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;<span class="comment">//        for (const auto &amp;kv : *this-&gt;memReleaser) {</span></div>
<div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;<span class="comment">//          for (const auto &amp;memConnector : *kv.second)</span></div>
<div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;<span class="comment">//            oss &lt;&lt; std::string(&quot;mainThread&quot;) &lt;&lt; &quot; -&gt; &quot; &lt;&lt; memConnector-&gt;getDotId() &lt;&lt; &quot;;&quot; &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;<span class="comment">//        }</span></div>
<div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;<span class="comment">//      }</span></div>
<div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;<span class="comment">//    if (oss.str().find(&quot;mainThread&quot;) != std::string::npos)</span></div>
<div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;<span class="comment">//    {</span></div>
<div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;<span class="comment">//      oss &lt;&lt; &quot;{ rank = sink; mainThread[label=\&quot;Main Thread\&quot;, fillcolor = aquamarine4]; }\n&quot;;</span></div>
<div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;<span class="comment">//#ifdef PROFILE</span></div>
<div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;<span class="comment">//    std::string desc = &quot;&quot;;</span></div>
<div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;<span class="comment">//    std::unordered_map&lt;std::string, double&gt; *timeMap;</span></div>
<div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;<span class="comment">//    std::unordered_map&lt;std::string, std::string&gt; *colorMap;</span></div>
<div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;<span class="comment">//    if ((flags &amp; DOTGEN_FLAG_HIDE_PROFILE_COMP_TIME) != 0)</span></div>
<div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;<span class="comment">//    {</span></div>
<div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;<span class="comment">//      desc = &quot;Compute Time (sec): &quot;;</span></div>
<div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;<span class="comment">//      timeMap = this-&gt;getComputeTimeAverages();</span></div>
<div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;<span class="comment">//    else if ((flags &amp; DOTGEN_FLAG_HIDE_PROFILE_WAIT_TIME) != 0)</span></div>
<div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;<span class="comment">//    {</span></div>
<div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;<span class="comment">//      desc = &quot;Wait Time (sec): &quot;;</span></div>
<div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;<span class="comment">//      timeMap = this-&gt;getWaitTimeAverages();</span></div>
<div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;<span class="comment">//    else if ((flags &amp; DOTGEN_FLAG_HIDE_PROFILE_MAX_Q_SZ) != 0)</span></div>
<div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;<span class="comment">//    {</span></div>
<div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;<span class="comment">//      desc = &quot;Max Q Size&quot;;</span></div>
<div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;<span class="comment">//      timeMap = this-&gt;getMaxQSizeAverages();</span></div>
<div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;<span class="comment">//    if (desc != &quot;&quot;) {</span></div>
<div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;<span class="comment">//      colorMap = this-&gt;genColorMap(timeMap);</span></div>
<div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;<span class="comment">//      oss &lt;&lt; this-&gt;genProfileGraph(flags, timeMap, desc, colorMap);</span></div>
<div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;<span class="comment">//      delete timeMap;</span></div>
<div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;<span class="comment">//      delete colorMap;</span></div>
<div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;<span class="comment">//#endif</span></div>
<div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;<span class="comment">//    oss &lt;&lt; &quot;}&quot; &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;<span class="comment">//    return oss.str();</span></div>
<div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;<span class="comment">//#ifdef PROFILE</span></div>
<div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;<span class="comment">//  std::unordered_map&lt;std::string, double&gt; *getComputeTimeAverages()</span></div>
<div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;<span class="comment">//  {</span></div>
<div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;<span class="comment">//    std::unordered_multimap&lt;std::string, long long int&gt; mmap;</span></div>
<div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;<span class="comment">//    this-&gt;gatherComputeTime(&amp;mmap);</span></div>
<div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;<span class="comment">//    return computeAverages&lt;long long int&gt;(&amp;mmap, 1000000.0);</span></div>
<div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;<span class="comment">//  std::unordered_map&lt;std::string, double&gt; *getWaitTimeAverages()</span></div>
<div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;<span class="comment">//  {</span></div>
<div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;<span class="comment">//    std::unordered_multimap&lt;std::string, long long int&gt; mmap;</span></div>
<div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;<span class="comment">//    this-&gt;gatherWaitTime(&amp;mmap);</span></div>
<div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;<span class="comment">//    return computeAverages&lt;long long int&gt;(&amp;mmap, 1000000.0);</span></div>
<div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;<span class="comment">//  std::unordered_map&lt;std::string, double&gt; *getMaxQSizeAverages()</span></div>
<div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;<span class="comment">//  {</span></div>
<div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;<span class="comment">//    std::unordered_multimap&lt;std::string, int&gt; mmap;</span></div>
<div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;<span class="comment">//    this-&gt;gatherMaxQSize(&amp;mmap);</span></div>
<div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;<span class="comment">//    return computeAverages&lt;int&gt;(&amp;mmap, 1.0);</span></div>
<div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;<span class="comment">//  template &lt;typename Type&gt;</span></div>
<div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;<span class="comment">//  std::unordered_map&lt;std::string, double&gt; *computeAverages(std::unordered_multimap&lt;std::string, Type&gt; *mmap, double divisor)</span></div>
<div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;<span class="comment">//  {</span></div>
<div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;<span class="comment">//    std::unordered_map&lt;std::string, double&gt; *ret = new std::unordered_map&lt;std::string, double&gt;();</span></div>
<div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;<span class="comment">//    std::string current(&quot;&quot;);</span></div>
<div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;<span class="comment">//    Type total = 0;</span></div>
<div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;<span class="comment">//    int count = 0;</span></div>
<div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;<span class="comment">//    // Loop over each</span></div>
<div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;<span class="comment">//    for (auto v : *mmap)</span></div>
<div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;<span class="comment">//    {</span></div>
<div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;<span class="comment">//      if (current != v.first) {</span></div>
<div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;<span class="comment">//        if (count != 0)</span></div>
<div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;<span class="comment">//        {</span></div>
<div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;<span class="comment">//          double avg = (double)total / (double) count;</span></div>
<div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;<span class="comment">//          ret-&gt;insert(std::pair&lt;std::string, double&gt;(current, (avg/divisor)));</span></div>
<div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;<span class="comment">//        }</span></div>
<div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;<span class="comment">//        else if (current != &quot;&quot;)</span></div>
<div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;<span class="comment">//        {</span></div>
<div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;<span class="comment">//          ret-&gt;insert(std::pair&lt;std::string, double&gt;(current, 0.0));</span></div>
<div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;<span class="comment">//        }</span></div>
<div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;<span class="comment">//        current = v.first;</span></div>
<div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;<span class="comment">//        total = 0;</span></div>
<div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;<span class="comment">//        count = 0;</span></div>
<div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;<span class="comment">//      }</span></div>
<div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;<span class="comment">//      if (v.second &gt; 0) {</span></div>
<div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;<span class="comment">//        total += v.second;</span></div>
<div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;<span class="comment">//        count++;</span></div>
<div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;<span class="comment">//      }</span></div>
<div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;<span class="comment">//    return ret;</span></div>
<div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;<span class="comment">//  void gatherComputeTime(std::unordered_multimap&lt;std::string, long long int&gt; *mmap) {</span></div>
<div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;<span class="comment">//    for (AnyTaskScheduler *bTask : *vertices) {</span></div>
<div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;<span class="comment">//      bTask-&gt;gatherComputeTime(mmap);</span></div>
<div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;<span class="comment">//  void gatherWaitTime(std::unordered_multimap&lt;std::string, long long int&gt; *mmap) {</span></div>
<div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;<span class="comment">//    for (AnyTaskScheduler *bTask : *vertices) {</span></div>
<div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;<span class="comment">//      bTask-&gt;gatherWaitTime(mmap);</span></div>
<div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;<span class="comment">//  virtual void gatherMaxQSize(std::unordered_multimap&lt;std::string, int&gt; *mmap) {</span></div>
<div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;<span class="comment">//    for (AnyTaskScheduler *bTask : *vertices) {</span></div>
<div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;<span class="comment">//      bTask-&gt;gatherMaxQSize(mmap);</span></div>
<div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;<span class="comment">//  std::unordered_map&lt;std::string, std::string&gt; *genColorMap(std::unordered_map&lt;std::string, double&gt; *mmap)</span></div>
<div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;<span class="comment">//  {</span></div>
<div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;<span class="comment">//    std::unordered_map&lt;std::string, std::string&gt; *colorMap = new std::unordered_map&lt;std::string, std::string&gt;();</span></div>
<div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;<span class="comment">//    int rColor[10] = {0,0,0,0,85,170,255,255,255,255};</span></div>
<div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;<span class="comment">//    int gColor[10] = {0,85,170,255,255,255,255,170,85,0};</span></div>
<div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;<span class="comment">//    int bColor[10] = {255,255,255,255,170,85,0,0,0,0};</span></div>
<div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;<span class="comment">//    std::deque&lt;double&gt; vals;</span></div>
<div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;<span class="comment">//    double maxTime = 0.0;</span></div>
<div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;<span class="comment">//    double totalTime = 0.0;</span></div>
<div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;<span class="comment">//    for (auto v : *mmap)</span></div>
<div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;<span class="comment">//    {</span></div>
<div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;<span class="comment">//      if (v.second &gt; 0) {</span></div>
<div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;<span class="comment">//        totalTime += v.second;</span></div>
<div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;<span class="comment">//      }</span></div>
<div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;<span class="comment">//      if (maxTime &lt; v.second)</span></div>
<div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;<span class="comment">//        maxTime = v.second;</span></div>
<div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;<span class="comment">//    for (auto v : *mmap)</span></div>
<div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;<span class="comment">//    {</span></div>
<div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;<span class="comment">//      if (v.second == 0.0) {</span></div>
<div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;<span class="comment">//        colorMap-&gt;insert(std::pair&lt;std::string, std::string&gt;(v.first, &quot;black&quot;));</span></div>
<div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;<span class="comment">//        continue;</span></div>
<div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;<span class="comment">//      }</span></div>
<div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;<span class="comment">//      int red = 0;</span></div>
<div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;<span class="comment">//      int green = 0;</span></div>
<div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;<span class="comment">//      int blue = 0;</span></div>
<div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;<span class="comment">//      // compute percentage of totalTime</span></div>
<div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;<span class="comment">//      int perc = (int) (v.second / maxTime * 100.0);</span></div>
<div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;<span class="comment">//      if (perc % 10 != 0)</span></div>
<div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;<span class="comment">//        perc = perc + 10 - (perc % 10);</span></div>
<div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;<span class="comment">//      int index = (perc / 10);</span></div>
<div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;<span class="comment">//      if (index &lt; 0)</span></div>
<div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;<span class="comment">//        index = 0;</span></div>
<div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;<span class="comment">//      if (index &gt;= 10)</span></div>
<div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;<span class="comment">//        index = 9;</span></div>
<div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;<span class="comment">//      red = rColor[index];</span></div>
<div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;<span class="comment">//      green = gColor[index];</span></div>
<div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;<span class="comment">//      blue = bColor[index];</span></div>
<div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;<span class="comment">//      char hexcol[16];</span></div>
<div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;<span class="comment">//      snprintf(hexcol, sizeof(hexcol), &quot;%02x%02x%02x&quot;, red &amp; 0xff, green &amp; 0xff ,blue &amp; 0xff);</span></div>
<div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;<span class="comment">//      std::string color(hexcol);</span></div>
<div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;<span class="comment">//      color = &quot;#&quot; + color;</span></div>
<div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;<span class="comment">//      colorMap-&gt;insert(std::pair&lt;std::string, std::string&gt;(v.first, color));</span></div>
<div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;<span class="comment">//    return colorMap;</span></div>
<div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;<span class="comment">//  std::string genProfileGraph(int flags, std::unordered_map&lt;std::string, double&gt; *mmap, std::string desc, std::unordered_map&lt;std::string, std::string&gt; *colorMap) {</span></div>
<div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;<span class="comment">//    std::ostringstream oss;</span></div>
<div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;<span class="comment">//    for (AnyTaskScheduler *bTask : *vertices) {</span></div>
<div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;<span class="comment">//      if (mmap-&gt;find(bTask-&gt;getNameWithPipID()) == mmap-&gt;end()) {</span></div>
<div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;<span class="comment">//        continue;</span></div>
<div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;<span class="comment">//      }</span></div>
<div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;<span class="comment">//      oss &lt;&lt; bTask-&gt;genDotProfile(flags, mmap, desc, colorMap);</span></div>
<div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;<span class="comment">//    return oss.str();</span></div>
<div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;<span class="comment">//#endif</span></div>
<div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;</div>
<div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;<span class="comment">//  /**</span></div>
<div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;<span class="comment">//   * @internal</span></div>
<div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;<span class="comment">//   * Updates the TaskGraph input consumer</span></div>
<div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;<span class="comment">//   * @param connector the connector to update the input consumers</span></div>
<div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;<span class="comment">//   *</span></div>
<div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;<span class="comment">//   * @note This function should only be called by the HTGS API</span></div>
<div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;<span class="comment">//   */</span></div>
<div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;<span class="comment">//  void updateGraphConsumerTask(std::shared_ptr&lt;Connector&lt;T&gt;&gt; connector) {</span></div>
<div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;<span class="comment">//    for (AnyTaskScheduler *bs : *this-&gt;graphInputConsumers) {</span></div>
<div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;<span class="comment">//      bs-&gt;setInputConnector(connector);</span></div>
<div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;<span class="comment">//    this-&gt;input = connector;</span></div>
<div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;<span class="comment">//  /**</span></div>
<div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;<span class="comment">//   * @internal</span></div>
<div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;<span class="comment">//   * Updates the TaskGraph output producers</span></div>
<div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;<span class="comment">//   * @param connector the connector to update the output producers</span></div>
<div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;<span class="comment">//   * @param increment whether to increment the number of producers for the connector</span></div>
<div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;<span class="comment">//   *</span></div>
<div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;<span class="comment">//   * @note This function should only be called by the HTGS API</span></div>
<div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;<span class="comment">//   */</span></div>
<div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;<span class="comment">//  void updateGraphOutputProducers(std::shared_ptr&lt;Connector&lt;U&gt;&gt; connector, bool increment) {</span></div>
<div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;<span class="comment">//    for (AnyTaskScheduler *bs : *this-&gt;graphOutputProducers) {</span></div>
<div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;<span class="comment">//      bs-&gt;setOutputConnector(connector);</span></div>
<div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;<span class="comment">//      if (increment)</span></div>
<div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;<span class="comment">//          connector-&gt;incrementInputTaskCount();</span></div>
<div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;<span class="comment">//    this-&gt;output = connector;</span></div>
<div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;<span class="comment">//  /**</span></div>
<div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;<span class="comment">//   * Gets the output producers associated with this TaskGraph</span></div>
<div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;<span class="comment">//   * @return the output producers for the TaskGraph</span></div>
<div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;<span class="comment">//   */</span></div>
<div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;<span class="comment">//  std::list&lt;AnyTaskScheduler *&gt; *getOutputProducers() {</span></div>
<div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;<span class="comment">//    return this-&gt;graphOutputProducers;</span></div>
<div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;<span class="comment">//  /**</span></div>
<div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;<span class="comment">//   * Adds a graph input consumer to process the input of the TaskGraph</span></div>
<div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;<span class="comment">//   * @param iTask the ITask that will process the input</span></div>
<div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;<span class="comment">//   */</span></div>
<div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;<span class="comment">//  template&lt;class V&gt;</span></div>
<div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;<span class="comment">//  void addGraphInputConsumer(ITask&lt;T, V&gt; *iTask) {</span></div>
<div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;<span class="comment">//    TaskScheduler&lt;T, V&gt; * task = getTaskManager(iTask, false);</span></div>
<div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;<span class="comment">//    addGraphInputConsumer(task);</span></div>
<div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;<span class="comment">//  /**</span></div>
<div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;<span class="comment">//   * Adds a graph output producer to produce output for the TaskGraph</span></div>
<div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;<span class="comment">//   * @param iTask the ITask that will produce output</span></div>
<div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;<span class="comment">//   */</span></div>
<div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;<span class="comment">//  template&lt;class V&gt;</span></div>
<div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;<span class="comment">//  void addGraphOutputProducer(ITask&lt;V, U&gt; *iTask) {</span></div>
<div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;<span class="comment">//    TaskScheduler&lt;V, U&gt; *task = getTaskManager(iTask, false);</span></div>
<div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;<span class="comment">//    addGraphOutputProducer(task);</span></div>
<div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;<span class="comment">//  /**</span></div>
<div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;<span class="comment">//   * Increments the number of producers sending data into the input for the TaskGraph.</span></div>
<div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;<span class="comment">//   * @note Specify the TaskGraph input using addGraphInputConsumer() and when the input stream has finished producing data use finishedProducingData()</span></div>
<div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;<span class="comment">//   */</span></div>
<div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;<span class="comment">//  void incrementGraphInputProducer() {</span></div>
<div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;<span class="comment">//    this-&gt;input-&gt;incrementInputTaskCount();</span></div>
<div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;<span class="comment">//  /**</span></div>
<div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;<span class="comment">//   * Indicates that the input stream has finished producing data for the TaskGraph.</span></div>
<div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;<span class="comment">//   * @note Must have a matching call to incrementGraphInputProducer()</span></div>
<div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;<span class="comment">//   */</span></div>
<div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;<span class="comment">//  void finishedProducingData() {</span></div>
<div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;<span class="comment">//    this-&gt;input-&gt;producerFinished();</span></div>
<div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;<span class="comment">//    this-&gt;input-&gt;wakeupConsumer();</span></div>
<div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;<span class="comment">//  /**</span></div>
<div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;<span class="comment">//   * Creates a copy of the TaskGraph with the specified pipeline Id and number of pipelines.</span></div>
<div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;<span class="comment">//   * The copy contains the same structure as the original TaskGraph, but with new instances of</span></div>
<div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;<span class="comment">//   * every Task, ITask, and Connector</span></div>
<div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;<span class="comment">//   * @param pipelineId the pipeline Id</span></div>
<div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;<span class="comment">//   * @param numPipelines the number of pipelines</span></div>
<div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;<span class="comment">//   * @return a copy of the TaskGraph</span></div>
<div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;<span class="comment">//   */</span></div>
<div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;<span class="comment">//  TaskGraph&lt;T, U&gt; *copy(int pipelineId, int numPipelines) {</span></div>
<div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;<span class="comment">//    TaskGraph&lt;T, U&gt; *graphCopy = new TaskGraph&lt;T, U&gt;();</span></div>
<div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;<span class="comment">//    // Pass the reference of the mem releaser and mmTypeMap to the copy</span></div>
<div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;<span class="comment">//    graphCopy-&gt;setMMTypeMap(this-&gt;mmTypeMap);</span></div>
<div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;<span class="comment">//    graphCopy-&gt;setMemReleaser(this-&gt;memReleaser);</span></div>
<div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;<span class="comment">//    graphCopy-&gt;setPipelineId(pipelineId);</span></div>
<div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;<span class="comment">//    std::map&lt;AnyTaskScheduler *, AnyTaskScheduler *&gt; copyMap;</span></div>
<div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;<span class="comment">//    std::map&lt;AnyITask *, AnyITask *&gt; copyITaskMap;</span></div>
<div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;<span class="comment">//    // Create a clone map to lookup pointers</span></div>
<div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;<span class="comment">//    for (AnyTaskScheduler *task : *this-&gt;vertices) {</span></div>
<div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;<span class="comment">//      AnyTaskScheduler *taskCopy = task-&gt;copy(false);</span></div>
<div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;<span class="comment">//      taskCopy-&gt;setPipelineId(pipelineId);</span></div>
<div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;<span class="comment">//      taskCopy-&gt;setNumPipelines(numPipelines);</span></div>
<div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;<span class="comment">//      copyMap.insert(std::pair&lt;AnyTaskScheduler *, AnyTaskScheduler *&gt;(task, taskCopy));</span></div>
<div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;<span class="comment">//      copyITaskMap.insert(std::pair&lt;AnyITask *, AnyITask *&gt;(task-&gt;getTaskFunction(), taskCopy-&gt;getTaskFunction()));</span></div>
<div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;<span class="comment">//    // Copy producer consumers</span></div>
<div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;<span class="comment">//    for (ProducerConsumerKey *prConKey : *this-&gt;producerConsumerKeys) {</span></div>
<div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;<span class="comment">//      AnyTaskScheduler *producer = prConKey-&gt;getProducer();</span></div>
<div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;<span class="comment">//      AnyTaskScheduler *consumer = prConKey-&gt;getConsumer();</span></div>
<div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;<span class="comment">//      AnyTaskScheduler *producerCopy = copyMap.find(producer)-&gt;second;</span></div>
<div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;<span class="comment">//      AnyTaskScheduler *consumerCopy = copyMap.find(consumer)-&gt;second;</span></div>
<div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;<span class="comment">//      graphCopy-&gt;addEdge(producerCopy, consumerCopy, producer-&gt;getOutputBaseConnector());</span></div>
<div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;<span class="comment">//      consumerCopy-&gt;addPipelineConnector(pipelineId);</span></div>
<div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160;<span class="comment">//    // Copy bookkeepers</span></div>
<div class="line"><a name="l00960"></a><span class="lineno">  960</span>&#160;<span class="comment">//    for (BookkeeperKey *bkKey : *this-&gt;bookkeeperKeys) {</span></div>
<div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;<span class="comment">//      AnyTaskScheduler *bkTask = bkKey-&gt;getBkTask();</span></div>
<div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;<span class="comment">//      BaseBaseRuleManager *ruleMan = bkKey-&gt;getRuleMan();</span></div>
<div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160;<span class="comment">//      AnyTaskScheduler *outputTask = bkKey-&gt;getOutputTask();</span></div>
<div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160;<span class="comment">//      AnyTaskScheduler *outputTaskCopy = copyMap.find(outputTask)-&gt;second;</span></div>
<div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;<span class="comment">//      AnyTaskScheduler *bkTaskCopy = copyMap.find(bkTask)-&gt;second;</span></div>
<div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;<span class="comment">//      BaseBaseRuleManager *ruleManCopy = ruleMan-&gt;copy();</span></div>
<div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160;<span class="comment">//      AnyITask *bkITask = bkTaskCopy-&gt;getTaskFunction();</span></div>
<div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;<span class="comment">//      graphCopy-&gt;addRuleManager(bkTaskCopy, bkITask, ruleManCopy, outputTaskCopy, ruleMan-&gt;getConnector());</span></div>
<div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;<span class="comment">//      outputTaskCopy-&gt;addPipelineConnector(pipelineId);</span></div>
<div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;<span class="comment">//    for (CustomEdgePair cep : *customEdgeList) {</span></div>
<div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;<span class="comment">//      AnyTaskScheduler *producerTask = cep.first.first;</span></div>
<div class="line"><a name="l00978"></a><span class="lineno">  978</span>&#160;<span class="comment">//      AnyTaskScheduler *consumerTask = cep.first.second;</span></div>
<div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;<span class="comment">//      ICustomEdge *customEdge = cep.second;</span></div>
<div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;<span class="comment">//      // Find copy</span></div>
<div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;<span class="comment">//      AnyTaskScheduler *producerTaskCopy = copyMap.find(producerTask)-&gt;second;</span></div>
<div class="line"><a name="l00984"></a><span class="lineno">  984</span>&#160;<span class="comment">//      AnyTaskScheduler *consumerTaskCopy = copyMap.find(consumerTask)-&gt;second;</span></div>
<div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;<span class="comment">//      ICustomEdge *customEdgeCopy = customEdge-&gt;copy();</span></div>
<div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;<span class="comment">//      graphCopy-&gt;addCustomEdge(producerTaskCopy, consumerTaskCopy, customEdgeCopy, pipelineId);</span></div>
<div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;<span class="comment">//    // Copy graph input consumers</span></div>
<div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;<span class="comment">//    for (AnyTaskScheduler *task : *this-&gt;graphInputConsumers) {</span></div>
<div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;<span class="comment">//      AnyTaskScheduler *taskCopy = copyMap.find(task)-&gt;second;</span></div>
<div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;<span class="comment">//      graphCopy-&gt;addGraphInputConsumer(taskCopy);</span></div>
<div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;<span class="comment">//    // Copy graph output producers</span></div>
<div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;<span class="comment">//    for (AnyTaskScheduler *task : *this-&gt;graphOutputProducers) {</span></div>
<div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;<span class="comment">//      AnyTaskScheduler *taskCopy = copyMap.find(task)-&gt;second;</span></div>
<div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;<span class="comment">//      graphCopy-&gt;addGraphOutputProducer(taskCopy);</span></div>
<div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;<span class="comment">//    // Copy memory managers</span></div>
<div class="line"><a name="l01005"></a><span class="lineno"> 1005</span>&#160;<span class="comment">//    for (MemoryManagerKey *mmKey : *this-&gt;memoryManagerKeys) {</span></div>
<div class="line"><a name="l01006"></a><span class="lineno"> 1006</span>&#160;<span class="comment">//      std::string name = mmKey-&gt;getName();</span></div>
<div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;<span class="comment">//      AnyITask *memGetter = mmKey-&gt;getMemGetter();</span></div>
<div class="line"><a name="l01008"></a><span class="lineno"> 1008</span>&#160;<span class="comment">//      AnyITask *memReleaser = mmKey-&gt;getMemReleaser();</span></div>
<div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;<span class="comment">//      AnyTaskScheduler *memTask = mmKey-&gt;getMemTask();</span></div>
<div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;<span class="comment">//      AnyITask *memGetterCopy = nullptr;</span></div>
<div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;<span class="comment">//      if (copyITaskMap.find(memGetter) != copyITaskMap.end())</span></div>
<div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;<span class="comment">//        memGetterCopy = copyITaskMap.find(memGetter)-&gt;second;</span></div>
<div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;<span class="comment">//      else</span></div>
<div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;<span class="comment">//        memGetterCopy = memGetter;</span></div>
<div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;<span class="comment">//      AnyITask *memReleaserCopy = nullptr;</span></div>
<div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;<span class="comment">//      if (memReleaser != nullptr) {</span></div>
<div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;<span class="comment">//        if (copyITaskMap.find(memReleaser) != copyITaskMap.end())</span></div>
<div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;<span class="comment">//          memReleaserCopy = copyITaskMap.find(memReleaser)-&gt;second;</span></div>
<div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;<span class="comment">//        else</span></div>
<div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;<span class="comment">//          memReleaserCopy = memReleaser;</span></div>
<div class="line"><a name="l01023"></a><span class="lineno"> 1023</span>&#160;<span class="comment">//      }</span></div>
<div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160;<span class="comment">//      AnyTaskScheduler *memTaskCopy = copyMap.find(memTask)-&gt;second;</span></div>
<div class="line"><a name="l01027"></a><span class="lineno"> 1027</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01028"></a><span class="lineno"> 1028</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01029"></a><span class="lineno"> 1029</span>&#160;<span class="comment">//      if (memReleaserCopy == nullptr)</span></div>
<div class="line"><a name="l01030"></a><span class="lineno"> 1030</span>&#160;<span class="comment">//      {</span></div>
<div class="line"><a name="l01031"></a><span class="lineno"> 1031</span>&#160;<span class="comment">//        graphCopy-&gt;addGraphMemoryManagerEdge(name, memGetterCopy, memTaskCopy,</span></div>
<div class="line"><a name="l01032"></a><span class="lineno"> 1032</span>&#160;<span class="comment">//                                             memTask-&gt;getInputBaseConnector(), mmKey-&gt;getMMType());</span></div>
<div class="line"><a name="l01033"></a><span class="lineno"> 1033</span>&#160;<span class="comment">//      }</span></div>
<div class="line"><a name="l01034"></a><span class="lineno"> 1034</span>&#160;<span class="comment">//      else {</span></div>
<div class="line"><a name="l01035"></a><span class="lineno"> 1035</span>&#160;<span class="comment">//        graphCopy-&gt;addMemoryManagerEdge(name, memGetterCopy, memReleaserCopy, memTaskCopy,</span></div>
<div class="line"><a name="l01036"></a><span class="lineno"> 1036</span>&#160;<span class="comment">//                                        memTask-&gt;getInputBaseConnector(), mmKey-&gt;getMMType(), mmKey-&gt;isIsReleaserOutsideGraph());</span></div>
<div class="line"><a name="l01037"></a><span class="lineno"> 1037</span>&#160;<span class="comment">//      }</span></div>
<div class="line"><a name="l01038"></a><span class="lineno"> 1038</span>&#160;<span class="comment">//      memTaskCopy-&gt;addPipelineConnector(pipelineId);</span></div>
<div class="line"><a name="l01039"></a><span class="lineno"> 1039</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01040"></a><span class="lineno"> 1040</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01041"></a><span class="lineno"> 1041</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01042"></a><span class="lineno"> 1042</span>&#160;<span class="comment">//    return graphCopy;</span></div>
<div class="line"><a name="l01043"></a><span class="lineno"> 1043</span>&#160;<span class="comment">//  };</span></div>
<div class="line"><a name="l01044"></a><span class="lineno"> 1044</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01045"></a><span class="lineno"> 1045</span>&#160;<span class="comment">//  /**</span></div>
<div class="line"><a name="l01046"></a><span class="lineno"> 1046</span>&#160;<span class="comment">//   * Adds an edge to the TaskGraph.</span></div>
<div class="line"><a name="l01047"></a><span class="lineno"> 1047</span>&#160;<span class="comment">//   * The output type of the produce must match the input type of the consumer. This will create two TaskScheduler</span></div>
<div class="line"><a name="l01048"></a><span class="lineno"> 1048</span>&#160;<span class="comment">//   * vertices (or lookup an existing vertex for the producer or consumer if that vertex already exists in the graph) and</span></div>
<div class="line"><a name="l01049"></a><span class="lineno"> 1049</span>&#160;<span class="comment">//   * connect the two vertices through a Connector.</span></div>
<div class="line"><a name="l01050"></a><span class="lineno"> 1050</span>&#160;<span class="comment">//   * @param producer the producer ITask</span></div>
<div class="line"><a name="l01051"></a><span class="lineno"> 1051</span>&#160;<span class="comment">//   * @param consumer the consumer ITask</span></div>
<div class="line"><a name="l01052"></a><span class="lineno"> 1052</span>&#160;<span class="comment">//   */</span></div>
<div class="line"><a name="l01053"></a><span class="lineno"> 1053</span>&#160;<span class="comment">//  template&lt;class V, class W, class X&gt;</span></div>
<div class="line"><a name="l01054"></a><span class="lineno"> 1054</span>&#160;<span class="comment">//  void addEdge(ITask&lt;V, W&gt; *producer, ITask&lt;W, X&gt; *consumer) {</span></div>
<div class="line"><a name="l01055"></a><span class="lineno"> 1055</span>&#160;<span class="comment">//    TaskScheduler&lt;V, W&gt; *producerTask = getTaskManager(producer, false);</span></div>
<div class="line"><a name="l01056"></a><span class="lineno"> 1056</span>&#160;<span class="comment">//    TaskScheduler&lt;W, X&gt; *consumerTask = getTaskManager(consumer, false);</span></div>
<div class="line"><a name="l01057"></a><span class="lineno"> 1057</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01058"></a><span class="lineno"> 1058</span>&#160;<span class="comment">//    addEdge(producerTask, consumerTask);</span></div>
<div class="line"><a name="l01059"></a><span class="lineno"> 1059</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01060"></a><span class="lineno"> 1060</span>&#160;<span class="comment">//  };</span></div>
<div class="line"><a name="l01061"></a><span class="lineno"> 1061</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01062"></a><span class="lineno"> 1062</span>&#160;<span class="comment">//  /**</span></div>
<div class="line"><a name="l01063"></a><span class="lineno"> 1063</span>&#160;<span class="comment">//   * Adds an IRule to the TaskGraph connecting a Bookkeeper with a consumer ITask.</span></div>
<div class="line"><a name="l01064"></a><span class="lineno"> 1064</span>&#160;<span class="comment">//   * The Bookkeeper type must match the input of the IRule and</span></div>
<div class="line"><a name="l01065"></a><span class="lineno"> 1065</span>&#160;<span class="comment">//   * the output type of the IRule must match the input type of the ITask consumer</span></div>
<div class="line"><a name="l01066"></a><span class="lineno"> 1066</span>&#160;<span class="comment">//   * @param bk the Bookkeeper</span></div>
<div class="line"><a name="l01067"></a><span class="lineno"> 1067</span>&#160;<span class="comment">//   * @param consumer the ITask consumer</span></div>
<div class="line"><a name="l01068"></a><span class="lineno"> 1068</span>&#160;<span class="comment">//   * @param rule the IRule to connect the Bookkeeper and the consumer ITask</span></div>
<div class="line"><a name="l01069"></a><span class="lineno"> 1069</span>&#160;<span class="comment">//   */</span></div>
<div class="line"><a name="l01070"></a><span class="lineno"> 1070</span>&#160;<span class="comment">//  template&lt;class V, class W, class X&gt;</span></div>
<div class="line"><a name="l01071"></a><span class="lineno"> 1071</span>&#160;<span class="comment">//  void addRule(Bookkeeper&lt;V&gt; *bk, ITask&lt;W, X&gt; *consumer, IRule&lt;V, W&gt; * rule) {</span></div>
<div class="line"><a name="l01072"></a><span class="lineno"> 1072</span>&#160;<span class="comment">//    TaskScheduler&lt;V, VoidData&gt; *bkTask = getTaskManager(bk, false);</span></div>
<div class="line"><a name="l01073"></a><span class="lineno"> 1073</span>&#160;<span class="comment">//    TaskScheduler&lt;W, X&gt; *consumerTask = getTaskManager(consumer, false);</span></div>
<div class="line"><a name="l01074"></a><span class="lineno"> 1074</span>&#160;<span class="comment">//    RuleManager&lt;V, W&gt; *ruleMan = getRuleManager(bk, consumer);</span></div>
<div class="line"><a name="l01075"></a><span class="lineno"> 1075</span>&#160;<span class="comment">//    std::shared_ptr&lt;IRule&lt;V, W&gt;&gt; iRuleShr = getIRule(rule);</span></div>
<div class="line"><a name="l01076"></a><span class="lineno"> 1076</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01077"></a><span class="lineno"> 1077</span>&#160;<span class="comment">//    ruleMan-&gt;addRule(iRuleShr);</span></div>
<div class="line"><a name="l01078"></a><span class="lineno"> 1078</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01079"></a><span class="lineno"> 1079</span>&#160;<span class="comment">//    addRuleManager(bkTask, bk, ruleMan, consumerTask);</span></div>
<div class="line"><a name="l01080"></a><span class="lineno"> 1080</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l01081"></a><span class="lineno"> 1081</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01082"></a><span class="lineno"> 1082</span>&#160;<span class="comment">//  /**</span></div>
<div class="line"><a name="l01083"></a><span class="lineno"> 1083</span>&#160;<span class="comment">//   * Adds a custom edge to the TaskGraph.</span></div>
<div class="line"><a name="l01084"></a><span class="lineno"> 1084</span>&#160;<span class="comment">//   * The ICustomEdge represents an interface to describe how to add the edge to the graph.</span></div>
<div class="line"><a name="l01085"></a><span class="lineno"> 1085</span>&#160;<span class="comment">//   * @param customEdge the custom edge to be added</span></div>
<div class="line"><a name="l01086"></a><span class="lineno"> 1086</span>&#160;<span class="comment">//   */</span></div>
<div class="line"><a name="l01087"></a><span class="lineno"> 1087</span>&#160;<span class="comment">//  void addCustomEdge(ICustomEdge *customEdge) {</span></div>
<div class="line"><a name="l01088"></a><span class="lineno"> 1088</span>&#160;<span class="comment">//    AnyTaskScheduler *producerTask = nullptr;</span></div>
<div class="line"><a name="l01089"></a><span class="lineno"> 1089</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01090"></a><span class="lineno"> 1090</span>&#160;<span class="comment">//    if (this-&gt;iTaskMap-&gt;find(customEdge-&gt;getProducerITask()) != this-&gt;iTaskMap-&gt;end()) {</span></div>
<div class="line"><a name="l01091"></a><span class="lineno"> 1091</span>&#160;<span class="comment">//      producerTask = this-&gt;iTaskMap-&gt;find(customEdge-&gt;getProducerITask())-&gt;second;</span></div>
<div class="line"><a name="l01092"></a><span class="lineno"> 1092</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01093"></a><span class="lineno"> 1093</span>&#160;<span class="comment">//    else {</span></div>
<div class="line"><a name="l01094"></a><span class="lineno"> 1094</span>&#160;<span class="comment">//      producerTask = customEdge-&gt;createProducerTask();</span></div>
<div class="line"><a name="l01095"></a><span class="lineno"> 1095</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01096"></a><span class="lineno"> 1096</span>&#160;<span class="comment">//      if (producerTask == nullptr) {</span></div>
<div class="line"><a name="l01097"></a><span class="lineno"> 1097</span>&#160;<span class="comment">//        std::cerr</span></div>
<div class="line"><a name="l01098"></a><span class="lineno"> 1098</span>&#160;<span class="comment">//            &lt;&lt; &quot;Custom edge defines the producer as nullptr, this may require that the producer should already exist in the graph&quot;</span></div>
<div class="line"><a name="l01099"></a><span class="lineno"> 1099</span>&#160;<span class="comment">//            &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l01100"></a><span class="lineno"> 1100</span>&#160;<span class="comment">//        throw std::invalid_argument(&quot;Must add producer iTask to graph before adding as custom edge&quot;);</span></div>
<div class="line"><a name="l01101"></a><span class="lineno"> 1101</span>&#160;<span class="comment">//      }</span></div>
<div class="line"><a name="l01102"></a><span class="lineno"> 1102</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01103"></a><span class="lineno"> 1103</span>&#160;<span class="comment">//      this-&gt;iTaskMap-&gt;insert(ITaskPair(customEdge-&gt;getProducerITask(), producerTask));</span></div>
<div class="line"><a name="l01104"></a><span class="lineno"> 1104</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01105"></a><span class="lineno"> 1105</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01106"></a><span class="lineno"> 1106</span>&#160;<span class="comment">//    AnyTaskScheduler *consumerTask = nullptr;</span></div>
<div class="line"><a name="l01107"></a><span class="lineno"> 1107</span>&#160;<span class="comment">//    if (this-&gt;iTaskMap-&gt;find(customEdge-&gt;getConsumerITask()) != this-&gt;iTaskMap-&gt;end()) {</span></div>
<div class="line"><a name="l01108"></a><span class="lineno"> 1108</span>&#160;<span class="comment">//      consumerTask = this-&gt;iTaskMap-&gt;find(customEdge-&gt;getConsumerITask())-&gt;second;</span></div>
<div class="line"><a name="l01109"></a><span class="lineno"> 1109</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01110"></a><span class="lineno"> 1110</span>&#160;<span class="comment">//    else {</span></div>
<div class="line"><a name="l01111"></a><span class="lineno"> 1111</span>&#160;<span class="comment">//      consumerTask = customEdge-&gt;createConsumerTask();</span></div>
<div class="line"><a name="l01112"></a><span class="lineno"> 1112</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01113"></a><span class="lineno"> 1113</span>&#160;<span class="comment">//      if (consumerTask == nullptr) {</span></div>
<div class="line"><a name="l01114"></a><span class="lineno"> 1114</span>&#160;<span class="comment">//        std::cerr</span></div>
<div class="line"><a name="l01115"></a><span class="lineno"> 1115</span>&#160;<span class="comment">//            &lt;&lt; &quot;Custom edge defines the consumer as nullptr, this may require that the consumer should already exist in the graph&quot;</span></div>
<div class="line"><a name="l01116"></a><span class="lineno"> 1116</span>&#160;<span class="comment">//            &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l01117"></a><span class="lineno"> 1117</span>&#160;<span class="comment">//        throw std::invalid_argument(&quot;Must add consumer iTask to graph before adding as custom edge&quot;);</span></div>
<div class="line"><a name="l01118"></a><span class="lineno"> 1118</span>&#160;<span class="comment">//      }</span></div>
<div class="line"><a name="l01119"></a><span class="lineno"> 1119</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01120"></a><span class="lineno"> 1120</span>&#160;<span class="comment">//      this-&gt;iTaskMap-&gt;insert(ITaskPair(customEdge-&gt;getConsumerITask(), consumerTask));</span></div>
<div class="line"><a name="l01121"></a><span class="lineno"> 1121</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01122"></a><span class="lineno"> 1122</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01123"></a><span class="lineno"> 1123</span>&#160;<span class="comment">//    std::shared_ptr&lt;AnyConnector&gt; connector = nullptr;</span></div>
<div class="line"><a name="l01124"></a><span class="lineno"> 1124</span>&#160;<span class="comment">//    if (customEdge-&gt;useConnector()) {</span></div>
<div class="line"><a name="l01125"></a><span class="lineno"> 1125</span>&#160;<span class="comment">//      if (consumerTaskConnectorMap-&gt;find(consumerTask) != this-&gt;consumerTaskConnectorMap-&gt;end()) {</span></div>
<div class="line"><a name="l01126"></a><span class="lineno"> 1126</span>&#160;<span class="comment">//        connector = this-&gt;consumerTaskConnectorMap-&gt;find(consumerTask)-&gt;second;</span></div>
<div class="line"><a name="l01127"></a><span class="lineno"> 1127</span>&#160;<span class="comment">//      }</span></div>
<div class="line"><a name="l01128"></a><span class="lineno"> 1128</span>&#160;<span class="comment">//      else {</span></div>
<div class="line"><a name="l01129"></a><span class="lineno"> 1129</span>&#160;<span class="comment">//        connector = std::shared_ptr&lt;AnyConnector&gt;(customEdge-&gt;createConnector());</span></div>
<div class="line"><a name="l01130"></a><span class="lineno"> 1130</span>&#160;<span class="comment">//        consumerTaskConnectorMap-&gt;insert(ConnectorPair(consumerTask, connector));</span></div>
<div class="line"><a name="l01131"></a><span class="lineno"> 1131</span>&#160;<span class="comment">//      }</span></div>
<div class="line"><a name="l01132"></a><span class="lineno"> 1132</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01133"></a><span class="lineno"> 1133</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01134"></a><span class="lineno"> 1134</span>&#160;<span class="comment">//    std::pair&lt;AnyTaskScheduler *, AnyTaskScheduler *&gt; prodConsPair(producerTask, consumerTask);</span></div>
<div class="line"><a name="l01135"></a><span class="lineno"> 1135</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01136"></a><span class="lineno"> 1136</span>&#160;<span class="comment">//    CustomEdgePair testPair(prodConsPair, customEdge);</span></div>
<div class="line"><a name="l01137"></a><span class="lineno"> 1137</span>&#160;<span class="comment">//    auto i = std::find_if(customEdgeList-&gt;begin(), customEdgeList-&gt;end(), CustomEdgeComparator(testPair));</span></div>
<div class="line"><a name="l01138"></a><span class="lineno"> 1138</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01139"></a><span class="lineno"> 1139</span>&#160;<span class="comment">//    if (i == customEdgeList-&gt;end()) {</span></div>
<div class="line"><a name="l01140"></a><span class="lineno"> 1140</span>&#160;<span class="comment">//      this-&gt;customEdgeList-&gt;push_back(testPair);</span></div>
<div class="line"><a name="l01141"></a><span class="lineno"> 1141</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01142"></a><span class="lineno"> 1142</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01143"></a><span class="lineno"> 1143</span>&#160;<span class="comment">//    customEdge-&gt;applyGraphConnection(producerTask, consumerTask, connector, 0, this);</span></div>
<div class="line"><a name="l01144"></a><span class="lineno"> 1144</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01145"></a><span class="lineno"> 1145</span>&#160;<span class="comment">//    updateGraphHistory(producerTask, false, customEdge-&gt;useConnector());</span></div>
<div class="line"><a name="l01146"></a><span class="lineno"> 1146</span>&#160;<span class="comment">//    updateGraphHistory(consumerTask, customEdge-&gt;useConnector(), false);</span></div>
<div class="line"><a name="l01147"></a><span class="lineno"> 1147</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l01148"></a><span class="lineno"> 1148</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01149"></a><span class="lineno"> 1149</span>&#160;<span class="comment">//  /**</span></div>
<div class="line"><a name="l01150"></a><span class="lineno"> 1150</span>&#160;<span class="comment">//   * Adds a MemoryManager edge with the specified name to the TaskGraph, which connects a memory getter and releaser.</span></div>
<div class="line"><a name="l01151"></a><span class="lineno"> 1151</span>&#160;<span class="comment">//   * This function provides the ability to specify a custom type of memory manager.</span></div>
<div class="line"><a name="l01152"></a><span class="lineno"> 1152</span>&#160;<span class="comment">//   * @param memGetter the ITask that is getting memory</span></div>
<div class="line"><a name="l01153"></a><span class="lineno"> 1153</span>&#160;<span class="comment">//   * @param memReleaser the ITask that is releasing memory</span></div>
<div class="line"><a name="l01154"></a><span class="lineno"> 1154</span>&#160;<span class="comment">//   * @param memoryManager the memory manager responsible for sending/recycling memory</span></div>
<div class="line"><a name="l01155"></a><span class="lineno"> 1155</span>&#160;<span class="comment">//   * @param ignoreMemGetterErrors whether to ignore errors with the memory getter, used if the memory getter is already connected</span></div>
<div class="line"><a name="l01156"></a><span class="lineno"> 1156</span>&#160;<span class="comment">//   * to the same memory manager with the same edge name</span></div>
<div class="line"><a name="l01157"></a><span class="lineno"> 1157</span>&#160;<span class="comment">//   * @note the memoryPoolSize can cause out of memory errors for the system if the allocator-&gt;size() * memoryPoolSize exceeds the total system memory</span></div>
<div class="line"><a name="l01158"></a><span class="lineno"> 1158</span>&#160;<span class="comment">//   * @tparam V the type of memory; i.e., &#39;double *&#39;</span></div>
<div class="line"><a name="l01159"></a><span class="lineno"> 1159</span>&#160;<span class="comment">//   */</span></div>
<div class="line"><a name="l01160"></a><span class="lineno"> 1160</span>&#160;<span class="comment">//  template &lt;class V&gt;</span></div>
<div class="line"><a name="l01161"></a><span class="lineno"> 1161</span>&#160;<span class="comment">//  void addMemoryManagerEdge(AnyITask *memGetter, AnyITask *memReleaser, MemoryManager&lt;V&gt; *memoryManager, bool ignoreMemGetterErrors)</span></div>
<div class="line"><a name="l01162"></a><span class="lineno"> 1162</span>&#160;<span class="comment">//  {</span></div>
<div class="line"><a name="l01163"></a><span class="lineno"> 1163</span>&#160;<span class="comment">//    // Check if the Memory Manager task exists or not</span></div>
<div class="line"><a name="l01164"></a><span class="lineno"> 1164</span>&#160;<span class="comment">//    // If it does then get that task and do not create connectors</span></div>
<div class="line"><a name="l01165"></a><span class="lineno"> 1165</span>&#160;<span class="comment">//    TaskScheduler&lt;MemoryData&lt;V&gt;, MemoryData&lt;V&gt;&gt; *memTask = getTaskManager(memoryManager, true);</span></div>
<div class="line"><a name="l01166"></a><span class="lineno"> 1166</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01167"></a><span class="lineno"> 1167</span>&#160;<span class="comment">//    bool isReleaserOutsideGraph;</span></div>
<div class="line"><a name="l01168"></a><span class="lineno"> 1168</span>&#160;<span class="comment">//    if (hasITask(memReleaser))</span></div>
<div class="line"><a name="l01169"></a><span class="lineno"> 1169</span>&#160;<span class="comment">//      isReleaserOutsideGraph = false;</span></div>
<div class="line"><a name="l01170"></a><span class="lineno"> 1170</span>&#160;<span class="comment">//    else</span></div>
<div class="line"><a name="l01171"></a><span class="lineno"> 1171</span>&#160;<span class="comment">//      isReleaserOutsideGraph = true;</span></div>
<div class="line"><a name="l01172"></a><span class="lineno"> 1172</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01173"></a><span class="lineno"> 1173</span>&#160;<span class="comment">//    attachMemGetter(memoryManager-&gt;getMemoryManagerName(), memGetter, memoryManager-&gt;getType(), memTask-&gt;getOutputBaseConnector(), ignoreMemGetterErrors);</span></div>
<div class="line"><a name="l01174"></a><span class="lineno"> 1174</span>&#160;<span class="comment">//    attachMemReleaser(memoryManager-&gt;getMemoryManagerName(), memReleaser, memoryManager-&gt;getType(), memTask-&gt;getInputBaseConnector(), isReleaserOutsideGraph);</span></div>
<div class="line"><a name="l01175"></a><span class="lineno"> 1175</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01176"></a><span class="lineno"> 1176</span>&#160;<span class="comment">//    memTask-&gt;getInputBaseConnector()-&gt;incrementInputTaskCount();</span></div>
<div class="line"><a name="l01177"></a><span class="lineno"> 1177</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01178"></a><span class="lineno"> 1178</span>&#160;<span class="comment">//    updateGraphHistory(memTask, true, true);</span></div>
<div class="line"><a name="l01179"></a><span class="lineno"> 1179</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01180"></a><span class="lineno"> 1180</span>&#160;<span class="comment">//    // Save this information for copy</span></div>
<div class="line"><a name="l01181"></a><span class="lineno"> 1181</span>&#160;<span class="comment">//    this-&gt;memoryManagerKeys-&gt;push_back(new MemoryManagerKey(memoryManager-&gt;getMemoryManagerName(), memGetter, memReleaser, memTask, memoryManager-&gt;getType(), isReleaserOutsideGraph));</span></div>
<div class="line"><a name="l01182"></a><span class="lineno"> 1182</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l01183"></a><span class="lineno"> 1183</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01184"></a><span class="lineno"> 1184</span>&#160;<span class="comment">//#ifdef USE_CUDA</span></div>
<div class="line"><a name="l01185"></a><span class="lineno"> 1185</span>&#160;<span class="comment">//  /**</span></div>
<div class="line"><a name="l01186"></a><span class="lineno"> 1186</span>&#160;<span class="comment">//   * Adds a CudaMemoryManager edge with the specified name to the TaskGraph.</span></div>
<div class="line"><a name="l01187"></a><span class="lineno"> 1187</span>&#160;<span class="comment">//   * This will create a CudaMemoryManager that is bound to some Cuda GPU based on the pipelineId of</span></div>
<div class="line"><a name="l01188"></a><span class="lineno"> 1188</span>&#160;<span class="comment">//   * the TaskGraph.</span></div>
<div class="line"><a name="l01189"></a><span class="lineno"> 1189</span>&#160;<span class="comment">//   * @param name the name of the memory edge</span></div>
<div class="line"><a name="l01190"></a><span class="lineno"> 1190</span>&#160;<span class="comment">//   * @param memoryEdges the ITask that is getting memory</span></div>
<div class="line"><a name="l01191"></a><span class="lineno"> 1191</span>&#160;<span class="comment">//   * @param releaseMemoryEdges the ITask that is releasing memory</span></div>
<div class="line"><a name="l01192"></a><span class="lineno"> 1192</span>&#160;<span class="comment">//   * @param allocator the allocator describing how memory is allocated (should allocate Cuda memory)</span></div>
<div class="line"><a name="l01193"></a><span class="lineno"> 1193</span>&#160;<span class="comment">//   * @param memoryPoolSize the size of the memory pool that is allocated by the CudaMemoryManager</span></div>
<div class="line"><a name="l01194"></a><span class="lineno"> 1194</span>&#160;<span class="comment">//   * @param type the type of memory manager</span></div>
<div class="line"><a name="l01195"></a><span class="lineno"> 1195</span>&#160;<span class="comment">//   * @param contexts the array of all Cuda contexts</span></div>
<div class="line"><a name="l01196"></a><span class="lineno"> 1196</span>&#160;<span class="comment">//   * @note the memoryPoolSize can cause out of memory errors for the GPU if the allocator-&gt;size() * memoryPoolSize exceeds the total GPU memory</span></div>
<div class="line"><a name="l01197"></a><span class="lineno"> 1197</span>&#160;<span class="comment">//   * @tparam V the type of memory; i.e. &#39;cufftDoubleComplex *&#39;</span></div>
<div class="line"><a name="l01198"></a><span class="lineno"> 1198</span>&#160;<span class="comment">//   */</span></div>
<div class="line"><a name="l01199"></a><span class="lineno"> 1199</span>&#160;<span class="comment">//  template &lt;class V&gt;</span></div>
<div class="line"><a name="l01200"></a><span class="lineno"> 1200</span>&#160;<span class="comment">//  void addCudaMemoryManagerEdge(std::string name, AnyITask *memoryEdges, AnyITask *releaseMemoryEdges,</span></div>
<div class="line"><a name="l01201"></a><span class="lineno"> 1201</span>&#160;<span class="comment">//          IMemoryAllocator&lt;V&gt; *allocator, int memoryPoolSize, MMType type, CUcontext * contexts) {</span></div>
<div class="line"><a name="l01202"></a><span class="lineno"> 1202</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01203"></a><span class="lineno"> 1203</span>&#160;<span class="comment">//      if (!hasITask(memoryEdges)) {</span></div>
<div class="line"><a name="l01204"></a><span class="lineno"> 1204</span>&#160;<span class="comment">//          std::cerr &lt;&lt; &quot; Must add iTask &quot; &lt;&lt; memoryEdges-&gt;getName() &lt;&lt; &quot; to graph before adding it as a memory edge&quot; &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l01205"></a><span class="lineno"> 1205</span>&#160;<span class="comment">//          throw std::invalid_argument(&quot;Must add iTask to graph before adding as memory edge&quot;);</span></div>
<div class="line"><a name="l01206"></a><span class="lineno"> 1206</span>&#160;<span class="comment">//      }</span></div>
<div class="line"><a name="l01207"></a><span class="lineno"> 1207</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01208"></a><span class="lineno"> 1208</span>&#160;<span class="comment">//      std::shared_ptr&lt;IMemoryAllocator&lt;V&gt;&gt; allocP = getMemoryAllocator(allocator);</span></div>
<div class="line"><a name="l01209"></a><span class="lineno"> 1209</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01210"></a><span class="lineno"> 1210</span>&#160;<span class="comment">//      bool ignoreMemGetterErrors;</span></div>
<div class="line"><a name="l01211"></a><span class="lineno"> 1211</span>&#160;<span class="comment">//      CudaMemoryManager&lt;V&gt; *memManager = getCudaMemoryManager(memoryEdges, name, memoryPoolSize, allocP, type, contexts, &amp;ignoreMemGetterErrors);</span></div>
<div class="line"><a name="l01212"></a><span class="lineno"> 1212</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01213"></a><span class="lineno"> 1213</span>&#160;<span class="comment">//      addMemoryManagerEdge(memoryEdges, releaseMemoryEdges, memManager, ignoreMemGetterErrors);</span></div>
<div class="line"><a name="l01214"></a><span class="lineno"> 1214</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l01215"></a><span class="lineno"> 1215</span>&#160;<span class="comment">//#endif</span></div>
<div class="line"><a name="l01216"></a><span class="lineno"> 1216</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01217"></a><span class="lineno"> 1217</span>&#160;<span class="comment">//  /**</span></div>
<div class="line"><a name="l01218"></a><span class="lineno"> 1218</span>&#160;<span class="comment">//   * Adds a MemoryManager that is managed by the user.</span></div>
<div class="line"><a name="l01219"></a><span class="lineno"> 1219</span>&#160;<span class="comment">//   * This edge will enable an ITask to use the MemoryManager to throttle how much data is allocated.</span></div>
<div class="line"><a name="l01220"></a><span class="lineno"> 1220</span>&#160;<span class="comment">//   * @param name the name of the memory edge</span></div>
<div class="line"><a name="l01221"></a><span class="lineno"> 1221</span>&#160;<span class="comment">//   * @param memGetter the ITask that will be getting memory</span></div>
<div class="line"><a name="l01222"></a><span class="lineno"> 1222</span>&#160;<span class="comment">//   * @param memReleaser the ITask that will be releasing memory</span></div>
<div class="line"><a name="l01223"></a><span class="lineno"> 1223</span>&#160;<span class="comment">//   * @param memoryPoolSize the size of the memory pool</span></div>
<div class="line"><a name="l01224"></a><span class="lineno"> 1224</span>&#160;<span class="comment">//   */</span></div>
<div class="line"><a name="l01225"></a><span class="lineno"> 1225</span>&#160;<span class="comment">//  void addUserManagedMemoryManagerEdge(std::string name,</span></div>
<div class="line"><a name="l01226"></a><span class="lineno"> 1226</span>&#160;<span class="comment">//                                       AnyITask *memGetter,</span></div>
<div class="line"><a name="l01227"></a><span class="lineno"> 1227</span>&#160;<span class="comment">//                                       AnyITask *memReleaser,</span></div>
<div class="line"><a name="l01228"></a><span class="lineno"> 1228</span>&#160;<span class="comment">//                                       int memoryPoolSize) {</span></div>
<div class="line"><a name="l01229"></a><span class="lineno"> 1229</span>&#160;<span class="comment">//    addMemoryManagerEdge(name, memGetter, memReleaser, new VoidMemoryAllocator(), memoryPoolSize, MMType::UserManaged);</span></div>
<div class="line"><a name="l01230"></a><span class="lineno"> 1230</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l01231"></a><span class="lineno"> 1231</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01232"></a><span class="lineno"> 1232</span>&#160;<span class="comment">//  /**</span></div>
<div class="line"><a name="l01233"></a><span class="lineno"> 1233</span>&#160;<span class="comment">//   * Adds a MemoryManager edge with the specified name to the TaskGraph.</span></div>
<div class="line"><a name="l01234"></a><span class="lineno"> 1234</span>&#160;<span class="comment">//   * @param name the name of the memory edge</span></div>
<div class="line"><a name="l01235"></a><span class="lineno"> 1235</span>&#160;<span class="comment">//   * @param memGetter the ITask that is getting memory</span></div>
<div class="line"><a name="l01236"></a><span class="lineno"> 1236</span>&#160;<span class="comment">//   * @param memReleaser the ITask that is releasing memory</span></div>
<div class="line"><a name="l01237"></a><span class="lineno"> 1237</span>&#160;<span class="comment">//   * @param allocator the allocator describing how memory is allocated (should allocate Cuda memory)</span></div>
<div class="line"><a name="l01238"></a><span class="lineno"> 1238</span>&#160;<span class="comment">//   * @param memoryPoolSize the size of the memory pool that is allocated by the CudaMemoryManager</span></div>
<div class="line"><a name="l01239"></a><span class="lineno"> 1239</span>&#160;<span class="comment">//   * @param type the type of memory manager</span></div>
<div class="line"><a name="l01240"></a><span class="lineno"> 1240</span>&#160;<span class="comment">//   * @note the memoryPoolSize can cause out of memory errors for the system if the allocator-&gt;size() * memoryPoolSize exceeds the total system memory</span></div>
<div class="line"><a name="l01241"></a><span class="lineno"> 1241</span>&#160;<span class="comment">//   * @tparam V the type of memory; i.e., &#39;double *&#39;</span></div>
<div class="line"><a name="l01242"></a><span class="lineno"> 1242</span>&#160;<span class="comment">//   */</span></div>
<div class="line"><a name="l01243"></a><span class="lineno"> 1243</span>&#160;<span class="comment">//  template&lt;class V&gt;</span></div>
<div class="line"><a name="l01244"></a><span class="lineno"> 1244</span>&#160;<span class="comment">//  void addMemoryManagerEdge(std::string name, AnyITask *memGetter, AnyITask *memReleaser,</span></div>
<div class="line"><a name="l01245"></a><span class="lineno"> 1245</span>&#160;<span class="comment">//                            IMemoryAllocator&lt;V&gt; *allocator, int memoryPoolSize, MMType type) {</span></div>
<div class="line"><a name="l01246"></a><span class="lineno"> 1246</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01247"></a><span class="lineno"> 1247</span>&#160;<span class="comment">//    if (!hasITask(memGetter)) {</span></div>
<div class="line"><a name="l01248"></a><span class="lineno"> 1248</span>&#160;<span class="comment">//      std::cerr &lt;&lt; &quot; Must add iTask &quot; &lt;&lt; memGetter-&gt;getName() &lt;&lt; &quot; to graph before adding it to a memory edge&quot;</span></div>
<div class="line"><a name="l01249"></a><span class="lineno"> 1249</span>&#160;<span class="comment">//          &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l01250"></a><span class="lineno"> 1250</span>&#160;<span class="comment">//      throw std::invalid_argument(&quot;Must add iTask to graph before adding to memory edge&quot;);</span></div>
<div class="line"><a name="l01251"></a><span class="lineno"> 1251</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01252"></a><span class="lineno"> 1252</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01253"></a><span class="lineno"> 1253</span>&#160;<span class="comment">//    std::shared_ptr&lt;IMemoryAllocator&lt;V&gt;&gt; allocP = getMemoryAllocator(allocator);</span></div>
<div class="line"><a name="l01254"></a><span class="lineno"> 1254</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01255"></a><span class="lineno"> 1255</span>&#160;<span class="comment">//    // mem getter errors occur when trying to add a memory edge to a mem getter that already contains the named edge</span></div>
<div class="line"><a name="l01256"></a><span class="lineno"> 1256</span>&#160;<span class="comment">//    bool ignoreMemGetterErrors;</span></div>
<div class="line"><a name="l01257"></a><span class="lineno"> 1257</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01258"></a><span class="lineno"> 1258</span>&#160;<span class="comment">//    MemoryManager&lt;V&gt; *memManager = getMemoryManager(memGetter, name, memoryPoolSize, allocP, type, &amp;ignoreMemGetterErrors);</span></div>
<div class="line"><a name="l01259"></a><span class="lineno"> 1259</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01260"></a><span class="lineno"> 1260</span>&#160;<span class="comment">//    addMemoryManagerEdge(memGetter, memReleaser, memManager, ignoreMemGetterErrors);</span></div>
<div class="line"><a name="l01261"></a><span class="lineno"> 1261</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l01262"></a><span class="lineno"> 1262</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01263"></a><span class="lineno"> 1263</span>&#160;<span class="comment">//  /**</span></div>
<div class="line"><a name="l01264"></a><span class="lineno"> 1264</span>&#160;<span class="comment">//  * Adds a MemoryManager that is managed by the user with this graph as the memory releaser.</span></div>
<div class="line"><a name="l01265"></a><span class="lineno"> 1265</span>&#160;<span class="comment">//  * This edge will enable an ITask to use the MemoryManager to throttle how much data is allocated.</span></div>
<div class="line"><a name="l01266"></a><span class="lineno"> 1266</span>&#160;<span class="comment">//  * The throttling is achieved by adding MemoryData back to the TaskGraph</span></div>
<div class="line"><a name="l01267"></a><span class="lineno"> 1267</span>&#160;<span class="comment">//  * @param name the name of the memory edge</span></div>
<div class="line"><a name="l01268"></a><span class="lineno"> 1268</span>&#160;<span class="comment">//  * @param memGetter the ITask that will be getting memory</span></div>
<div class="line"><a name="l01269"></a><span class="lineno"> 1269</span>&#160;<span class="comment">//  * @param memoryPoolSize the size of the memory pool</span></div>
<div class="line"><a name="l01270"></a><span class="lineno"> 1270</span>&#160;<span class="comment">//  */</span></div>
<div class="line"><a name="l01271"></a><span class="lineno"> 1271</span>&#160;<span class="comment">//  void addGraphUserManagedMemoryManagerEdge(std::string name,</span></div>
<div class="line"><a name="l01272"></a><span class="lineno"> 1272</span>&#160;<span class="comment">//                                       AnyITask *memGetter,</span></div>
<div class="line"><a name="l01273"></a><span class="lineno"> 1273</span>&#160;<span class="comment">//                                       int memoryPoolSize) {</span></div>
<div class="line"><a name="l01274"></a><span class="lineno"> 1274</span>&#160;<span class="comment">//    addGraphMemoryManagerEdge(name, memGetter, new VoidMemoryAllocator(), memoryPoolSize, MMType::UserManaged);</span></div>
<div class="line"><a name="l01275"></a><span class="lineno"> 1275</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l01276"></a><span class="lineno"> 1276</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01277"></a><span class="lineno"> 1277</span>&#160;<span class="comment">//  /**</span></div>
<div class="line"><a name="l01278"></a><span class="lineno"> 1278</span>&#160;<span class="comment">//   * Adds a MemoryManager edge with the specified name to the TaskGraph.</span></div>
<div class="line"><a name="l01279"></a><span class="lineno"> 1279</span>&#160;<span class="comment">//   * The TaskGraph is used to release memory using the TaskGraph::memRelease function.</span></div>
<div class="line"><a name="l01280"></a><span class="lineno"> 1280</span>&#160;<span class="comment">//   * @param name the name of the memory edge</span></div>
<div class="line"><a name="l01281"></a><span class="lineno"> 1281</span>&#160;<span class="comment">//   * @param memGetter the ITask that is getting memory</span></div>
<div class="line"><a name="l01282"></a><span class="lineno"> 1282</span>&#160;<span class="comment">//   * @param allocator the allocator describing how memory is allocated (should allocate Cuda memory)</span></div>
<div class="line"><a name="l01283"></a><span class="lineno"> 1283</span>&#160;<span class="comment">//   * @param memoryPoolSize the size of the memory pool that is allocated by the CudaMemoryManager</span></div>
<div class="line"><a name="l01284"></a><span class="lineno"> 1284</span>&#160;<span class="comment">//   * @param type the type of memory manager</span></div>
<div class="line"><a name="l01285"></a><span class="lineno"> 1285</span>&#160;<span class="comment">//   * @note the memoryPoolSize can cause out of memory errors for the system if the allocator-&gt;size() * memoryPoolSize exceeds the total system memory</span></div>
<div class="line"><a name="l01286"></a><span class="lineno"> 1286</span>&#160;<span class="comment">//   * @tparam V the type of memory; i.e., &#39;double *&#39;</span></div>
<div class="line"><a name="l01287"></a><span class="lineno"> 1287</span>&#160;<span class="comment">//   */</span></div>
<div class="line"><a name="l01288"></a><span class="lineno"> 1288</span>&#160;<span class="comment">//  template &lt;class V&gt;</span></div>
<div class="line"><a name="l01289"></a><span class="lineno"> 1289</span>&#160;<span class="comment">//  void addGraphMemoryManagerEdge(std::string name, AnyITask *memGetter,</span></div>
<div class="line"><a name="l01290"></a><span class="lineno"> 1290</span>&#160;<span class="comment">//                                 IMemoryAllocator&lt;V&gt; *allocator, int memoryPoolSize, MMType type)</span></div>
<div class="line"><a name="l01291"></a><span class="lineno"> 1291</span>&#160;<span class="comment">//  {</span></div>
<div class="line"><a name="l01292"></a><span class="lineno"> 1292</span>&#160;<span class="comment">//    if (!hasITask(memGetter)) {</span></div>
<div class="line"><a name="l01293"></a><span class="lineno"> 1293</span>&#160;<span class="comment">//      std::cerr &lt;&lt; &quot; Must add iTask &quot; &lt;&lt; memGetter-&gt;getName() &lt;&lt; &quot; to graph before adding it to a memory edge&quot;</span></div>
<div class="line"><a name="l01294"></a><span class="lineno"> 1294</span>&#160;<span class="comment">//          &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l01295"></a><span class="lineno"> 1295</span>&#160;<span class="comment">//      throw std::invalid_argument(&quot;Must add iTask to graph before adding to memory edge&quot;);</span></div>
<div class="line"><a name="l01296"></a><span class="lineno"> 1296</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01297"></a><span class="lineno"> 1297</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01298"></a><span class="lineno"> 1298</span>&#160;<span class="comment">//    std::shared_ptr&lt;IMemoryAllocator&lt;V&gt;&gt; allocP = getMemoryAllocator(allocator);</span></div>
<div class="line"><a name="l01299"></a><span class="lineno"> 1299</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01300"></a><span class="lineno"> 1300</span>&#160;<span class="comment">//    // mem getter errors occur when trying to add a memory edge to a mem getter that already contains the named edge</span></div>
<div class="line"><a name="l01301"></a><span class="lineno"> 1301</span>&#160;<span class="comment">//    bool ignoreMemGetterErrors = false;</span></div>
<div class="line"><a name="l01302"></a><span class="lineno"> 1302</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01303"></a><span class="lineno"> 1303</span>&#160;<span class="comment">//    MemoryManager&lt;V&gt; *memManager = getMemoryManager(memGetter, name, memoryPoolSize, allocP, type, &amp;ignoreMemGetterErrors);</span></div>
<div class="line"><a name="l01304"></a><span class="lineno"> 1304</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01305"></a><span class="lineno"> 1305</span>&#160;<span class="comment">//    TaskScheduler&lt;MemoryData&lt;V&gt;, MemoryData&lt;V&gt;&gt; *memTask = getTaskManager(memManager, true);</span></div>
<div class="line"><a name="l01306"></a><span class="lineno"> 1306</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01307"></a><span class="lineno"> 1307</span>&#160;<span class="comment">//    attachMemGetter(name, memGetter, type, memTask-&gt;getOutputBaseConnector(), ignoreMemGetterErrors);</span></div>
<div class="line"><a name="l01308"></a><span class="lineno"> 1308</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01309"></a><span class="lineno"> 1309</span>&#160;<span class="comment">//    DEBUG(&quot;Adding memory releaser &quot; &lt;&lt; name &lt;&lt; &quot; to &quot; &lt;&lt; &quot;TaskGraph&quot;&lt;&lt; &quot; &quot; &lt;&lt; memReleaser &lt;&lt;</span></div>
<div class="line"><a name="l01310"></a><span class="lineno"> 1310</span>&#160;<span class="comment">//        &quot; at connector &quot; &lt;&lt;</span></div>
<div class="line"><a name="l01311"></a><span class="lineno"> 1311</span>&#160;<span class="comment">//        memTask-&gt;getInputBaseConnector());</span></div>
<div class="line"><a name="l01312"></a><span class="lineno"> 1312</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01313"></a><span class="lineno"> 1313</span>&#160;<span class="comment">//    std::shared_ptr&lt;std::vector&lt;std::shared_ptr&lt;AnyConnector&gt;&gt;&gt; vector;</span></div>
<div class="line"><a name="l01314"></a><span class="lineno"> 1314</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01315"></a><span class="lineno"> 1315</span>&#160;<span class="comment">//    if (hasMemReleaser(name))</span></div>
<div class="line"><a name="l01316"></a><span class="lineno"> 1316</span>&#160;<span class="comment">//      vector = memReleaser-&gt;find(name)-&gt;second;</span></div>
<div class="line"><a name="l01317"></a><span class="lineno"> 1317</span>&#160;<span class="comment">//    else</span></div>
<div class="line"><a name="l01318"></a><span class="lineno"> 1318</span>&#160;<span class="comment">//      vector = std::shared_ptr&lt;std::vector&lt;std::shared_ptr&lt;AnyConnector&gt;&gt;&gt;(new std::vector&lt;std::shared_ptr&lt;AnyConnector&gt;&gt;());</span></div>
<div class="line"><a name="l01319"></a><span class="lineno"> 1319</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01320"></a><span class="lineno"> 1320</span>&#160;<span class="comment">//    vector-&gt;push_back(memTask-&gt;getInputBaseConnector());</span></div>
<div class="line"><a name="l01321"></a><span class="lineno"> 1321</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01322"></a><span class="lineno"> 1322</span>&#160;<span class="comment">//    mmTypeMap-&gt;insert(std::pair&lt;std::string, MMType&gt;(name, type));</span></div>
<div class="line"><a name="l01323"></a><span class="lineno"> 1323</span>&#160;<span class="comment">//    memReleaser-&gt;insert(std::pair&lt;std::string, std::shared_ptr&lt;std::vector&lt;std::shared_ptr&lt;AnyConnector&gt;&gt;&gt;&gt;(name, vector));</span></div>
<div class="line"><a name="l01324"></a><span class="lineno"> 1324</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01325"></a><span class="lineno"> 1325</span>&#160;<span class="comment">//    memTask-&gt;getInputBaseConnector()-&gt;incrementInputTaskCount();</span></div>
<div class="line"><a name="l01326"></a><span class="lineno"> 1326</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01327"></a><span class="lineno"> 1327</span>&#160;<span class="comment">//    updateGraphHistory(memTask, true, true);</span></div>
<div class="line"><a name="l01328"></a><span class="lineno"> 1328</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01329"></a><span class="lineno"> 1329</span>&#160;<span class="comment">//    this-&gt;memoryManagerKeys-&gt;push_back(new MemoryManagerKey(name, memGetter, nullptr, memTask, type, false));</span></div>
<div class="line"><a name="l01330"></a><span class="lineno"> 1330</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l01331"></a><span class="lineno"> 1331</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01332"></a><span class="lineno"> 1332</span>&#160;<span class="comment">//  /**</span></div>
<div class="line"><a name="l01333"></a><span class="lineno"> 1333</span>&#160;<span class="comment">// * Checks whether this ITask contains a memReleaser for a specified name</span></div>
<div class="line"><a name="l01334"></a><span class="lineno"> 1334</span>&#160;<span class="comment">// * @param name the name of the memReleaser</span></div>
<div class="line"><a name="l01335"></a><span class="lineno"> 1335</span>&#160;<span class="comment">// * @return whether this ITask has a memReleaser with the specified name</span></div>
<div class="line"><a name="l01336"></a><span class="lineno"> 1336</span>&#160;<span class="comment">// * @retval TRUE if the ITask has a memReleaser with the specified name</span></div>
<div class="line"><a name="l01337"></a><span class="lineno"> 1337</span>&#160;<span class="comment">// * @retval FALSE if the ITask does not have a memReleaser with the specified name</span></div>
<div class="line"><a name="l01338"></a><span class="lineno"> 1338</span>&#160;<span class="comment">// * @note To add a memReleaser to this TaskGraph use TaskGraph::addGraphMemoryManagerEdge</span></div>
<div class="line"><a name="l01339"></a><span class="lineno"> 1339</span>&#160;<span class="comment">// */</span></div>
<div class="line"><a name="l01340"></a><span class="lineno"> 1340</span>&#160;<span class="comment">//  bool hasMemReleaser(std::string name) {</span></div>
<div class="line"><a name="l01341"></a><span class="lineno"> 1341</span>&#160;<span class="comment">//    return memReleaser-&gt;find(name) != memReleaser-&gt;end();</span></div>
<div class="line"><a name="l01342"></a><span class="lineno"> 1342</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l01343"></a><span class="lineno"> 1343</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01344"></a><span class="lineno"> 1344</span>&#160;<span class="comment">//  /**</span></div>
<div class="line"><a name="l01345"></a><span class="lineno"> 1345</span>&#160;<span class="comment">// * Releases memory onto a memory edge</span></div>
<div class="line"><a name="l01346"></a><span class="lineno"> 1346</span>&#160;<span class="comment">// * @param name the name of the memory edge</span></div>
<div class="line"><a name="l01347"></a><span class="lineno"> 1347</span>&#160;<span class="comment">// * @param memory the memory to be released</span></div>
<div class="line"><a name="l01348"></a><span class="lineno"> 1348</span>&#160;<span class="comment">// * @tparam V the MemoryData type</span></div>
<div class="line"><a name="l01349"></a><span class="lineno"> 1349</span>&#160;<span class="comment">// * @note The name specified must have been attached to this ITask as a memReleaser using</span></div>
<div class="line"><a name="l01350"></a><span class="lineno"> 1350</span>&#160;<span class="comment">// * the TaskGraph::addMemoryManagerEdge routine, which can be verified using hasMemReleaser()</span></div>
<div class="line"><a name="l01351"></a><span class="lineno"> 1351</span>&#160;<span class="comment">// * @note Memory edge must be defined as MMType::Static OR MMType::Dynamic</span></div>
<div class="line"><a name="l01352"></a><span class="lineno"> 1352</span>&#160;<span class="comment">// */</span></div>
<div class="line"><a name="l01353"></a><span class="lineno"> 1353</span>&#160;<span class="comment">//  template&lt;class V&gt;</span></div>
<div class="line"><a name="l01354"></a><span class="lineno"> 1354</span>&#160;<span class="comment">//  void memRelease(std::string name, std::shared_ptr&lt;MemoryData&lt;V&gt;&gt; memory) {</span></div>
<div class="line"><a name="l01355"></a><span class="lineno"> 1355</span>&#160;<span class="comment">//    assert(this-&gt;mmTypeMap-&gt;find(name)-&gt;second == MMType::Static</span></div>
<div class="line"><a name="l01356"></a><span class="lineno"> 1356</span>&#160;<span class="comment">//               || this-&gt;mmTypeMap-&gt;find(name)-&gt;second == MMType::Dynamic);</span></div>
<div class="line"><a name="l01357"></a><span class="lineno"> 1357</span>&#160;<span class="comment">//    std::shared_ptr&lt;AnyConnector&gt; conn = memReleaser-&gt;find(name)-&gt;second-&gt;at((unsigned long) memory-&gt;getPipelineId());</span></div>
<div class="line"><a name="l01358"></a><span class="lineno"> 1358</span>&#160;<span class="comment">//    std::shared_ptr&lt;Connector&lt;MemoryData&lt;V&gt;&gt;&gt; connector = std::dynamic_pointer_cast&lt;Connector&lt;MemoryData&lt;V&gt;&gt;&gt;(conn);</span></div>
<div class="line"><a name="l01359"></a><span class="lineno"> 1359</span>&#160;<span class="comment">//    connector-&gt;produceData(memory);</span></div>
<div class="line"><a name="l01360"></a><span class="lineno"> 1360</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l01361"></a><span class="lineno"> 1361</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01362"></a><span class="lineno"> 1362</span>&#160;<span class="comment">//  /**</span></div>
<div class="line"><a name="l01363"></a><span class="lineno"> 1363</span>&#160;<span class="comment">//   * Releases memory onto a memory edge</span></div>
<div class="line"><a name="l01364"></a><span class="lineno"> 1364</span>&#160;<span class="comment">//   * @param name the name of the memory edge</span></div>
<div class="line"><a name="l01365"></a><span class="lineno"> 1365</span>&#160;<span class="comment">//   * @param pipelineId the pipelineId to add data to</span></div>
<div class="line"><a name="l01366"></a><span class="lineno"> 1366</span>&#160;<span class="comment">//   * @note The name specified must have been attached to this ITask as a memReleaser using</span></div>
<div class="line"><a name="l01367"></a><span class="lineno"> 1367</span>&#160;<span class="comment">//   * the TaskGraph::addUserManagedEdge routine, which can be verified using hasMemReleaser()</span></div>
<div class="line"><a name="l01368"></a><span class="lineno"> 1368</span>&#160;<span class="comment">//   * @note Memory edge must be defined as MMType::UserManaged by using the TaskGraph::addUserManagedMemoryManagerEdge</span></div>
<div class="line"><a name="l01369"></a><span class="lineno"> 1369</span>&#160;<span class="comment">//   */</span></div>
<div class="line"><a name="l01370"></a><span class="lineno"> 1370</span>&#160;<span class="comment">//  void memRelease(std::string name, int pipelineId) {</span></div>
<div class="line"><a name="l01371"></a><span class="lineno"> 1371</span>&#160;<span class="comment">//    assert(this-&gt;mmTypeMap-&gt;find(name)-&gt;second == MMType::UserManaged);</span></div>
<div class="line"><a name="l01372"></a><span class="lineno"> 1372</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01373"></a><span class="lineno"> 1373</span>&#160;<span class="comment">//    std::shared_ptr&lt;MemoryData&lt;void *&gt;&gt; memory(new MemoryData&lt;void *&gt;(nullptr));</span></div>
<div class="line"><a name="l01374"></a><span class="lineno"> 1374</span>&#160;<span class="comment">//    memory-&gt;setPipelineId(pipelineId);</span></div>
<div class="line"><a name="l01375"></a><span class="lineno"> 1375</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01376"></a><span class="lineno"> 1376</span>&#160;<span class="comment">//    std::shared_ptr&lt;AnyConnector&gt; conn = memReleaser-&gt;find(name)-&gt;second-&gt;at((unsigned long) memory-&gt;getPipelineId());</span></div>
<div class="line"><a name="l01377"></a><span class="lineno"> 1377</span>&#160;<span class="comment">//    std::shared_ptr&lt;Connector&lt;MemoryData&lt;void *&gt;&gt;&gt; connector = std::dynamic_pointer_cast&lt;Connector&lt;MemoryData&lt;void *&gt;&gt;&gt;(conn);</span></div>
<div class="line"><a name="l01378"></a><span class="lineno"> 1378</span>&#160;<span class="comment">//    connector-&gt;produceData(memory);</span></div>
<div class="line"><a name="l01379"></a><span class="lineno"> 1379</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l01380"></a><span class="lineno"> 1380</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01381"></a><span class="lineno"> 1381</span>&#160;<span class="comment">//  /**</span></div>
<div class="line"><a name="l01382"></a><span class="lineno"> 1382</span>&#160;<span class="comment">//   * Indicates to the memory managers that are managing memory between the TaskGraph and ITask&#39;s created from TaskGraph::addGraphMemoryManager</span></div>
<div class="line"><a name="l01383"></a><span class="lineno"> 1383</span>&#160;<span class="comment">//   * can be shut down.</span></div>
<div class="line"><a name="l01384"></a><span class="lineno"> 1384</span>&#160;<span class="comment">//   * Use this function from the thread that is interacting with the TaskGraph&#39;s memory manager to ensure the memory managers</span></div>
<div class="line"><a name="l01385"></a><span class="lineno"> 1385</span>&#160;<span class="comment">//   * are shutting down.</span></div>
<div class="line"><a name="l01386"></a><span class="lineno"> 1386</span>&#160;<span class="comment">//   */</span></div>
<div class="line"><a name="l01387"></a><span class="lineno"> 1387</span>&#160;<span class="comment">//  void finishReleasingMemory()</span></div>
<div class="line"><a name="l01388"></a><span class="lineno"> 1388</span>&#160;<span class="comment">//  {</span></div>
<div class="line"><a name="l01389"></a><span class="lineno"> 1389</span>&#160;<span class="comment">//    DEBUG(&quot;TaskGraph&quot; &lt;&lt; &quot; Shutting down &quot; &lt;&lt; memReleaser-&gt;size() &lt;&lt;</span></div>
<div class="line"><a name="l01390"></a><span class="lineno"> 1390</span>&#160;<span class="comment">//        &quot; memory releasers&quot;);</span></div>
<div class="line"><a name="l01391"></a><span class="lineno"> 1391</span>&#160;<span class="comment">//    for (std::pair&lt;std::string, std::shared_ptr&lt;std::vector&lt;std::shared_ptr&lt;AnyConnector&gt;&gt;&gt; &gt; pair : *this-&gt;memReleaser) {</span></div>
<div class="line"><a name="l01392"></a><span class="lineno"> 1392</span>&#160;<span class="comment">//      DEBUG(&quot;TaskGraph &quot; &lt;&lt; &quot; Shutting down memory releaser : &quot; &lt;&lt;</span></div>
<div class="line"><a name="l01393"></a><span class="lineno"> 1393</span>&#160;<span class="comment">//          pair.first &lt;&lt; &quot; with &quot; &lt;&lt; pair.second-&gt;size() &lt;&lt; &quot; connectors&quot;);</span></div>
<div class="line"><a name="l01394"></a><span class="lineno"> 1394</span>&#160;<span class="comment">//      for (std::shared_ptr&lt;AnyConnector&gt; connector : *pair.second)</span></div>
<div class="line"><a name="l01395"></a><span class="lineno"> 1395</span>&#160;<span class="comment">//      {</span></div>
<div class="line"><a name="l01396"></a><span class="lineno"> 1396</span>&#160;<span class="comment">//        connector-&gt;producerFinished();</span></div>
<div class="line"><a name="l01397"></a><span class="lineno"> 1397</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01398"></a><span class="lineno"> 1398</span>&#160;<span class="comment">//        if (connector-&gt;isInputTerminated())</span></div>
<div class="line"><a name="l01399"></a><span class="lineno"> 1399</span>&#160;<span class="comment">//          connector-&gt;wakeupConsumer();</span></div>
<div class="line"><a name="l01400"></a><span class="lineno"> 1400</span>&#160;<span class="comment">//      }</span></div>
<div class="line"><a name="l01401"></a><span class="lineno"> 1401</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01402"></a><span class="lineno"> 1402</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01403"></a><span class="lineno"> 1403</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01404"></a><span class="lineno"> 1404</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l01405"></a><span class="lineno"> 1405</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01406"></a><span class="lineno"> 1406</span>&#160;<span class="comment">//  /**</span></div>
<div class="line"><a name="l01407"></a><span class="lineno"> 1407</span>&#160;<span class="comment">//   * Gets the edges (Connector) associated with the TaskGraph</span></div>
<div class="line"><a name="l01408"></a><span class="lineno"> 1408</span>&#160;<span class="comment">//   * @return the list of connectors</span></div>
<div class="line"><a name="l01409"></a><span class="lineno"> 1409</span>&#160;<span class="comment">//   */</span></div>
<div class="line"><a name="l01410"></a><span class="lineno"> 1410</span>&#160;<span class="comment">//  std::list&lt;std::shared_ptr&lt;AnyConnector&gt;&gt; *getEdges() const {</span></div>
<div class="line"><a name="l01411"></a><span class="lineno"> 1411</span>&#160;<span class="comment">//    return this-&gt;edges;</span></div>
<div class="line"><a name="l01412"></a><span class="lineno"> 1412</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l01413"></a><span class="lineno"> 1413</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01414"></a><span class="lineno"> 1414</span>&#160;<span class="comment">//  /**</span></div>
<div class="line"><a name="l01415"></a><span class="lineno"> 1415</span>&#160;<span class="comment">//   * Gets the vertices (BaseTaskScheduler) associated with the TaskGraph</span></div>
<div class="line"><a name="l01416"></a><span class="lineno"> 1416</span>&#160;<span class="comment">//   * @return the list of tasks</span></div>
<div class="line"><a name="l01417"></a><span class="lineno"> 1417</span>&#160;<span class="comment">//   */</span></div>
<div class="line"><a name="l01418"></a><span class="lineno"> 1418</span>&#160;<span class="comment">//  std::list&lt;AnyTaskScheduler *&gt; *getVertices() const {</span></div>
<div class="line"><a name="l01419"></a><span class="lineno"> 1419</span>&#160;<span class="comment">//    return this-&gt;vertices;</span></div>
<div class="line"><a name="l01420"></a><span class="lineno"> 1420</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l01421"></a><span class="lineno"> 1421</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01422"></a><span class="lineno"> 1422</span>&#160;<span class="comment">//  /**</span></div>
<div class="line"><a name="l01423"></a><span class="lineno"> 1423</span>&#160;<span class="comment">//   * Pure virtual function to add a copy of a TaskScheduler into the TaskGraph.</span></div>
<div class="line"><a name="l01424"></a><span class="lineno"> 1424</span>&#160;<span class="comment">//   * @param taskCopy the task that was copied.</span></div>
<div class="line"><a name="l01425"></a><span class="lineno"> 1425</span>&#160;<span class="comment">//   */</span></div>
<div class="line"><a name="l01426"></a><span class="lineno"> 1426</span>&#160;<span class="comment">//  void addTaskCopy(AnyTaskScheduler *taskCopy)</span></div>
<div class="line"><a name="l01427"></a><span class="lineno"> 1427</span>&#160;<span class="comment">//  {</span></div>
<div class="line"><a name="l01428"></a><span class="lineno"> 1428</span>&#160;<span class="comment">//    if (std::find(vertices-&gt;begin(), vertices-&gt;end(), taskCopy) == vertices-&gt;end()) {</span></div>
<div class="line"><a name="l01429"></a><span class="lineno"> 1429</span>&#160;<span class="comment">//      this-&gt;vertices-&gt;push_back(taskCopy);</span></div>
<div class="line"><a name="l01430"></a><span class="lineno"> 1430</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01431"></a><span class="lineno"> 1431</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l01432"></a><span class="lineno"> 1432</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01433"></a><span class="lineno"> 1433</span>&#160;<span class="comment">//  /**</span></div>
<div class="line"><a name="l01434"></a><span class="lineno"> 1434</span>&#160;<span class="comment">//   * Provides debug output for the TaskGraph</span></div>
<div class="line"><a name="l01435"></a><span class="lineno"> 1435</span>&#160;<span class="comment">//   * @note \#define DEBUG_FLAG to enable debugging</span></div>
<div class="line"><a name="l01436"></a><span class="lineno"> 1436</span>&#160;<span class="comment">//   */</span></div>
<div class="line"><a name="l01437"></a><span class="lineno"> 1437</span>&#160;<span class="comment">//  void debug() const {</span></div>
<div class="line"><a name="l01438"></a><span class="lineno"> 1438</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01439"></a><span class="lineno"> 1439</span>&#160;<span class="comment">//    DEBUG(&quot;-----------------------------------------------&quot;);</span></div>
<div class="line"><a name="l01440"></a><span class="lineno"> 1440</span>&#160;<span class="comment">//    DEBUG(&quot;TaskGraph -- num vertices: &quot; &lt;&lt; vertices-&gt;size() &lt;&lt; &quot; num edges: &quot; &lt;&lt; edges-&gt;size() &lt;&lt;</span></div>
<div class="line"><a name="l01441"></a><span class="lineno"> 1441</span>&#160;<span class="comment">//        &quot; -- DETAILS:&quot;);</span></div>
<div class="line"><a name="l01442"></a><span class="lineno"> 1442</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01443"></a><span class="lineno"> 1443</span>&#160;<span class="comment">//    for (AnyTaskScheduler *t : *vertices) {</span></div>
<div class="line"><a name="l01444"></a><span class="lineno"> 1444</span>&#160;<span class="comment">//      t-&gt;debug();</span></div>
<div class="line"><a name="l01445"></a><span class="lineno"> 1445</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01446"></a><span class="lineno"> 1446</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01447"></a><span class="lineno"> 1447</span>&#160;<span class="comment">//    for (std::shared_ptr&lt;AnyConnector&gt; c : *edges) {</span></div>
<div class="line"><a name="l01448"></a><span class="lineno"> 1448</span>&#160;<span class="comment">//      DEBUG(&quot;Connector: &quot; &lt;&lt; c &lt;&lt; &quot; total producers: &quot; &lt;&lt; c-&gt;getProducerCount());</span></div>
<div class="line"><a name="l01449"></a><span class="lineno"> 1449</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01450"></a><span class="lineno"> 1450</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01451"></a><span class="lineno"> 1451</span>&#160;<span class="comment">//    DEBUG(&quot;Graph input: &quot; &lt;&lt; this-&gt;input &lt;&lt; &quot; total producers: &quot; &lt;&lt;</span></div>
<div class="line"><a name="l01452"></a><span class="lineno"> 1452</span>&#160;<span class="comment">//        (input ? this-&gt;input-&gt;getProducerCount() : 0));</span></div>
<div class="line"><a name="l01453"></a><span class="lineno"> 1453</span>&#160;<span class="comment">//    DEBUG(&quot;Graph output: &quot; &lt;&lt; this-&gt;output &lt;&lt; &quot; total producers: &quot; &lt;&lt;</span></div>
<div class="line"><a name="l01454"></a><span class="lineno"> 1454</span>&#160;<span class="comment">//        (output ? this-&gt;output-&gt;getProducerCount() : 0));</span></div>
<div class="line"><a name="l01455"></a><span class="lineno"> 1455</span>&#160;<span class="comment">//    DEBUG(&quot;-----------------------------------------------&quot;);</span></div>
<div class="line"><a name="l01456"></a><span class="lineno"> 1456</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l01457"></a><span class="lineno"> 1457</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01458"></a><span class="lineno"> 1458</span>&#160;<span class="comment">//  /**</span></div>
<div class="line"><a name="l01459"></a><span class="lineno"> 1459</span>&#160;<span class="comment">//   * Processes all of the input for the TaskGraph until no more input is available</span></div>
<div class="line"><a name="l01460"></a><span class="lineno"> 1460</span>&#160;<span class="comment">//   * @note \#define DEBUG_FLAG to enable debugging</span></div>
<div class="line"><a name="l01461"></a><span class="lineno"> 1461</span>&#160;<span class="comment">//   */</span></div>
<div class="line"><a name="l01462"></a><span class="lineno"> 1462</span>&#160;<span class="comment">//  void debugInput() {</span></div>
<div class="line"><a name="l01463"></a><span class="lineno"> 1463</span>&#160;<span class="comment">//    while (!this-&gt;input-&gt;isInputTerminated())</span></div>
<div class="line"><a name="l01464"></a><span class="lineno"> 1464</span>&#160;<span class="comment">//      DEBUG(&quot;data = &quot; &lt;&lt; this-&gt;input-&gt;consumeData() &lt;&lt; std::endl);</span></div>
<div class="line"><a name="l01465"></a><span class="lineno"> 1465</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l01466"></a><span class="lineno"> 1466</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01467"></a><span class="lineno"> 1467</span>&#160;<span class="comment">//  /**</span></div>
<div class="line"><a name="l01468"></a><span class="lineno"> 1468</span>&#160;<span class="comment">//   * @internal</span></div>
<div class="line"><a name="l01469"></a><span class="lineno"> 1469</span>&#160;<span class="comment">//   * Updates the pipelineIds and the number of pipelines for all tasks in the TaskGraph</span></div>
<div class="line"><a name="l01470"></a><span class="lineno"> 1470</span>&#160;<span class="comment">//   * @param pipelineId the pipeline Id</span></div>
<div class="line"><a name="l01471"></a><span class="lineno"> 1471</span>&#160;<span class="comment">//   * @param numPipelines the number of pipelines</span></div>
<div class="line"><a name="l01472"></a><span class="lineno"> 1472</span>&#160;<span class="comment">//   *</span></div>
<div class="line"><a name="l01473"></a><span class="lineno"> 1473</span>&#160;<span class="comment">//   * @note This function should only be called by the HTGS API</span></div>
<div class="line"><a name="l01474"></a><span class="lineno"> 1474</span>&#160;<span class="comment">//   */</span></div>
<div class="line"><a name="l01475"></a><span class="lineno"> 1475</span>&#160;<span class="comment">//  void updateIdAndNumPipelines(int pipelineId, int numPipelines) {</span></div>
<div class="line"><a name="l01476"></a><span class="lineno"> 1476</span>&#160;<span class="comment">//    for (AnyTaskScheduler *t : *this-&gt;vertices) {</span></div>
<div class="line"><a name="l01477"></a><span class="lineno"> 1477</span>&#160;<span class="comment">//      t-&gt;setPipelineId(pipelineId);</span></div>
<div class="line"><a name="l01478"></a><span class="lineno"> 1478</span>&#160;<span class="comment">//      t-&gt;setNumPipelines(numPipelines);</span></div>
<div class="line"><a name="l01479"></a><span class="lineno"> 1479</span>&#160;<span class="comment">//      t-&gt;addPipelineConnector(pipelineId);</span></div>
<div class="line"><a name="l01480"></a><span class="lineno"> 1480</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01481"></a><span class="lineno"> 1481</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l01482"></a><span class="lineno"> 1482</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01483"></a><span class="lineno"> 1483</span>&#160;<span class="comment">//  /**</span></div>
<div class="line"><a name="l01484"></a><span class="lineno"> 1484</span>&#160;<span class="comment">//   * Gets the input connector for the TaskGraph</span></div>
<div class="line"><a name="l01485"></a><span class="lineno"> 1485</span>&#160;<span class="comment">//   * @return the input connector</span></div>
<div class="line"><a name="l01486"></a><span class="lineno"> 1486</span>&#160;<span class="comment">//   */</span></div>
<div class="line"><a name="l01487"></a><span class="lineno"> 1487</span>&#160;<span class="comment">//  std::shared_ptr&lt;Connector&lt;T&gt;&gt; getInputConnector() {</span></div>
<div class="line"><a name="l01488"></a><span class="lineno"> 1488</span>&#160;<span class="comment">//    return this-&gt;input;</span></div>
<div class="line"><a name="l01489"></a><span class="lineno"> 1489</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l01490"></a><span class="lineno"> 1490</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01491"></a><span class="lineno"> 1491</span>&#160;<span class="comment">//  /**</span></div>
<div class="line"><a name="l01492"></a><span class="lineno"> 1492</span>&#160;<span class="comment">//   * Gets the output connector for the TaskGraph</span></div>
<div class="line"><a name="l01493"></a><span class="lineno"> 1493</span>&#160;<span class="comment">//   * @return the output connector</span></div>
<div class="line"><a name="l01494"></a><span class="lineno"> 1494</span>&#160;<span class="comment">//   */</span></div>
<div class="line"><a name="l01495"></a><span class="lineno"> 1495</span>&#160;<span class="comment">//  std::shared_ptr&lt;Connector&lt;U&gt;&gt; getOutputConnector() {</span></div>
<div class="line"><a name="l01496"></a><span class="lineno"> 1496</span>&#160;<span class="comment">//    return this-&gt;output;</span></div>
<div class="line"><a name="l01497"></a><span class="lineno"> 1497</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l01498"></a><span class="lineno"> 1498</span>&#160;<span class="comment">//  /**</span></div>
<div class="line"><a name="l01499"></a><span class="lineno"> 1499</span>&#160;<span class="comment">//   * Sets the memory manager type map</span></div>
<div class="line"><a name="l01500"></a><span class="lineno"> 1500</span>&#160;<span class="comment">//   * @param pMap the shared pointer to the memory manager type map</span></div>
<div class="line"><a name="l01501"></a><span class="lineno"> 1501</span>&#160;<span class="comment">//   */</span></div>
<div class="line"><a name="l01502"></a><span class="lineno"> 1502</span>&#160;<span class="comment">//  void setMMTypeMap(std::shared_ptr&lt;std::unordered_map&lt;std::string, MMType&gt;&gt; pMap) { this-&gt;mmTypeMap = pMap; }</span></div>
<div class="line"><a name="l01503"></a><span class="lineno"> 1503</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01504"></a><span class="lineno"> 1504</span>&#160;<span class="comment">//  /**</span></div>
<div class="line"><a name="l01505"></a><span class="lineno"> 1505</span>&#160;<span class="comment">//   * Sets the memory releaser mapping</span></div>
<div class="line"><a name="l01506"></a><span class="lineno"> 1506</span>&#160;<span class="comment">//   * @param memReleaser the memory releaser map</span></div>
<div class="line"><a name="l01507"></a><span class="lineno"> 1507</span>&#160;<span class="comment">//   */</span></div>
<div class="line"><a name="l01508"></a><span class="lineno"> 1508</span>&#160;<span class="comment">//  void setMemReleaser(std::shared_ptr&lt;std::unordered_map&lt;std::string, std::shared_ptr&lt;std::vector&lt;std::shared_ptr&lt;AnyConnector&gt;&gt;&gt; &gt;&gt; memReleaser) {</span></div>
<div class="line"><a name="l01509"></a><span class="lineno"> 1509</span>&#160;<span class="comment">//    this-&gt;memReleaser = memReleaser;</span></div>
<div class="line"><a name="l01510"></a><span class="lineno"> 1510</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l01511"></a><span class="lineno"> 1511</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01512"></a><span class="lineno"> 1512</span>&#160;<span class="comment">//  /**</span></div>
<div class="line"><a name="l01513"></a><span class="lineno"> 1513</span>&#160;<span class="comment">//   * Sets the pipeline Id that the TaskGraph is bound to.</span></div>
<div class="line"><a name="l01514"></a><span class="lineno"> 1514</span>&#160;<span class="comment">//   * @param pipelineId the pipelineId</span></div>
<div class="line"><a name="l01515"></a><span class="lineno"> 1515</span>&#160;<span class="comment">//   */</span></div>
<div class="line"><a name="l01516"></a><span class="lineno"> 1516</span>&#160;<span class="comment">//  void setPipelineId(int pipelineId) { this-&gt;pipelineId = pipelineId; }</span></div>
<div class="line"><a name="l01517"></a><span class="lineno"> 1517</span>&#160;</div>
<div class="line"><a name="l01518"></a><span class="lineno"> 1518</span>&#160;</div>
<div class="line"><a name="l01519"></a><span class="lineno"> 1519</span>&#160; <span class="keyword">private</span>:</div>
<div class="line"><a name="l01520"></a><span class="lineno"> 1520</span>&#160;</div>
<div class="line"><a name="l01522"></a><span class="lineno"> 1522</span>&#160;<span class="comment">//  template&lt;class V, class W, class X&gt;</span></div>
<div class="line"><a name="l01523"></a><span class="lineno"> 1523</span>&#160;<span class="comment">//  void addEdge(TaskScheduler&lt;V, W&gt; *producer, TaskScheduler&lt;W, X&gt; *consumer) {</span></div>
<div class="line"><a name="l01524"></a><span class="lineno"> 1524</span>&#160;<span class="comment">//    std::shared_ptr&lt;Connector&lt;W&gt;&gt; connector;</span></div>
<div class="line"><a name="l01525"></a><span class="lineno"> 1525</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01526"></a><span class="lineno"> 1526</span>&#160;<span class="comment">//    if (this-&gt;consumerTaskConnectorMap-&gt;find(consumer) != this-&gt;consumerTaskConnectorMap-&gt;end()) {</span></div>
<div class="line"><a name="l01527"></a><span class="lineno"> 1527</span>&#160;<span class="comment">//      connector = std::dynamic_pointer_cast&lt;Connector&lt;W&gt;&gt;(this-&gt;consumerTaskConnectorMap-&gt;find(consumer)-&gt;second);</span></div>
<div class="line"><a name="l01528"></a><span class="lineno"> 1528</span>&#160;<span class="comment">//      producer-&gt;setOutputConnector(connector);</span></div>
<div class="line"><a name="l01529"></a><span class="lineno"> 1529</span>&#160;<span class="comment">//      connector-&gt;incrementInputTaskCount();</span></div>
<div class="line"><a name="l01530"></a><span class="lineno"> 1530</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01531"></a><span class="lineno"> 1531</span>&#160;<span class="comment">//      this-&gt;consumerTaskConnectorMap-&gt;insert(ConnectorPair(consumer, connector));</span></div>
<div class="line"><a name="l01532"></a><span class="lineno"> 1532</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01533"></a><span class="lineno"> 1533</span>&#160;<span class="comment">//    else {</span></div>
<div class="line"><a name="l01534"></a><span class="lineno"> 1534</span>&#160;<span class="comment">//      connector = std::shared_ptr&lt;Connector&lt;W&gt;&gt;(new Connector&lt;W&gt;());</span></div>
<div class="line"><a name="l01535"></a><span class="lineno"> 1535</span>&#160;<span class="comment">//      producer-&gt;setOutputConnector(connector);</span></div>
<div class="line"><a name="l01536"></a><span class="lineno"> 1536</span>&#160;<span class="comment">//      consumer-&gt;setInputConnector(connector);</span></div>
<div class="line"><a name="l01537"></a><span class="lineno"> 1537</span>&#160;<span class="comment">//      connector-&gt;incrementInputTaskCount();</span></div>
<div class="line"><a name="l01538"></a><span class="lineno"> 1538</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01539"></a><span class="lineno"> 1539</span>&#160;<span class="comment">//      this-&gt;consumerTaskConnectorMap-&gt;insert(ConnectorPair(consumer, connector));</span></div>
<div class="line"><a name="l01540"></a><span class="lineno"> 1540</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01541"></a><span class="lineno"> 1541</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01542"></a><span class="lineno"> 1542</span>&#160;<span class="comment">//    updateGraphHistory(producer, false, true);</span></div>
<div class="line"><a name="l01543"></a><span class="lineno"> 1543</span>&#160;<span class="comment">//    updateGraphHistory(consumer, true, false);</span></div>
<div class="line"><a name="l01544"></a><span class="lineno"> 1544</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01545"></a><span class="lineno"> 1545</span>&#160;<span class="comment">//    this-&gt;producerConsumerKeys-&gt;push_back(new ProducerConsumerKey(producer, consumer));</span></div>
<div class="line"><a name="l01546"></a><span class="lineno"> 1546</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l01547"></a><span class="lineno"> 1547</span>&#160;</div>
<div class="line"><a name="l01548"></a><span class="lineno"> 1548</span>&#160;</div>
<div class="line"><a name="l01549"></a><span class="lineno"> 1549</span>&#160;<span class="comment">//  template&lt;class V, class W, class X&gt;</span></div>
<div class="line"><a name="l01550"></a><span class="lineno"> 1550</span>&#160;<span class="comment">//  void addRuleManager(TaskScheduler&lt;V, VoidData&gt; *bkTask, Bookkeeper&lt;V&gt; *bk, RuleManager&lt;V, W&gt; *ruleMan,</span></div>
<div class="line"><a name="l01551"></a><span class="lineno"> 1551</span>&#160;<span class="comment">//                      TaskScheduler&lt;W, X&gt; *consumerTask) {</span></div>
<div class="line"><a name="l01552"></a><span class="lineno"> 1552</span>&#160;<span class="comment">//    // Add rule to bookkeeper</span></div>
<div class="line"><a name="l01553"></a><span class="lineno"> 1553</span>&#160;<span class="comment">//    bk-&gt;addRuleManager(ruleMan);</span></div>
<div class="line"><a name="l01554"></a><span class="lineno"> 1554</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01555"></a><span class="lineno"> 1555</span>&#160;<span class="comment">//    std::shared_ptr&lt;Connector&lt;W&gt;&gt; connector;</span></div>
<div class="line"><a name="l01556"></a><span class="lineno"> 1556</span>&#160;<span class="comment">//    if (consumerTaskConnectorMap-&gt;find(consumerTask) != this-&gt;consumerTaskConnectorMap-&gt;end()) {</span></div>
<div class="line"><a name="l01557"></a><span class="lineno"> 1557</span>&#160;<span class="comment">//      connector = std::dynamic_pointer_cast&lt;Connector&lt;W&gt;&gt; (this-&gt;consumerTaskConnectorMap-&gt;find(consumerTask)-&gt;second);</span></div>
<div class="line"><a name="l01558"></a><span class="lineno"> 1558</span>&#160;<span class="comment">//      ruleMan-&gt;setOutputConnector(connector);</span></div>
<div class="line"><a name="l01559"></a><span class="lineno"> 1559</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01560"></a><span class="lineno"> 1560</span>&#160;<span class="comment">//    else {</span></div>
<div class="line"><a name="l01561"></a><span class="lineno"> 1561</span>&#160;<span class="comment">//      connector = std::shared_ptr&lt;Connector&lt;W&gt;&gt;(new Connector&lt;W&gt;());</span></div>
<div class="line"><a name="l01562"></a><span class="lineno"> 1562</span>&#160;<span class="comment">//      ruleMan-&gt;setOutputConnector(connector);</span></div>
<div class="line"><a name="l01563"></a><span class="lineno"> 1563</span>&#160;<span class="comment">//      consumerTask-&gt;setInputConnector(connector);</span></div>
<div class="line"><a name="l01564"></a><span class="lineno"> 1564</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01565"></a><span class="lineno"> 1565</span>&#160;<span class="comment">//      consumerTaskConnectorMap-&gt;insert(ConnectorPair(consumerTask, connector));</span></div>
<div class="line"><a name="l01566"></a><span class="lineno"> 1566</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01567"></a><span class="lineno"> 1567</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01568"></a><span class="lineno"> 1568</span>&#160;<span class="comment">//    updateGraphHistory(bkTask, false, false);</span></div>
<div class="line"><a name="l01569"></a><span class="lineno"> 1569</span>&#160;<span class="comment">//    updateGraphHistory(consumerTask, true, false);</span></div>
<div class="line"><a name="l01570"></a><span class="lineno"> 1570</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01571"></a><span class="lineno"> 1571</span>&#160;<span class="comment">//    std::pair&lt;AnyITask *, AnyITask *&gt; ruleEdge(bk, consumerTask-&gt;getTaskFunction());</span></div>
<div class="line"><a name="l01572"></a><span class="lineno"> 1572</span>&#160;<span class="comment">//    if (this-&gt;ruleEdgeMap-&gt;find(ruleEdge) == this-&gt;ruleEdgeMap-&gt;end()) {</span></div>
<div class="line"><a name="l01573"></a><span class="lineno"> 1573</span>&#160;<span class="comment">//      this-&gt;ruleEdgeMap-&gt;insert(RuleEdgePair(ruleEdge, ruleMan));</span></div>
<div class="line"><a name="l01574"></a><span class="lineno"> 1574</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01575"></a><span class="lineno"> 1575</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01576"></a><span class="lineno"> 1576</span>&#160;<span class="comment">//    this-&gt;bookkeeperKeys-&gt;push_back(new BookkeeperKey(bkTask, bk, ruleMan, consumerTask));</span></div>
<div class="line"><a name="l01577"></a><span class="lineno"> 1577</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l01578"></a><span class="lineno"> 1578</span>&#160;</div>
<div class="line"><a name="l01579"></a><span class="lineno"> 1579</span>&#160;</div>
<div class="line"><a name="l01580"></a><span class="lineno"> 1580</span>&#160;<span class="comment">//  void addCustomEdge(AnyTaskScheduler *producerTask, AnyTaskScheduler *consumerTask, ICustomEdge *customEdge, int pipelineId) {</span></div>
<div class="line"><a name="l01581"></a><span class="lineno"> 1581</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01582"></a><span class="lineno"> 1582</span>&#160;<span class="comment">//    std::shared_ptr&lt;AnyConnector&gt; connector = nullptr;</span></div>
<div class="line"><a name="l01583"></a><span class="lineno"> 1583</span>&#160;<span class="comment">//    if (customEdge-&gt;useConnector()) {</span></div>
<div class="line"><a name="l01584"></a><span class="lineno"> 1584</span>&#160;<span class="comment">//      if (consumerTaskConnectorMap-&gt;find(consumerTask) != this-&gt;consumerTaskConnectorMap-&gt;end()) {</span></div>
<div class="line"><a name="l01585"></a><span class="lineno"> 1585</span>&#160;<span class="comment">//        connector = this-&gt;consumerTaskConnectorMap-&gt;find(consumerTask)-&gt;second;</span></div>
<div class="line"><a name="l01586"></a><span class="lineno"> 1586</span>&#160;<span class="comment">//      }</span></div>
<div class="line"><a name="l01587"></a><span class="lineno"> 1587</span>&#160;<span class="comment">//      else {</span></div>
<div class="line"><a name="l01588"></a><span class="lineno"> 1588</span>&#160;<span class="comment">//        connector = std::shared_ptr&lt;AnyConnector&gt;(customEdge-&gt;createConnector());</span></div>
<div class="line"><a name="l01589"></a><span class="lineno"> 1589</span>&#160;<span class="comment">//        consumerTaskConnectorMap-&gt;insert(ConnectorPair(consumerTask, connector));</span></div>
<div class="line"><a name="l01590"></a><span class="lineno"> 1590</span>&#160;<span class="comment">//      }</span></div>
<div class="line"><a name="l01591"></a><span class="lineno"> 1591</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01592"></a><span class="lineno"> 1592</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01593"></a><span class="lineno"> 1593</span>&#160;<span class="comment">//    std::pair&lt;AnyTaskScheduler *, AnyTaskScheduler *&gt; prodConsPair(producerTask, consumerTask);</span></div>
<div class="line"><a name="l01594"></a><span class="lineno"> 1594</span>&#160;<span class="comment">//    CustomEdgePair testPair(prodConsPair, customEdge);</span></div>
<div class="line"><a name="l01595"></a><span class="lineno"> 1595</span>&#160;<span class="comment">//    auto i = std::find_if(customEdgeList-&gt;begin(), customEdgeList-&gt;end(), CustomEdgeComparator(testPair));</span></div>
<div class="line"><a name="l01596"></a><span class="lineno"> 1596</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01597"></a><span class="lineno"> 1597</span>&#160;<span class="comment">//    if (i == customEdgeList-&gt;end())</span></div>
<div class="line"><a name="l01598"></a><span class="lineno"> 1598</span>&#160;<span class="comment">//      this-&gt;customEdgeList-&gt;push_back(testPair);</span></div>
<div class="line"><a name="l01599"></a><span class="lineno"> 1599</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01600"></a><span class="lineno"> 1600</span>&#160;<span class="comment">//    customEdge-&gt;applyGraphConnection(producerTask, consumerTask, connector, pipelineId, this);</span></div>
<div class="line"><a name="l01601"></a><span class="lineno"> 1601</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01602"></a><span class="lineno"> 1602</span>&#160;<span class="comment">//    updateGraphHistory(producerTask, false, customEdge-&gt;useConnector());</span></div>
<div class="line"><a name="l01603"></a><span class="lineno"> 1603</span>&#160;<span class="comment">//    updateGraphHistory(consumerTask, customEdge-&gt;useConnector(), false);</span></div>
<div class="line"><a name="l01604"></a><span class="lineno"> 1604</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l01605"></a><span class="lineno"> 1605</span>&#160;</div>
<div class="line"><a name="l01606"></a><span class="lineno"> 1606</span>&#160;<span class="comment">//  void addGraphInputConsumer(AnyTaskScheduler *task) {</span></div>
<div class="line"><a name="l01607"></a><span class="lineno"> 1607</span>&#160;<span class="comment">//    DEBUG_VERBOSE(&quot;Adding task graph input consumer: &quot; &lt;&lt; task &lt;&lt; &quot; to input connector &quot; &lt;&lt; this-&gt;input);</span></div>
<div class="line"><a name="l01608"></a><span class="lineno"> 1608</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01609"></a><span class="lineno"> 1609</span>&#160;<span class="comment">//    std::shared_ptr&lt;Connector&lt;T&gt;&gt; connector;</span></div>
<div class="line"><a name="l01610"></a><span class="lineno"> 1610</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01611"></a><span class="lineno"> 1611</span>&#160;<span class="comment">//    // If the task consuming is already in the graph, then use that task&#39;s connector</span></div>
<div class="line"><a name="l01612"></a><span class="lineno"> 1612</span>&#160;<span class="comment">//    if (this-&gt;consumerTaskConnectorMap-&gt;find(task) != this-&gt;consumerTaskConnectorMap-&gt;end()) {</span></div>
<div class="line"><a name="l01613"></a><span class="lineno"> 1613</span>&#160;<span class="comment">//      connector = std::dynamic_pointer_cast&lt;Connector&lt;T&gt;&gt;(this-&gt;consumerTaskConnectorMap-&gt;find(task)-&gt;second);</span></div>
<div class="line"><a name="l01614"></a><span class="lineno"> 1614</span>&#160;<span class="comment">//      this-&gt;input = connector;</span></div>
<div class="line"><a name="l01615"></a><span class="lineno"> 1615</span>&#160;<span class="comment">//      this-&gt;consumerTaskConnectorMap-&gt;insert(ConnectorPair(task, connector));</span></div>
<div class="line"><a name="l01616"></a><span class="lineno"> 1616</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01617"></a><span class="lineno"> 1617</span>&#160;<span class="comment">//    else {</span></div>
<div class="line"><a name="l01618"></a><span class="lineno"> 1618</span>&#160;<span class="comment">//      // task not found, use the graph&#39;s input</span></div>
<div class="line"><a name="l01619"></a><span class="lineno"> 1619</span>&#160;<span class="comment">//      connector = this-&gt;input;</span></div>
<div class="line"><a name="l01620"></a><span class="lineno"> 1620</span>&#160;<span class="comment">//      task-&gt;setInputConnector(connector);</span></div>
<div class="line"><a name="l01621"></a><span class="lineno"> 1621</span>&#160;<span class="comment">//      this-&gt;consumerTaskConnectorMap-&gt;insert(ConnectorPair(task, connector));</span></div>
<div class="line"><a name="l01622"></a><span class="lineno"> 1622</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01623"></a><span class="lineno"> 1623</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01624"></a><span class="lineno"> 1624</span>&#160;<span class="comment">//    this-&gt;graphInputConsumers-&gt;push_back(task);</span></div>
<div class="line"><a name="l01625"></a><span class="lineno"> 1625</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01626"></a><span class="lineno"> 1626</span>&#160;<span class="comment">//    updateGraphHistory(task, true, false);</span></div>
<div class="line"><a name="l01627"></a><span class="lineno"> 1627</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l01628"></a><span class="lineno"> 1628</span>&#160;</div>
<div class="line"><a name="l01629"></a><span class="lineno"> 1629</span>&#160;<span class="comment">//  void addGraphOutputProducer(AnyTaskScheduler *task) {</span></div>
<div class="line"><a name="l01630"></a><span class="lineno"> 1630</span>&#160;<span class="comment">//    DEBUG_VERBOSE(&quot;Adding task graph output producer: &quot; &lt;&lt; task &lt;&lt; &quot; to output connector &quot; &lt;&lt; this-&gt;output);</span></div>
<div class="line"><a name="l01631"></a><span class="lineno"> 1631</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01632"></a><span class="lineno"> 1632</span>&#160;<span class="comment">//    task-&gt;setOutputConnector(output);</span></div>
<div class="line"><a name="l01633"></a><span class="lineno"> 1633</span>&#160;<span class="comment">//    output-&gt;incrementInputTaskCount();</span></div>
<div class="line"><a name="l01634"></a><span class="lineno"> 1634</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01635"></a><span class="lineno"> 1635</span>&#160;<span class="comment">//    this-&gt;graphOutputProducers-&gt;push_back(task);</span></div>
<div class="line"><a name="l01636"></a><span class="lineno"> 1636</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01637"></a><span class="lineno"> 1637</span>&#160;<span class="comment">//    updateGraphHistory(task, false, true);</span></div>
<div class="line"><a name="l01638"></a><span class="lineno"> 1638</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l01639"></a><span class="lineno"> 1639</span>&#160;</div>
<div class="line"><a name="l01640"></a><span class="lineno"> 1640</span>&#160;<span class="comment">//  void addGraphMemoryManagerEdge(std::string name, AnyITask *memGetter, AnyTaskScheduler *memTask,</span></div>
<div class="line"><a name="l01641"></a><span class="lineno"> 1641</span>&#160;<span class="comment">//                                 std::shared_ptr&lt;AnyConnector&gt; connector, MMType type)</span></div>
<div class="line"><a name="l01642"></a><span class="lineno"> 1642</span>&#160;<span class="comment">//  {</span></div>
<div class="line"><a name="l01643"></a><span class="lineno"> 1643</span>&#160;<span class="comment">//    // Check to make sure the memory edge&#39;s memgetter is already in the graph</span></div>
<div class="line"><a name="l01644"></a><span class="lineno"> 1644</span>&#160;<span class="comment">//    if (!hasITask(memGetter)) {</span></div>
<div class="line"><a name="l01645"></a><span class="lineno"> 1645</span>&#160;<span class="comment">//      std::cerr &lt;&lt; &quot; Must add iTask &quot; &lt;&lt; memGetter-&gt;getName() &lt;&lt; &quot; to graph before adding it to a memory edge&quot;</span></div>
<div class="line"><a name="l01646"></a><span class="lineno"> 1646</span>&#160;<span class="comment">//          &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l01647"></a><span class="lineno"> 1647</span>&#160;<span class="comment">//      throw std::invalid_argument(&quot;Must add iTask to graph before adding to memory edge&quot;);</span></div>
<div class="line"><a name="l01648"></a><span class="lineno"> 1648</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01649"></a><span class="lineno"> 1649</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01650"></a><span class="lineno"> 1650</span>&#160;<span class="comment">//    std::shared_ptr&lt;AnyConnector&gt; inputConnector;</span></div>
<div class="line"><a name="l01651"></a><span class="lineno"> 1651</span>&#160;<span class="comment">//    std::shared_ptr&lt;AnyConnector&gt; outputConnector;</span></div>
<div class="line"><a name="l01652"></a><span class="lineno"> 1652</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01653"></a><span class="lineno"> 1653</span>&#160;<span class="comment">//    // If the memManager is not in this graph, then create a new one and update the memTask</span></div>
<div class="line"><a name="l01654"></a><span class="lineno"> 1654</span>&#160;<span class="comment">//    if (std::find(this-&gt;vertices-&gt;begin(), this-&gt;vertices-&gt;end(), memTask) == this-&gt;vertices-&gt;end()) {</span></div>
<div class="line"><a name="l01655"></a><span class="lineno"> 1655</span>&#160;<span class="comment">//      inputConnector = std::shared_ptr&lt;AnyConnector&gt;(connector-&gt;copy());</span></div>
<div class="line"><a name="l01656"></a><span class="lineno"> 1656</span>&#160;<span class="comment">//      outputConnector = std::shared_ptr&lt;AnyConnector&gt;(connector-&gt;copy());</span></div>
<div class="line"><a name="l01657"></a><span class="lineno"> 1657</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01658"></a><span class="lineno"> 1658</span>&#160;<span class="comment">//      memTask-&gt;setInputConnector(inputConnector);</span></div>
<div class="line"><a name="l01659"></a><span class="lineno"> 1659</span>&#160;<span class="comment">//      memTask-&gt;setOutputConnector(outputConnector);</span></div>
<div class="line"><a name="l01660"></a><span class="lineno"> 1660</span>&#160;<span class="comment">//      outputConnector-&gt;incrementInputTaskCount();</span></div>
<div class="line"><a name="l01661"></a><span class="lineno"> 1661</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01662"></a><span class="lineno"> 1662</span>&#160;<span class="comment">//    else</span></div>
<div class="line"><a name="l01663"></a><span class="lineno"> 1663</span>&#160;<span class="comment">//    {</span></div>
<div class="line"><a name="l01664"></a><span class="lineno"> 1664</span>&#160;<span class="comment">//      // memManager task is already in the graph, so its connectors should exist</span></div>
<div class="line"><a name="l01665"></a><span class="lineno"> 1665</span>&#160;<span class="comment">//      inputConnector = memTask-&gt;getInputBaseConnector();</span></div>
<div class="line"><a name="l01666"></a><span class="lineno"> 1666</span>&#160;<span class="comment">//      outputConnector = memTask-&gt;getOutputBaseConnector();</span></div>
<div class="line"><a name="l01667"></a><span class="lineno"> 1667</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01668"></a><span class="lineno"> 1668</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01669"></a><span class="lineno"> 1669</span>&#160;<span class="comment">//    DEBUG(&quot;Adding memory getter &quot; &lt;&lt; name &lt;&lt; &quot; to &quot; &lt;&lt; memGetter-&gt;getName() &lt;&lt; &quot; &quot; &lt;&lt; memGetter &lt;&lt;</span></div>
<div class="line"><a name="l01670"></a><span class="lineno"> 1670</span>&#160;<span class="comment">//        &quot; at connector &quot; &lt;&lt; memTask-&gt;getOutputBaseConnector());</span></div>
<div class="line"><a name="l01671"></a><span class="lineno"> 1671</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01672"></a><span class="lineno"> 1672</span>&#160;<span class="comment">//    memGetter-&gt;attachMemGetter(name, outputConnector, type);</span></div>
<div class="line"><a name="l01673"></a><span class="lineno"> 1673</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01674"></a><span class="lineno"> 1674</span>&#160;<span class="comment">//    DEBUG(&quot;Adding memory releaser &quot; &lt;&lt; name &lt;&lt; &quot; to &quot; &lt;&lt; &quot;TaskGraph&quot;&lt;&lt; &quot; &quot; &lt;&lt; memReleaser &lt;&lt;</span></div>
<div class="line"><a name="l01675"></a><span class="lineno"> 1675</span>&#160;<span class="comment">//        &quot; at connector &quot; &lt;&lt; memTask-&gt;getInputBaseConnector());</span></div>
<div class="line"><a name="l01676"></a><span class="lineno"> 1676</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01677"></a><span class="lineno"> 1677</span>&#160;<span class="comment">//    std::shared_ptr&lt;std::vector&lt;std::shared_ptr&lt;AnyConnector&gt;&gt;&gt; vector;</span></div>
<div class="line"><a name="l01678"></a><span class="lineno"> 1678</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01679"></a><span class="lineno"> 1679</span>&#160;<span class="comment">//    // Get the vector of connectors for the given edge name (1 pipeline per vector element)</span></div>
<div class="line"><a name="l01680"></a><span class="lineno"> 1680</span>&#160;<span class="comment">//    if (hasMemReleaser(name))</span></div>
<div class="line"><a name="l01681"></a><span class="lineno"> 1681</span>&#160;<span class="comment">//      vector = memReleaser-&gt;find(name)-&gt;second;</span></div>
<div class="line"><a name="l01682"></a><span class="lineno"> 1682</span>&#160;<span class="comment">//    else</span></div>
<div class="line"><a name="l01683"></a><span class="lineno"> 1683</span>&#160;<span class="comment">//      vector = std::shared_ptr&lt;std::vector&lt;std::shared_ptr&lt;AnyConnector&gt;&gt;&gt;(new std::vector&lt;std::shared_ptr&lt;AnyConnector&gt;&gt;());</span></div>
<div class="line"><a name="l01684"></a><span class="lineno"> 1684</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01685"></a><span class="lineno"> 1685</span>&#160;<span class="comment">//    // Add the connector</span></div>
<div class="line"><a name="l01686"></a><span class="lineno"> 1686</span>&#160;<span class="comment">//    vector-&gt;push_back(memTask-&gt;getInputBaseConnector());</span></div>
<div class="line"><a name="l01687"></a><span class="lineno"> 1687</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01688"></a><span class="lineno"> 1688</span>&#160;<span class="comment">//    mmTypeMap-&gt;insert(std::pair&lt;std::string, MMType&gt;(name, type));</span></div>
<div class="line"><a name="l01689"></a><span class="lineno"> 1689</span>&#160;<span class="comment">//    memReleaser-&gt;insert(std::pair&lt;std::string, std::shared_ptr&lt;std::vector&lt;std::shared_ptr&lt;AnyConnector&gt;&gt;&gt;&gt;(name, vector));</span></div>
<div class="line"><a name="l01690"></a><span class="lineno"> 1690</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01691"></a><span class="lineno"> 1691</span>&#160;<span class="comment">//    inputConnector-&gt;incrementInputTaskCount();</span></div>
<div class="line"><a name="l01692"></a><span class="lineno"> 1692</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01693"></a><span class="lineno"> 1693</span>&#160;<span class="comment">//    updateGraphHistory(memTask, true, true);</span></div>
<div class="line"><a name="l01694"></a><span class="lineno"> 1694</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01695"></a><span class="lineno"> 1695</span>&#160;<span class="comment">//    this-&gt;memoryManagerKeys-&gt;push_back(new MemoryManagerKey(name, memGetter, nullptr, memTask, type, false));</span></div>
<div class="line"><a name="l01696"></a><span class="lineno"> 1696</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l01697"></a><span class="lineno"> 1697</span>&#160;</div>
<div class="line"><a name="l01698"></a><span class="lineno"> 1698</span>&#160;<span class="comment">//  void addMemoryManagerEdge(std::string name, AnyITask *memGetter, AnyITask *memReleaser, AnyTaskScheduler *memTask,</span></div>
<div class="line"><a name="l01699"></a><span class="lineno"> 1699</span>&#160;<span class="comment">//                            std::shared_ptr&lt;AnyConnector&gt; connector, MMType type, bool isReleaserOutsideGraph) {</span></div>
<div class="line"><a name="l01700"></a><span class="lineno"> 1700</span>&#160;<span class="comment">//    if (!hasITask(memGetter)) {</span></div>
<div class="line"><a name="l01701"></a><span class="lineno"> 1701</span>&#160;<span class="comment">//      std::cerr &lt;&lt; &quot; Must add iTask &quot; &lt;&lt; memGetter-&gt;getName() &lt;&lt; &quot; to graph before adding it as a memory edge&quot;</span></div>
<div class="line"><a name="l01702"></a><span class="lineno"> 1702</span>&#160;<span class="comment">//          &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l01703"></a><span class="lineno"> 1703</span>&#160;<span class="comment">//      throw std::invalid_argument(&quot;Must add iTask to graph before adding as memory edge&quot;);</span></div>
<div class="line"><a name="l01704"></a><span class="lineno"> 1704</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01705"></a><span class="lineno"> 1705</span>&#160;<span class="comment">//    std::shared_ptr&lt;AnyConnector&gt; inputConnector;</span></div>
<div class="line"><a name="l01706"></a><span class="lineno"> 1706</span>&#160;<span class="comment">//    std::shared_ptr&lt;AnyConnector&gt; outputConnector;</span></div>
<div class="line"><a name="l01707"></a><span class="lineno"> 1707</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01708"></a><span class="lineno"> 1708</span>&#160;<span class="comment">//    // If the memManager is not in this graph, then create a new one and update the memTask</span></div>
<div class="line"><a name="l01709"></a><span class="lineno"> 1709</span>&#160;<span class="comment">//    if (std::find(this-&gt;vertices-&gt;begin(), this-&gt;vertices-&gt;end(), memTask) == this-&gt;vertices-&gt;end()) {</span></div>
<div class="line"><a name="l01710"></a><span class="lineno"> 1710</span>&#160;<span class="comment">//      inputConnector = std::shared_ptr&lt;AnyConnector&gt;(connector-&gt;copy());</span></div>
<div class="line"><a name="l01711"></a><span class="lineno"> 1711</span>&#160;<span class="comment">//      outputConnector = std::shared_ptr&lt;AnyConnector&gt;(connector-&gt;copy());</span></div>
<div class="line"><a name="l01712"></a><span class="lineno"> 1712</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01713"></a><span class="lineno"> 1713</span>&#160;<span class="comment">//      memTask-&gt;setInputConnector(inputConnector);</span></div>
<div class="line"><a name="l01714"></a><span class="lineno"> 1714</span>&#160;<span class="comment">//      memTask-&gt;setOutputConnector(outputConnector);</span></div>
<div class="line"><a name="l01715"></a><span class="lineno"> 1715</span>&#160;<span class="comment">//      outputConnector-&gt;incrementInputTaskCount();</span></div>
<div class="line"><a name="l01716"></a><span class="lineno"> 1716</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01717"></a><span class="lineno"> 1717</span>&#160;<span class="comment">//    else</span></div>
<div class="line"><a name="l01718"></a><span class="lineno"> 1718</span>&#160;<span class="comment">//    {</span></div>
<div class="line"><a name="l01719"></a><span class="lineno"> 1719</span>&#160;<span class="comment">//      // memManager task is already in the graph, so its connectors should exist</span></div>
<div class="line"><a name="l01720"></a><span class="lineno"> 1720</span>&#160;<span class="comment">//      inputConnector = memTask-&gt;getInputBaseConnector();</span></div>
<div class="line"><a name="l01721"></a><span class="lineno"> 1721</span>&#160;<span class="comment">//      outputConnector = memTask-&gt;getOutputBaseConnector();</span></div>
<div class="line"><a name="l01722"></a><span class="lineno"> 1722</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01723"></a><span class="lineno"> 1723</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01724"></a><span class="lineno"> 1724</span>&#160;<span class="comment">//    DEBUG(&quot;Adding memory getter &quot; &lt;&lt; name &lt;&lt; &quot; to &quot; &lt;&lt; memGetter-&gt;getName() &lt;&lt; &quot; &quot; &lt;&lt; memGetter &lt;&lt;</span></div>
<div class="line"><a name="l01725"></a><span class="lineno"> 1725</span>&#160;<span class="comment">//        &quot; at connector &quot; &lt;&lt; memTask-&gt;getOutputBaseConnector());</span></div>
<div class="line"><a name="l01726"></a><span class="lineno"> 1726</span>&#160;<span class="comment">//    DEBUG(&quot;Adding memory releaser &quot; &lt;&lt; name &lt;&lt; &quot; to &quot; &lt;&lt; memReleaser-&gt;getName() &lt;&lt; &quot; &quot; &lt;&lt; memReleaser &lt;&lt;</span></div>
<div class="line"><a name="l01727"></a><span class="lineno"> 1727</span>&#160;<span class="comment">//        &quot; at connector &quot; &lt;&lt; memTask-&gt;getInputBaseConnector());</span></div>
<div class="line"><a name="l01728"></a><span class="lineno"> 1728</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01729"></a><span class="lineno"> 1729</span>&#160;<span class="comment">//    // This functionality is internal to copying a graph, so inserting the memoryEdges/releaser with the same name is desired</span></div>
<div class="line"><a name="l01730"></a><span class="lineno"> 1730</span>&#160;<span class="comment">//    // One per pipeline</span></div>
<div class="line"><a name="l01731"></a><span class="lineno"> 1731</span>&#160;<span class="comment">//    memGetter-&gt;attachMemGetter(name, outputConnector, type);</span></div>
<div class="line"><a name="l01732"></a><span class="lineno"> 1732</span>&#160;<span class="comment">//    memReleaser-&gt;attachMemReleaser(name, inputConnector, type, isReleaserOutsideGraph);</span></div>
<div class="line"><a name="l01733"></a><span class="lineno"> 1733</span>&#160;<span class="comment">//    inputConnector-&gt;incrementInputTaskCount();</span></div>
<div class="line"><a name="l01734"></a><span class="lineno"> 1734</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01735"></a><span class="lineno"> 1735</span>&#160;<span class="comment">//    updateGraphHistory(memTask, true, true);</span></div>
<div class="line"><a name="l01736"></a><span class="lineno"> 1736</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01737"></a><span class="lineno"> 1737</span>&#160;<span class="comment">//    // Save this information for copy</span></div>
<div class="line"><a name="l01738"></a><span class="lineno"> 1738</span>&#160;<span class="comment">//    this-&gt;memoryManagerKeys-&gt;push_back(new MemoryManagerKey(name, memGetter, memReleaser, memTask, type, isReleaserOutsideGraph));</span></div>
<div class="line"><a name="l01739"></a><span class="lineno"> 1739</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l01740"></a><span class="lineno"> 1740</span>&#160;</div>
<div class="line"><a name="l01741"></a><span class="lineno"> 1741</span>&#160;<span class="comment">//  void addRuleManager(AnyTaskScheduler *bkTask,</span></div>
<div class="line"><a name="l01742"></a><span class="lineno"> 1742</span>&#160;<span class="comment">//                      AnyITask *bk,</span></div>
<div class="line"><a name="l01743"></a><span class="lineno"> 1743</span>&#160;<span class="comment">//                      BaseBaseRuleManager *ruleMan,</span></div>
<div class="line"><a name="l01744"></a><span class="lineno"> 1744</span>&#160;<span class="comment">//                      AnyTaskScheduler *consumerTask,</span></div>
<div class="line"><a name="l01745"></a><span class="lineno"> 1745</span>&#160;<span class="comment">//                      std::shared_ptr&lt;AnyConnector&gt; origConnector) {</span></div>
<div class="line"><a name="l01746"></a><span class="lineno"> 1746</span>&#160;<span class="comment">//    // Add rule to bookkeeper</span></div>
<div class="line"><a name="l01747"></a><span class="lineno"> 1747</span>&#160;<span class="comment">//    bk-&gt;addRuleManager(ruleMan);</span></div>
<div class="line"><a name="l01748"></a><span class="lineno"> 1748</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01749"></a><span class="lineno"> 1749</span>&#160;<span class="comment">//    std::shared_ptr&lt;AnyConnector&gt; connector;</span></div>
<div class="line"><a name="l01750"></a><span class="lineno"> 1750</span>&#160;<span class="comment">//    if (consumerTaskConnectorMap-&gt;find(consumerTask) != this-&gt;consumerTaskConnectorMap-&gt;end()) {</span></div>
<div class="line"><a name="l01751"></a><span class="lineno"> 1751</span>&#160;<span class="comment">//      connector = this-&gt;consumerTaskConnectorMap-&gt;find(consumerTask)-&gt;second;</span></div>
<div class="line"><a name="l01752"></a><span class="lineno"> 1752</span>&#160;<span class="comment">//      ruleMan-&gt;setOutputConnector(connector);</span></div>
<div class="line"><a name="l01753"></a><span class="lineno"> 1753</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01754"></a><span class="lineno"> 1754</span>&#160;<span class="comment">//    else {</span></div>
<div class="line"><a name="l01755"></a><span class="lineno"> 1755</span>&#160;<span class="comment">//      connector = std::shared_ptr&lt;AnyConnector&gt;(origConnector-&gt;copy());</span></div>
<div class="line"><a name="l01756"></a><span class="lineno"> 1756</span>&#160;<span class="comment">//      ruleMan-&gt;setOutputConnector(connector);</span></div>
<div class="line"><a name="l01757"></a><span class="lineno"> 1757</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01758"></a><span class="lineno"> 1758</span>&#160;<span class="comment">//      consumerTask-&gt;setInputConnector(connector);</span></div>
<div class="line"><a name="l01759"></a><span class="lineno"> 1759</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01760"></a><span class="lineno"> 1760</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01761"></a><span class="lineno"> 1761</span>&#160;<span class="comment">//    updateGraphHistory(bkTask, false, false);</span></div>
<div class="line"><a name="l01762"></a><span class="lineno"> 1762</span>&#160;<span class="comment">//    updateGraphHistory(consumerTask, true, false);</span></div>
<div class="line"><a name="l01763"></a><span class="lineno"> 1763</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01764"></a><span class="lineno"> 1764</span>&#160;<span class="comment">//    this-&gt;bookkeeperKeys-&gt;push_back(new BookkeeperKey(bkTask, bk, ruleMan, consumerTask));</span></div>
<div class="line"><a name="l01765"></a><span class="lineno"> 1765</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l01766"></a><span class="lineno"> 1766</span>&#160;</div>
<div class="line"><a name="l01767"></a><span class="lineno"> 1767</span>&#160;</div>
<div class="line"><a name="l01768"></a><span class="lineno"> 1768</span>&#160;<span class="comment">//  void addEdge(AnyTaskScheduler *producer, AnyTaskScheduler *consumer, std::shared_ptr&lt;AnyConnector&gt; origConnector) {</span></div>
<div class="line"><a name="l01769"></a><span class="lineno"> 1769</span>&#160;<span class="comment">//    std::shared_ptr&lt;AnyConnector&gt; connector;</span></div>
<div class="line"><a name="l01770"></a><span class="lineno"> 1770</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01771"></a><span class="lineno"> 1771</span>&#160;<span class="comment">//    if (this-&gt;consumerTaskConnectorMap-&gt;find(consumer) != this-&gt;consumerTaskConnectorMap-&gt;end()) {</span></div>
<div class="line"><a name="l01772"></a><span class="lineno"> 1772</span>&#160;<span class="comment">//      connector = this-&gt;consumerTaskConnectorMap-&gt;find(consumer)-&gt;second;</span></div>
<div class="line"><a name="l01773"></a><span class="lineno"> 1773</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01774"></a><span class="lineno"> 1774</span>&#160;<span class="comment">//      producer-&gt;setOutputConnector(connector);</span></div>
<div class="line"><a name="l01775"></a><span class="lineno"> 1775</span>&#160;<span class="comment">//      connector-&gt;incrementInputTaskCount();</span></div>
<div class="line"><a name="l01776"></a><span class="lineno"> 1776</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01777"></a><span class="lineno"> 1777</span>&#160;<span class="comment">//      this-&gt;consumerTaskConnectorMap-&gt;insert(ConnectorPair(consumer, connector));</span></div>
<div class="line"><a name="l01778"></a><span class="lineno"> 1778</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01779"></a><span class="lineno"> 1779</span>&#160;<span class="comment">//    else {</span></div>
<div class="line"><a name="l01780"></a><span class="lineno"> 1780</span>&#160;<span class="comment">//      connector = std::shared_ptr&lt;AnyConnector&gt;(origConnector-&gt;copy());</span></div>
<div class="line"><a name="l01781"></a><span class="lineno"> 1781</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01782"></a><span class="lineno"> 1782</span>&#160;<span class="comment">//      producer-&gt;setOutputConnector(connector);</span></div>
<div class="line"><a name="l01783"></a><span class="lineno"> 1783</span>&#160;<span class="comment">//      consumer-&gt;setInputConnector(connector);</span></div>
<div class="line"><a name="l01784"></a><span class="lineno"> 1784</span>&#160;<span class="comment">//      connector-&gt;incrementInputTaskCount();</span></div>
<div class="line"><a name="l01785"></a><span class="lineno"> 1785</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01786"></a><span class="lineno"> 1786</span>&#160;<span class="comment">//      this-&gt;consumerTaskConnectorMap-&gt;insert(ConnectorPair(consumer, connector));</span></div>
<div class="line"><a name="l01787"></a><span class="lineno"> 1787</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01788"></a><span class="lineno"> 1788</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01789"></a><span class="lineno"> 1789</span>&#160;<span class="comment">//    updateGraphHistory(producer, false, true);</span></div>
<div class="line"><a name="l01790"></a><span class="lineno"> 1790</span>&#160;<span class="comment">//    updateGraphHistory(consumer, true, false);</span></div>
<div class="line"><a name="l01791"></a><span class="lineno"> 1791</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01792"></a><span class="lineno"> 1792</span>&#160;<span class="comment">//    this-&gt;producerConsumerKeys-&gt;push_back(new ProducerConsumerKey(producer, consumer));</span></div>
<div class="line"><a name="l01793"></a><span class="lineno"> 1793</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l01794"></a><span class="lineno"> 1794</span>&#160;</div>
<div class="line"><a name="l01795"></a><span class="lineno"> 1795</span>&#160;<span class="comment">//  bool hasITask(AnyITask *task)</span></div>
<div class="line"><a name="l01796"></a><span class="lineno"> 1796</span>&#160;<span class="comment">//  {</span></div>
<div class="line"><a name="l01797"></a><span class="lineno"> 1797</span>&#160;<span class="comment">//    return this-&gt;iTaskMap-&gt;find(task) != this-&gt;iTaskMap-&gt;end();</span></div>
<div class="line"><a name="l01798"></a><span class="lineno"> 1798</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l01799"></a><span class="lineno"> 1799</span>&#160;</div>
<div class="line"><a name="l01800"></a><span class="lineno"> 1800</span>&#160;<span class="comment">//  template &lt;class V&gt;</span></div>
<div class="line"><a name="l01801"></a><span class="lineno"> 1801</span>&#160;<span class="comment">//  std::shared_ptr&lt;IMemoryAllocator&lt;V&gt;&gt; getMemoryAllocator(IMemoryAllocator&lt;V&gt; *allocator)</span></div>
<div class="line"><a name="l01802"></a><span class="lineno"> 1802</span>&#160;<span class="comment">//  {</span></div>
<div class="line"><a name="l01803"></a><span class="lineno"> 1803</span>&#160;<span class="comment">//    std::shared_ptr&lt;IMemoryAllocator&lt;V&gt;&gt; allocP;</span></div>
<div class="line"><a name="l01804"></a><span class="lineno"> 1804</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01805"></a><span class="lineno"> 1805</span>&#160;<span class="comment">//    if (this-&gt;memAllocMap-&gt;find(allocator) == this-&gt;memAllocMap-&gt;end())</span></div>
<div class="line"><a name="l01806"></a><span class="lineno"> 1806</span>&#160;<span class="comment">//    {</span></div>
<div class="line"><a name="l01807"></a><span class="lineno"> 1807</span>&#160;<span class="comment">//      allocP = std::shared_ptr&lt;IMemoryAllocator&lt;V&gt;&gt;(allocator);</span></div>
<div class="line"><a name="l01808"></a><span class="lineno"> 1808</span>&#160;<span class="comment">//      memAllocMap-&gt;insert(MemAllocPair(allocator, allocP));</span></div>
<div class="line"><a name="l01809"></a><span class="lineno"> 1809</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01810"></a><span class="lineno"> 1810</span>&#160;<span class="comment">//    else</span></div>
<div class="line"><a name="l01811"></a><span class="lineno"> 1811</span>&#160;<span class="comment">//    {</span></div>
<div class="line"><a name="l01812"></a><span class="lineno"> 1812</span>&#160;<span class="comment">//      allocP = std::dynamic_pointer_cast&lt;IMemoryAllocator&lt;V&gt;&gt;(this-&gt;memAllocMap-&gt;at(allocator));</span></div>
<div class="line"><a name="l01813"></a><span class="lineno"> 1813</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01814"></a><span class="lineno"> 1814</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01815"></a><span class="lineno"> 1815</span>&#160;<span class="comment">//    return allocP;</span></div>
<div class="line"><a name="l01816"></a><span class="lineno"> 1816</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l01817"></a><span class="lineno"> 1817</span>&#160;</div>
<div class="line"><a name="l01818"></a><span class="lineno"> 1818</span>&#160;<span class="comment">//  template &lt;class V&gt;</span></div>
<div class="line"><a name="l01819"></a><span class="lineno"> 1819</span>&#160;<span class="comment">//  MemoryManager&lt;V&gt; *getMemoryManager(AnyITask *memGetter, std::string name, int memoryPoolSize, std::shared_ptr&lt;IMemoryAllocator&lt;V&gt;&gt; allocP, MMType type, bool *ignoreMemGetterErrors)</span></div>
<div class="line"><a name="l01820"></a><span class="lineno"> 1820</span>&#160;<span class="comment">//  {</span></div>
<div class="line"><a name="l01821"></a><span class="lineno"> 1821</span>&#160;<span class="comment">//    MemoryManager&lt;V&gt; *memManager;</span></div>
<div class="line"><a name="l01822"></a><span class="lineno"> 1822</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01823"></a><span class="lineno"> 1823</span>&#160;<span class="comment">//    // Check if memoryEdges has a memory edge, if it does then check if the specified name is created</span></div>
<div class="line"><a name="l01824"></a><span class="lineno"> 1824</span>&#160;<span class="comment">//    if (memGetterMap-&gt;find(memGetter) == this-&gt;memGetterMap-&gt;end())</span></div>
<div class="line"><a name="l01825"></a><span class="lineno"> 1825</span>&#160;<span class="comment">//    {</span></div>
<div class="line"><a name="l01826"></a><span class="lineno"> 1826</span>&#160;<span class="comment">//      // The memoryEdges does not have any memory edges associated with it</span></div>
<div class="line"><a name="l01827"></a><span class="lineno"> 1827</span>&#160;<span class="comment">//      memManager = new MemoryManager&lt;V&gt;(name, memoryPoolSize, allocP, type);</span></div>
<div class="line"><a name="l01828"></a><span class="lineno"> 1828</span>&#160;<span class="comment">//      MemManagerMap *mmMap = new MemManagerMap();</span></div>
<div class="line"><a name="l01829"></a><span class="lineno"> 1829</span>&#160;<span class="comment">//      mmMap-&gt;insert(MemManagerPair(name, memManager));</span></div>
<div class="line"><a name="l01830"></a><span class="lineno"> 1830</span>&#160;<span class="comment">//      memGetterMap-&gt;insert(MemGetterPair(memGetter, mmMap));</span></div>
<div class="line"><a name="l01831"></a><span class="lineno"> 1831</span>&#160;<span class="comment">//      *ignoreMemGetterErrors = false;</span></div>
<div class="line"><a name="l01832"></a><span class="lineno"> 1832</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01833"></a><span class="lineno"> 1833</span>&#160;<span class="comment">//    else</span></div>
<div class="line"><a name="l01834"></a><span class="lineno"> 1834</span>&#160;<span class="comment">//    {</span></div>
<div class="line"><a name="l01835"></a><span class="lineno"> 1835</span>&#160;<span class="comment">//      // MemGetter has some memory edges</span></div>
<div class="line"><a name="l01836"></a><span class="lineno"> 1836</span>&#160;<span class="comment">//      // Now identify if the specified named edge already exists</span></div>
<div class="line"><a name="l01837"></a><span class="lineno"> 1837</span>&#160;<span class="comment">//      MemManagerMap *mmMap = memGetterMap-&gt;at(memGetter);</span></div>
<div class="line"><a name="l01838"></a><span class="lineno"> 1838</span>&#160;<span class="comment">//      if (mmMap-&gt;find(name) == mmMap-&gt;end())</span></div>
<div class="line"><a name="l01839"></a><span class="lineno"> 1839</span>&#160;<span class="comment">//      {</span></div>
<div class="line"><a name="l01840"></a><span class="lineno"> 1840</span>&#160;<span class="comment">//        // No memory manager found with name, create a new one and add it</span></div>
<div class="line"><a name="l01841"></a><span class="lineno"> 1841</span>&#160;<span class="comment">//        memManager = new MemoryManager&lt;V&gt;(name, memoryPoolSize, allocP, type);</span></div>
<div class="line"><a name="l01842"></a><span class="lineno"> 1842</span>&#160;<span class="comment">//        mmMap-&gt;insert(MemManagerPair(name, memManager));</span></div>
<div class="line"><a name="l01843"></a><span class="lineno"> 1843</span>&#160;<span class="comment">//        *ignoreMemGetterErrors = false;</span></div>
<div class="line"><a name="l01844"></a><span class="lineno"> 1844</span>&#160;<span class="comment">//      }</span></div>
<div class="line"><a name="l01845"></a><span class="lineno"> 1845</span>&#160;<span class="comment">//      else</span></div>
<div class="line"><a name="l01846"></a><span class="lineno"> 1846</span>&#160;<span class="comment">//      {</span></div>
<div class="line"><a name="l01847"></a><span class="lineno"> 1847</span>&#160;<span class="comment">//        // Memory manager found with name, reuse the stored memory manager</span></div>
<div class="line"><a name="l01848"></a><span class="lineno"> 1848</span>&#160;<span class="comment">//        memManager = (MemoryManager&lt;V&gt; *)mmMap-&gt;at(name);</span></div>
<div class="line"><a name="l01849"></a><span class="lineno"> 1849</span>&#160;<span class="comment">//        *ignoreMemGetterErrors = true;</span></div>
<div class="line"><a name="l01850"></a><span class="lineno"> 1850</span>&#160;<span class="comment">//      }</span></div>
<div class="line"><a name="l01851"></a><span class="lineno"> 1851</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01852"></a><span class="lineno"> 1852</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01853"></a><span class="lineno"> 1853</span>&#160;<span class="comment">//    return memManager;</span></div>
<div class="line"><a name="l01854"></a><span class="lineno"> 1854</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l01855"></a><span class="lineno"> 1855</span>&#160;</div>
<div class="line"><a name="l01856"></a><span class="lineno"> 1856</span>&#160;<span class="comment">//#ifdef USE_CUDA</span></div>
<div class="line"><a name="l01857"></a><span class="lineno"> 1857</span>&#160;<span class="comment">//  template &lt;class V&gt;</span></div>
<div class="line"><a name="l01858"></a><span class="lineno"> 1858</span>&#160;<span class="comment">//  CudaMemoryManager&lt;V&gt; *getCudaMemoryManager(AnyITask *memoryEdges, std::string name, int memoryPoolSize, std::shared_ptr&lt;IMemoryAllocator&lt;V&gt;&gt; allocP, MMType type, CUcontext *contexts, bool *ignoreMemGetterErrors)</span></div>
<div class="line"><a name="l01859"></a><span class="lineno"> 1859</span>&#160;<span class="comment">//  {</span></div>
<div class="line"><a name="l01860"></a><span class="lineno"> 1860</span>&#160;<span class="comment">//    CudaMemoryManager&lt;V&gt; *memManager;</span></div>
<div class="line"><a name="l01861"></a><span class="lineno"> 1861</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01862"></a><span class="lineno"> 1862</span>&#160;<span class="comment">//    // Check if memoryEdges has a memory edge, if it does then check if the specified name is created</span></div>
<div class="line"><a name="l01863"></a><span class="lineno"> 1863</span>&#160;<span class="comment">//    if (memGetterMap-&gt;find(memoryEdges) == this-&gt;memGetterMap-&gt;end())</span></div>
<div class="line"><a name="l01864"></a><span class="lineno"> 1864</span>&#160;<span class="comment">//    {</span></div>
<div class="line"><a name="l01865"></a><span class="lineno"> 1865</span>&#160;<span class="comment">//      // The memoryEdges does not have any memory edges associated with it</span></div>
<div class="line"><a name="l01866"></a><span class="lineno"> 1866</span>&#160;<span class="comment">//      memManager = new CudaMemoryManager&lt;V&gt;(name, contexts, memoryPoolSize, allocP, type);</span></div>
<div class="line"><a name="l01867"></a><span class="lineno"> 1867</span>&#160;<span class="comment">//      MemManagerMap *mmMap = new MemManagerMap();</span></div>
<div class="line"><a name="l01868"></a><span class="lineno"> 1868</span>&#160;<span class="comment">//      mmMap-&gt;insert(MemManagerPair(name, memManager));</span></div>
<div class="line"><a name="l01869"></a><span class="lineno"> 1869</span>&#160;<span class="comment">//      memGetterMap-&gt;insert(MemGetterPair(memoryEdges, mmMap));</span></div>
<div class="line"><a name="l01870"></a><span class="lineno"> 1870</span>&#160;<span class="comment">//      *ignoreMemGetterErrors = false;</span></div>
<div class="line"><a name="l01871"></a><span class="lineno"> 1871</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01872"></a><span class="lineno"> 1872</span>&#160;<span class="comment">//    else</span></div>
<div class="line"><a name="l01873"></a><span class="lineno"> 1873</span>&#160;<span class="comment">//    {</span></div>
<div class="line"><a name="l01874"></a><span class="lineno"> 1874</span>&#160;<span class="comment">//      // MemGetter has some memory edges</span></div>
<div class="line"><a name="l01875"></a><span class="lineno"> 1875</span>&#160;<span class="comment">//      // Now identify if the specified named edge already exists</span></div>
<div class="line"><a name="l01876"></a><span class="lineno"> 1876</span>&#160;<span class="comment">//      MemManagerMap *mmMap = memGetterMap-&gt;at(memoryEdges);</span></div>
<div class="line"><a name="l01877"></a><span class="lineno"> 1877</span>&#160;<span class="comment">//      if (mmMap-&gt;find(name) == mmMap-&gt;end())</span></div>
<div class="line"><a name="l01878"></a><span class="lineno"> 1878</span>&#160;<span class="comment">//      {</span></div>
<div class="line"><a name="l01879"></a><span class="lineno"> 1879</span>&#160;<span class="comment">//        // No memory manager found with name, create a new one and add it</span></div>
<div class="line"><a name="l01880"></a><span class="lineno"> 1880</span>&#160;<span class="comment">//        memManager = new CudaMemoryManager&lt;V&gt;(name, contexts, memoryPoolSize, allocP, type);</span></div>
<div class="line"><a name="l01881"></a><span class="lineno"> 1881</span>&#160;<span class="comment">//        mmMap-&gt;insert(MemManagerPair(name, memManager));</span></div>
<div class="line"><a name="l01882"></a><span class="lineno"> 1882</span>&#160;<span class="comment">//        *ignoreMemGetterErrors = false;</span></div>
<div class="line"><a name="l01883"></a><span class="lineno"> 1883</span>&#160;<span class="comment">//      }</span></div>
<div class="line"><a name="l01884"></a><span class="lineno"> 1884</span>&#160;<span class="comment">//      else</span></div>
<div class="line"><a name="l01885"></a><span class="lineno"> 1885</span>&#160;<span class="comment">//      {</span></div>
<div class="line"><a name="l01886"></a><span class="lineno"> 1886</span>&#160;<span class="comment">//        // Memory manager found with name, reuse the stored memory manager</span></div>
<div class="line"><a name="l01887"></a><span class="lineno"> 1887</span>&#160;<span class="comment">//        memManager = (CudaMemoryManager&lt;V&gt; *)mmMap-&gt;at(name);</span></div>
<div class="line"><a name="l01888"></a><span class="lineno"> 1888</span>&#160;<span class="comment">//        *ignoreMemGetterErrors = true;</span></div>
<div class="line"><a name="l01889"></a><span class="lineno"> 1889</span>&#160;<span class="comment">//      }</span></div>
<div class="line"><a name="l01890"></a><span class="lineno"> 1890</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01891"></a><span class="lineno"> 1891</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01892"></a><span class="lineno"> 1892</span>&#160;<span class="comment">//    return memManager;</span></div>
<div class="line"><a name="l01893"></a><span class="lineno"> 1893</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l01894"></a><span class="lineno"> 1894</span>&#160;<span class="comment">//#endif</span></div>
<div class="line"><a name="l01895"></a><span class="lineno"> 1895</span>&#160;</div>
<div class="line"><a name="l01896"></a><span class="lineno"> 1896</span>&#160;<span class="comment">//  template &lt;class V, class W&gt;</span></div>
<div class="line"><a name="l01897"></a><span class="lineno"> 1897</span>&#160;<span class="comment">//  TaskScheduler&lt;V, W&gt; *getTaskManager(ITask&lt;V, W&gt; *iTask, bool attachConnectors)</span></div>
<div class="line"><a name="l01898"></a><span class="lineno"> 1898</span>&#160;<span class="comment">//  {</span></div>
<div class="line"><a name="l01899"></a><span class="lineno"> 1899</span>&#160;<span class="comment">//    TaskScheduler&lt;V, W&gt; *taskScheduler;</span></div>
<div class="line"><a name="l01900"></a><span class="lineno"> 1900</span>&#160;<span class="comment">//    if (this-&gt;iTaskMap-&gt;find(iTask) == this-&gt;iTaskMap-&gt;end())</span></div>
<div class="line"><a name="l01901"></a><span class="lineno"> 1901</span>&#160;<span class="comment">//    {</span></div>
<div class="line"><a name="l01902"></a><span class="lineno"> 1902</span>&#160;<span class="comment">//      taskScheduler = TaskScheduler&lt;V, W&gt;::createTask(iTask);</span></div>
<div class="line"><a name="l01903"></a><span class="lineno"> 1903</span>&#160;<span class="comment">//      this-&gt;iTaskMap-&gt;insert(ITaskPair(iTask, taskScheduler));</span></div>
<div class="line"><a name="l01904"></a><span class="lineno"> 1904</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01905"></a><span class="lineno"> 1905</span>&#160;<span class="comment">//      if (attachConnectors)</span></div>
<div class="line"><a name="l01906"></a><span class="lineno"> 1906</span>&#160;<span class="comment">//      {</span></div>
<div class="line"><a name="l01907"></a><span class="lineno"> 1907</span>&#160;<span class="comment">//        std::shared_ptr&lt;Connector&lt;V&gt;&gt; inputConnector(new Connector&lt;V&gt;());</span></div>
<div class="line"><a name="l01908"></a><span class="lineno"> 1908</span>&#160;<span class="comment">//        std::shared_ptr&lt;Connector&lt;W&gt;&gt; outputConnector(new Connector&lt;W&gt;());</span></div>
<div class="line"><a name="l01909"></a><span class="lineno"> 1909</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01910"></a><span class="lineno"> 1910</span>&#160;<span class="comment">//        taskScheduler-&gt;setOutputConnector(outputConnector);</span></div>
<div class="line"><a name="l01911"></a><span class="lineno"> 1911</span>&#160;<span class="comment">//        taskScheduler-&gt;setInputConnector(inputConnector);</span></div>
<div class="line"><a name="l01912"></a><span class="lineno"> 1912</span>&#160;<span class="comment">//        outputConnector-&gt;incrementInputTaskCount();</span></div>
<div class="line"><a name="l01913"></a><span class="lineno"> 1913</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01914"></a><span class="lineno"> 1914</span>&#160;<span class="comment">//      }</span></div>
<div class="line"><a name="l01915"></a><span class="lineno"> 1915</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01916"></a><span class="lineno"> 1916</span>&#160;<span class="comment">//    else</span></div>
<div class="line"><a name="l01917"></a><span class="lineno"> 1917</span>&#160;<span class="comment">//    {</span></div>
<div class="line"><a name="l01918"></a><span class="lineno"> 1918</span>&#160;<span class="comment">//      taskScheduler = (TaskScheduler&lt;V, W&gt; *)this-&gt;iTaskMap-&gt;at(iTask);</span></div>
<div class="line"><a name="l01919"></a><span class="lineno"> 1919</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01920"></a><span class="lineno"> 1920</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01921"></a><span class="lineno"> 1921</span>&#160;<span class="comment">//    return taskScheduler;</span></div>
<div class="line"><a name="l01922"></a><span class="lineno"> 1922</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l01923"></a><span class="lineno"> 1923</span>&#160;</div>
<div class="line"><a name="l01924"></a><span class="lineno"> 1924</span>&#160;<span class="comment">//  template &lt;class V, class W, class X&gt;</span></div>
<div class="line"><a name="l01925"></a><span class="lineno"> 1925</span>&#160;<span class="comment">//  RuleManager&lt;V, W&gt; *getRuleManager(Bookkeeper&lt;V&gt; *bk, ITask&lt;W, X&gt; *consumer)</span></div>
<div class="line"><a name="l01926"></a><span class="lineno"> 1926</span>&#160;<span class="comment">//  {</span></div>
<div class="line"><a name="l01927"></a><span class="lineno"> 1927</span>&#160;<span class="comment">//    RuleManager&lt;V, W&gt; *ruleMan;</span></div>
<div class="line"><a name="l01928"></a><span class="lineno"> 1928</span>&#160;<span class="comment">//    std::pair&lt;AnyITask *, AnyITask *&gt; ruleEdge(bk, consumer);</span></div>
<div class="line"><a name="l01929"></a><span class="lineno"> 1929</span>&#160;<span class="comment">//    if (this-&gt;ruleEdgeMap-&gt;find(ruleEdge) != this-&gt;ruleEdgeMap-&gt;end()) {</span></div>
<div class="line"><a name="l01930"></a><span class="lineno"> 1930</span>&#160;<span class="comment">//      ruleMan = (RuleManager&lt;V, W&gt; *) this-&gt;ruleEdgeMap-&gt;find(ruleEdge)-&gt;second;</span></div>
<div class="line"><a name="l01931"></a><span class="lineno"> 1931</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01932"></a><span class="lineno"> 1932</span>&#160;<span class="comment">//    else {</span></div>
<div class="line"><a name="l01933"></a><span class="lineno"> 1933</span>&#160;<span class="comment">//      ruleMan = new RuleManager&lt;V, W&gt;();</span></div>
<div class="line"><a name="l01934"></a><span class="lineno"> 1934</span>&#160;<span class="comment">//      this-&gt;ruleEdgeMap-&gt;insert(RuleEdgePair(ruleEdge, ruleMan));</span></div>
<div class="line"><a name="l01935"></a><span class="lineno"> 1935</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01936"></a><span class="lineno"> 1936</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01937"></a><span class="lineno"> 1937</span>&#160;<span class="comment">//    return ruleMan;</span></div>
<div class="line"><a name="l01938"></a><span class="lineno"> 1938</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l01939"></a><span class="lineno"> 1939</span>&#160;</div>
<div class="line"><a name="l01940"></a><span class="lineno"> 1940</span>&#160;<span class="comment">//  void attachMemGetter(std::string name, AnyITask *memGetter, MMType type, std::shared_ptr&lt;AnyConnector&gt; connector, bool ignoreMemGetterErrors)</span></div>
<div class="line"><a name="l01941"></a><span class="lineno"> 1941</span>&#160;<span class="comment">//  {</span></div>
<div class="line"><a name="l01942"></a><span class="lineno"> 1942</span>&#160;<span class="comment">//    DEBUG(&quot;Adding memory getter &quot; &lt;&lt; name &lt;&lt; &quot; to &quot; &lt;&lt; memGetter-&gt;getName() &lt;&lt; &quot; &quot; &lt;&lt; memGetter &lt;&lt;</span></div>
<div class="line"><a name="l01943"></a><span class="lineno"> 1943</span>&#160;<span class="comment">//        &quot; at connector &quot; &lt;&lt; connector);</span></div>
<div class="line"><a name="l01944"></a><span class="lineno"> 1944</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01945"></a><span class="lineno"> 1945</span>&#160;<span class="comment">//    if (memGetter-&gt;hasMemGetter(name))</span></div>
<div class="line"><a name="l01946"></a><span class="lineno"> 1946</span>&#160;<span class="comment">//    {</span></div>
<div class="line"><a name="l01947"></a><span class="lineno"> 1947</span>&#160;<span class="comment">//      if (!ignoreMemGetterErrors) {</span></div>
<div class="line"><a name="l01948"></a><span class="lineno"> 1948</span>&#160;<span class="comment">//        std::cerr &lt;&lt; &quot;Error memory getter edge &quot; &lt;&lt; name &lt;&lt; &quot; already exists for task: &quot; &lt;&lt; memGetter-&gt;getName()</span></div>
<div class="line"><a name="l01949"></a><span class="lineno"> 1949</span>&#160;<span class="comment">//            &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l01950"></a><span class="lineno"> 1950</span>&#160;<span class="comment">//      }</span></div>
<div class="line"><a name="l01951"></a><span class="lineno"> 1951</span>&#160;<span class="comment">//      return;</span></div>
<div class="line"><a name="l01952"></a><span class="lineno"> 1952</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01953"></a><span class="lineno"> 1953</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01954"></a><span class="lineno"> 1954</span>&#160;<span class="comment">//    memGetter-&gt;attachMemGetter(name, connector, type);</span></div>
<div class="line"><a name="l01955"></a><span class="lineno"> 1955</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l01956"></a><span class="lineno"> 1956</span>&#160;</div>
<div class="line"><a name="l01957"></a><span class="lineno"> 1957</span>&#160;<span class="comment">//  void attachMemReleaser(std::string name, AnyITask *memReleaser, MMType type, std::shared_ptr&lt;AnyConnector&gt; connector, bool isReleaserOutsideGraph)</span></div>
<div class="line"><a name="l01958"></a><span class="lineno"> 1958</span>&#160;<span class="comment">//  {</span></div>
<div class="line"><a name="l01959"></a><span class="lineno"> 1959</span>&#160;<span class="comment">//    DEBUG(&quot;Adding memory releaser &quot; &lt;&lt; name &lt;&lt; &quot; to &quot; &lt;&lt; memReleaser-&gt;getName() &lt;&lt; &quot; &quot; &lt;&lt; memReleaser &lt;&lt;</span></div>
<div class="line"><a name="l01960"></a><span class="lineno"> 1960</span>&#160;<span class="comment">//        &quot; at connector &quot; &lt;&lt; connector);</span></div>
<div class="line"><a name="l01961"></a><span class="lineno"> 1961</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01962"></a><span class="lineno"> 1962</span>&#160;<span class="comment">//    if (memReleaser-&gt;hasMemReleaser(name))</span></div>
<div class="line"><a name="l01963"></a><span class="lineno"> 1963</span>&#160;<span class="comment">//    {</span></div>
<div class="line"><a name="l01964"></a><span class="lineno"> 1964</span>&#160;<span class="comment">//      std::cerr &lt;&lt; &quot;Error memory releaser edge &quot; &lt;&lt; name &lt;&lt; &quot; already exists for task: &quot; &lt;&lt; memReleaser-&gt;getName() &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l01965"></a><span class="lineno"> 1965</span>&#160;<span class="comment">//      return;</span></div>
<div class="line"><a name="l01966"></a><span class="lineno"> 1966</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01967"></a><span class="lineno"> 1967</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01968"></a><span class="lineno"> 1968</span>&#160;<span class="comment">//    memReleaser-&gt;attachMemReleaser(name, connector, type, isReleaserOutsideGraph);</span></div>
<div class="line"><a name="l01969"></a><span class="lineno"> 1969</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l01970"></a><span class="lineno"> 1970</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01971"></a><span class="lineno"> 1971</span>&#160;<span class="comment">//  void updateGraphHistory(AnyTaskScheduler *taskScheduler, bool addInputEdge, bool addOutputEdge)</span></div>
<div class="line"><a name="l01972"></a><span class="lineno"> 1972</span>&#160;<span class="comment">//  {</span></div>
<div class="line"><a name="l01973"></a><span class="lineno"> 1973</span>&#160;<span class="comment">//    if (taskScheduler == nullptr)</span></div>
<div class="line"><a name="l01974"></a><span class="lineno"> 1974</span>&#160;<span class="comment">//      return;</span></div>
<div class="line"><a name="l01975"></a><span class="lineno"> 1975</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01976"></a><span class="lineno"> 1976</span>&#160;<span class="comment">//    if (std::find(vertices-&gt;begin(), vertices-&gt;end(), taskScheduler) == vertices-&gt;end()) {</span></div>
<div class="line"><a name="l01977"></a><span class="lineno"> 1977</span>&#160;<span class="comment">//      this-&gt;vertices-&gt;push_back(taskScheduler);</span></div>
<div class="line"><a name="l01978"></a><span class="lineno"> 1978</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01979"></a><span class="lineno"> 1979</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01980"></a><span class="lineno"> 1980</span>&#160;<span class="comment">//    if (this-&gt;iTaskMap-&gt;find(taskScheduler-&gt;getTaskFunction()) == this-&gt;iTaskMap-&gt;end()) {</span></div>
<div class="line"><a name="l01981"></a><span class="lineno"> 1981</span>&#160;<span class="comment">//      this-&gt;iTaskMap-&gt;insert(ITaskPair(taskScheduler-&gt;getTaskFunction(), taskScheduler));</span></div>
<div class="line"><a name="l01982"></a><span class="lineno"> 1982</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01983"></a><span class="lineno"> 1983</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01984"></a><span class="lineno"> 1984</span>&#160;<span class="comment">//    if (addInputEdge) {</span></div>
<div class="line"><a name="l01985"></a><span class="lineno"> 1985</span>&#160;<span class="comment">//      if (std::find(edges-&gt;begin(), edges-&gt;end(), taskScheduler-&gt;getInputBaseConnector()) == edges-&gt;end()) {</span></div>
<div class="line"><a name="l01986"></a><span class="lineno"> 1986</span>&#160;<span class="comment">//        this-&gt;edges-&gt;push_back(taskScheduler-&gt;getInputBaseConnector());</span></div>
<div class="line"><a name="l01987"></a><span class="lineno"> 1987</span>&#160;<span class="comment">//      }</span></div>
<div class="line"><a name="l01988"></a><span class="lineno"> 1988</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01989"></a><span class="lineno"> 1989</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l01990"></a><span class="lineno"> 1990</span>&#160;<span class="comment">//    if (addOutputEdge) {</span></div>
<div class="line"><a name="l01991"></a><span class="lineno"> 1991</span>&#160;<span class="comment">//      if (std::find(edges-&gt;begin(), edges-&gt;end(), taskScheduler-&gt;getOutputBaseConnector()) == edges-&gt;end()) {</span></div>
<div class="line"><a name="l01992"></a><span class="lineno"> 1992</span>&#160;<span class="comment">//        this-&gt;edges-&gt;push_back(taskScheduler-&gt;getOutputBaseConnector());</span></div>
<div class="line"><a name="l01993"></a><span class="lineno"> 1993</span>&#160;<span class="comment">//      }</span></div>
<div class="line"><a name="l01994"></a><span class="lineno"> 1994</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01995"></a><span class="lineno"> 1995</span>&#160;<span class="comment">//  }</span></div>
<div class="line"><a name="l01996"></a><span class="lineno"> 1996</span>&#160;</div>
<div class="line"><a name="l01997"></a><span class="lineno"> 1997</span>&#160;</div>
<div class="line"><a name="l01998"></a><span class="lineno"> 1998</span>&#160;  <span class="keywordtype">void</span> copyAndUpdateGraphConsumerTask(<a class="code" href="classhtgs_1_1_any_task_scheduler.html">AnyTaskScheduler</a> *taskScheduler)</div>
<div class="line"><a name="l01999"></a><span class="lineno"> 1999</span>&#160;  {</div>
<div class="line"><a name="l02000"></a><span class="lineno"> 2000</span>&#160;    <span class="keywordflow">if</span> (taskScheduler != <span class="keyword">nullptr</span>) {</div>
<div class="line"><a name="l02001"></a><span class="lineno"> 2001</span>&#160;      <a class="code" href="classhtgs_1_1_any_task_scheduler.html">AnyTaskScheduler</a> *copy = this-&gt;getTaskManagerCopy(taskScheduler-&gt;<a class="code" href="classhtgs_1_1_any_task_scheduler.html#a4c96ed2ca3802f3a85b35e3d1006a6bf">getTaskFunction</a>());</div>
<div class="line"><a name="l02002"></a><span class="lineno"> 2002</span>&#160;      this-&gt;<a class="code" href="classhtgs_1_1_task_graph.html#a73c039d4e4517f84d5b311871157584e">graphConsumerTaskManager</a> = copy;</div>
<div class="line"><a name="l02003"></a><span class="lineno"> 2003</span>&#160;      this-&gt;graphConsumerTaskManager-&gt;<a class="code" href="classhtgs_1_1_any_task_scheduler.html#afbed88d7a0cbd49d184a385892775694">setInputConnector</a>(this-&gt;<a class="code" href="classhtgs_1_1_task_graph.html#a839fa5eee17aa8dde3e25586984c5369">input</a>);</div>
<div class="line"><a name="l02004"></a><span class="lineno"> 2004</span>&#160;      this-&gt;addTaskManager(this-&gt;graphConsumerTaskManager);</div>
<div class="line"><a name="l02005"></a><span class="lineno"> 2005</span>&#160;    }</div>
<div class="line"><a name="l02006"></a><span class="lineno"> 2006</span>&#160;  }</div>
<div class="line"><a name="l02007"></a><span class="lineno"> 2007</span>&#160;</div>
<div class="line"><a name="l02008"></a><span class="lineno"> 2008</span>&#160;  <span class="keywordtype">void</span> copyAndUpdateGraphProducerTask(AnyTaskScheduler *taskScheduler)</div>
<div class="line"><a name="l02009"></a><span class="lineno"> 2009</span>&#160;  {</div>
<div class="line"><a name="l02010"></a><span class="lineno"> 2010</span>&#160;    <span class="keywordflow">if</span> (taskScheduler != <span class="keyword">nullptr</span>) {</div>
<div class="line"><a name="l02011"></a><span class="lineno"> 2011</span>&#160;      AnyTaskScheduler *copy = this-&gt;getTaskManagerCopy(taskScheduler-&gt;getTaskFunction());</div>
<div class="line"><a name="l02012"></a><span class="lineno"> 2012</span>&#160;</div>
<div class="line"><a name="l02013"></a><span class="lineno"> 2013</span>&#160;      <span class="comment">// TODO: Number of active connections for Connector</span></div>
<div class="line"><a name="l02014"></a><span class="lineno"> 2014</span>&#160;      this-&gt;<a class="code" href="classhtgs_1_1_task_graph.html#ac60eb3eb99b077b53ff3a68eb43a5c8e">graphProducerTaskManager</a> = copy;</div>
<div class="line"><a name="l02015"></a><span class="lineno"> 2015</span>&#160;      this-&gt;graphProducerTaskManager-&gt;<a class="code" href="classhtgs_1_1_any_task_scheduler.html#a2b72dda29cceb6699050458cdbf473cc">setOutputConnector</a>(this-&gt;<a class="code" href="classhtgs_1_1_task_graph.html#a7c35ca0b3e8f5e33f276479210e28320">output</a>);</div>
<div class="line"><a name="l02016"></a><span class="lineno"> 2016</span>&#160;      this-&gt;<a class="code" href="classhtgs_1_1_task_graph.html#a7c35ca0b3e8f5e33f276479210e28320">output</a>-&gt;incrementInputTaskCount();</div>
<div class="line"><a name="l02017"></a><span class="lineno"> 2017</span>&#160;      this-&gt;addTaskManager(this-&gt;graphProducerTaskManager);</div>
<div class="line"><a name="l02018"></a><span class="lineno"> 2018</span>&#160;    }</div>
<div class="line"><a name="l02019"></a><span class="lineno"> 2019</span>&#160;  }</div>
<div class="line"><a name="l02020"></a><span class="lineno"> 2020</span>&#160;</div>
<div class="line"><a name="l02021"></a><span class="lineno"> 2021</span>&#160;  <span class="keywordtype">void</span> addEdgeDescriptor(EdgeDescriptor *edge)</div>
<div class="line"><a name="l02022"></a><span class="lineno"> 2022</span>&#160;  {</div>
<div class="line"><a name="l02023"></a><span class="lineno"> 2023</span>&#160;    this-&gt;edges-&gt;push_back(edge);</div>
<div class="line"><a name="l02024"></a><span class="lineno"> 2024</span>&#160;  }</div>
<div class="line"><a name="l02025"></a><span class="lineno"> 2025</span>&#160;</div>
<div class="line"><a name="l02027"></a><span class="lineno"><a class="line" href="classhtgs_1_1_task_graph.html#a9530b9db723598005535c53049a9c24e"> 2027</a></span>&#160;  std::list&lt;EdgeDescriptor *&gt; *<a class="code" href="classhtgs_1_1_task_graph.html#a9530b9db723598005535c53049a9c24e">edges</a>;</div>
<div class="line"><a name="l02028"></a><span class="lineno"> 2028</span>&#160;</div>
<div class="line"><a name="l02029"></a><span class="lineno"><a class="line" href="classhtgs_1_1_task_graph.html#a73c039d4e4517f84d5b311871157584e"> 2029</a></span>&#160;  <a class="code" href="classhtgs_1_1_any_task_scheduler.html">AnyTaskScheduler</a> *<a class="code" href="classhtgs_1_1_task_graph.html#a73c039d4e4517f84d5b311871157584e">graphConsumerTaskManager</a>; </div>
<div class="line"><a name="l02030"></a><span class="lineno"><a class="line" href="classhtgs_1_1_task_graph.html#ac60eb3eb99b077b53ff3a68eb43a5c8e"> 2030</a></span>&#160;  <a class="code" href="classhtgs_1_1_any_task_scheduler.html">AnyTaskScheduler</a> *<a class="code" href="classhtgs_1_1_task_graph.html#ac60eb3eb99b077b53ff3a68eb43a5c8e">graphProducerTaskManager</a>; </div>
<div class="line"><a name="l02031"></a><span class="lineno"> 2031</span>&#160;</div>
<div class="line"><a name="l02032"></a><span class="lineno"><a class="line" href="classhtgs_1_1_task_graph.html#a839fa5eee17aa8dde3e25586984c5369"> 2032</a></span>&#160;  std::shared_ptr&lt;Connector&lt;T&gt;&gt; <a class="code" href="classhtgs_1_1_task_graph.html#a839fa5eee17aa8dde3e25586984c5369">input</a>; </div>
<div class="line"><a name="l02033"></a><span class="lineno"><a class="line" href="classhtgs_1_1_task_graph.html#a7c35ca0b3e8f5e33f276479210e28320"> 2033</a></span>&#160;  std::shared_ptr&lt;Connector&lt;U&gt;&gt; <a class="code" href="classhtgs_1_1_task_graph.html#a7c35ca0b3e8f5e33f276479210e28320">output</a>; </div>
<div class="line"><a name="l02034"></a><span class="lineno"> 2034</span>&#160;</div>
<div class="line"><a name="l02035"></a><span class="lineno"> 2035</span>&#160;};</div>
<div class="line"><a name="l02036"></a><span class="lineno"> 2036</span>&#160;}</div>
<div class="line"><a name="l02037"></a><span class="lineno"> 2037</span>&#160;</div>
<div class="line"><a name="l02038"></a><span class="lineno"> 2038</span>&#160;<span class="preprocessor">#endif //HTGS_TASKGRAPH_HPP</span></div>
<div class="ttc" id="classhtgs_1_1_task_graph_html_a2d896acdc5a27ed9db6340cd2b5995ed"><div class="ttname"><a href="classhtgs_1_1_task_graph.html#a2d896acdc5a27ed9db6340cd2b5995ed">htgs::TaskGraph::produceData</a></div><div class="ttdeci">void produceData(std::shared_ptr&lt; T &gt; data)</div><div class="ttdoc">Produces data for the input of the TaskGraph. </div><div class="ttdef"><b>Definition:</b> TaskGraph.hpp:511</div></div>
<div class="ttc" id="classhtgs_1_1_any_i_task_html"><div class="ttname"><a href="classhtgs_1_1_any_i_task.html">htgs::AnyITask</a></div><div class="ttdoc">Implements the parent ITask, which removes the template arguments of an ITask. </div><div class="ttdef"><b>Definition:</b> AnyITask.hpp:39</div></div>
<div class="ttc" id="classhtgs_1_1_cuda_memory_manager_html"><div class="ttname"><a href="classhtgs_1_1_cuda_memory_manager.html">htgs::CudaMemoryManager</a></div><div class="ttdoc">Implements a MemoryManager that binds the thread responsible for the MemoryManager to a Cuda GPU prio...</div><div class="ttdef"><b>Definition:</b> CudaMemoryManager.hpp:33</div></div>
<div class="ttc" id="classhtgs_1_1_task_graph_html_afeb08f2cdf202215129b6f2b2d9e59ab"><div class="ttname"><a href="classhtgs_1_1_task_graph.html#afeb08f2cdf202215129b6f2b2d9e59ab">htgs::TaskGraph::addUserManagedMemoryManagerEdge</a></div><div class="ttdeci">void addUserManagedMemoryManagerEdge(std::string name, AnyITask *getMemoryTask, AnyITask *releaseMemoryTask, size_t memoryPoolSize)</div><div class="ttdoc">Adds a MemoryManager that is managed by the user. </div><div class="ttdef"><b>Definition:</b> TaskGraph.hpp:386</div></div>
<div class="ttc" id="classhtgs_1_1_task_graph_html_a9530b9db723598005535c53049a9c24e"><div class="ttname"><a href="classhtgs_1_1_task_graph.html#a9530b9db723598005535c53049a9c24e">htgs::TaskGraph::edges</a></div><div class="ttdeci">std::list&lt; EdgeDescriptor * &gt; * edges</div><div class="ttdoc">Writes the dot representation of the task graph to disk. </div><div class="ttdef"><b>Definition:</b> TaskGraph.hpp:2027</div></div>
<div class="ttc" id="classhtgs_1_1_any_task_graph_html_a5e2c111406e04640fd8841658cca55a0"><div class="ttname"><a href="classhtgs_1_1_any_task_graph.html#a5e2c111406e04640fd8841658cca55a0">htgs::AnyTaskGraph::getTaskManagers</a></div><div class="ttdeci">virtual std::list&lt; AnyTaskScheduler * &gt; * getTaskManagers()</div><div class="ttdoc">Pure virtual function to get the vertices of the TaskGraph. </div><div class="ttdef"><b>Definition:</b> AnyTaskGraph.hpp:61</div></div>
<div class="ttc" id="classhtgs_1_1_any_task_scheduler_html_afbed88d7a0cbd49d184a385892775694"><div class="ttname"><a href="classhtgs_1_1_any_task_scheduler.html#afbed88d7a0cbd49d184a385892775694">htgs::AnyTaskScheduler::setInputConnector</a></div><div class="ttdeci">virtual void setInputConnector(std::shared_ptr&lt; AnyConnector &gt; connector)=0</div><div class="ttdoc">Sets the input BaseConnector. </div></div>
<div class="ttc" id="classhtgs_1_1_any_task_graph_html"><div class="ttname"><a href="classhtgs_1_1_any_task_graph.html">htgs::AnyTaskGraph</a></div><div class="ttdef"><b>Definition:</b> AnyTaskGraph.hpp:33</div></div>
<div class="ttc" id="classhtgs_1_1_memory_edge_html"><div class="ttname"><a href="classhtgs_1_1_memory_edge.html">htgs::MemoryEdge</a></div><div class="ttdef"><b>Definition:</b> MemoryEdge.hpp:13</div></div>
<div class="ttc" id="classhtgs_1_1_task_graph_html_a839fa5eee17aa8dde3e25586984c5369"><div class="ttname"><a href="classhtgs_1_1_task_graph.html#a839fa5eee17aa8dde3e25586984c5369">htgs::TaskGraph::input</a></div><div class="ttdeci">std::shared_ptr&lt; Connector&lt; T &gt; &gt; input</div><div class="ttdoc">The input connector for the TaskGraph. </div><div class="ttdef"><b>Definition:</b> TaskGraph.hpp:2032</div></div>
<div class="ttc" id="_void_memory_allocator_8hpp_html"><div class="ttname"><a href="_void_memory_allocator_8hpp.html">VoidMemoryAllocator.hpp</a></div><div class="ttdoc">Provides the implementation for a Void memory allocator. </div></div>
<div class="ttc" id="classhtgs_1_1_connector_html"><div class="ttname"><a href="classhtgs_1_1_connector.html">htgs::Connector</a></div><div class="ttdoc">Manages the input/output of IData between Tasks. </div><div class="ttdef"><b>Definition:</b> Connector.hpp:57</div></div>
<div class="ttc" id="classhtgs_1_1_task_graph_html_ad89bcb6c378447e939df51b49a2c07ce"><div class="ttname"><a href="classhtgs_1_1_task_graph.html#ad89bcb6c378447e939df51b49a2c07ce">htgs::TaskGraph::~TaskGraph</a></div><div class="ttdeci">~TaskGraph() override</div><div class="ttdoc">Constructs a TaskGraph with the specified input and output Connector. </div><div class="ttdef"><b>Definition:</b> TaskGraph.hpp:198</div></div>
<div class="ttc" id="classhtgs_1_1_task_graph_html_a5e88c706326e36faf5cc705c1d7ed345"><div class="ttname"><a href="classhtgs_1_1_task_graph.html#a5e88c706326e36faf5cc705c1d7ed345">htgs::TaskGraph::TaskGraph</a></div><div class="ttdeci">TaskGraph(size_t pipelineId, size_t numPipelines)</div><div class="ttdoc">Constructs a TaskGraph. </div><div class="ttdef"><b>Definition:</b> TaskGraph.hpp:140</div></div>
<div class="ttc" id="classhtgs_1_1_task_graph_html_a0ad46b99c6a98747464100e1a739a419"><div class="ttname"><a href="classhtgs_1_1_task_graph.html#a0ad46b99c6a98747464100e1a739a419">htgs::TaskGraph::isOutputTerminated</a></div><div class="ttdeci">bool isOutputTerminated()</div><div class="ttdoc">Checks if the output of the TaskGraph has finished producing data. </div><div class="ttdef"><b>Definition:</b> TaskGraph.hpp:556</div></div>
<div class="ttc" id="classhtgs_1_1_memory_manager_html"><div class="ttname"><a href="classhtgs_1_1_memory_manager.html">htgs::MemoryManager</a></div><div class="ttdoc">Processes MemoryData between two ITasks using a memory pool. </div><div class="ttdef"><b>Definition:</b> MemoryManager.hpp:51</div></div>
<div class="ttc" id="classhtgs_1_1_any_task_graph_html_aa22ef2947e9b30e47c83701acfc06b5b"><div class="ttname"><a href="classhtgs_1_1_any_task_graph.html#aa22ef2947e9b30e47c83701acfc06b5b">htgs::AnyTaskGraph::numPipelines</a></div><div class="ttdeci">size_t numPipelines</div><div class="ttdoc">The number of pipelines from this graph. </div><div class="ttdef"><b>Definition:</b> AnyTaskGraph.hpp:334</div></div>
<div class="ttc" id="classhtgs_1_1_task_graph_html_a994884edaae94574d64ee9fd5d0fd7a4"><div class="ttname"><a href="classhtgs_1_1_task_graph.html#a994884edaae94574d64ee9fd5d0fd7a4">htgs::TaskGraph::pollData</a></div><div class="ttdeci">std::shared_ptr&lt; U &gt; pollData(long microTimeout)</div><div class="ttdoc">Polls for data from the output of the TaskGraph. </div><div class="ttdef"><b>Definition:</b> TaskGraph.hpp:546</div></div>
<div class="ttc" id="classhtgs_1_1_i_memory_allocator_html"><div class="ttname"><a href="classhtgs_1_1_i_memory_allocator.html">htgs::IMemoryAllocator</a></div><div class="ttdoc">Abstract class that describes how memory is allocated and freed. </div><div class="ttdef"><b>Definition:</b> IMemoryAllocator.hpp:63</div></div>
<div class="ttc" id="classhtgs_1_1_task_graph_html_a1b84e93e1a7221ffa0d4b35b55e817f9"><div class="ttname"><a href="classhtgs_1_1_task_graph.html#a1b84e93e1a7221ffa0d4b35b55e817f9">htgs::TaskGraph::addMemoryManagerEdge</a></div><div class="ttdeci">void addMemoryManagerEdge(std::string name, AnyITask *getMemoryTask, AnyITask *releaseMemoryTask, std::shared_ptr&lt; IMemoryAllocatorType &gt; allocator, size_t memoryPoolSize, MMType type)</div><div class="ttdoc">Adds a MemoryManager edge with the specified name to the TaskGraph. </div><div class="ttdef"><b>Definition:</b> TaskGraph.hpp:410</div></div>
<div class="ttc" id="classhtgs_1_1_task_graph_html_a85eb1e4c7ffd8732046a2ec0a37a91a6"><div class="ttname"><a href="classhtgs_1_1_task_graph.html#a85eb1e4c7ffd8732046a2ec0a37a91a6">htgs::TaskGraph::addCudaMemoryManagerEdge</a></div><div class="ttdeci">void addCudaMemoryManagerEdge(std::string name, AnyITask *memoryEdges, AnyITask *releaseMemoryEdges, std::shared_ptr&lt; IMemoryAllocatorType &gt; allocator, size_t memoryPoolSize, MMType type, CUcontext *contexts)</div><div class="ttdoc">Adds a CudaMemoryManager edge with the specified name to the TaskGraph. </div><div class="ttdef"><b>Definition:</b> TaskGraph.hpp:363</div></div>
<div class="ttc" id="classhtgs_1_1_task_graph_html_a73c039d4e4517f84d5b311871157584e"><div class="ttname"><a href="classhtgs_1_1_task_graph.html#a73c039d4e4517f84d5b311871157584e">htgs::TaskGraph::graphConsumerTaskManager</a></div><div class="ttdeci">AnyTaskScheduler * graphConsumerTaskManager</div><div class="ttdoc">The list of consumers accessing the TaskGraph&#39;s input connector. </div><div class="ttdef"><b>Definition:</b> TaskGraph.hpp:2029</div></div>
<div class="ttc" id="classhtgs_1_1_task_graph_html_aae29ebfc63282162af4e88eaf4c103c9"><div class="ttname"><a href="classhtgs_1_1_task_graph.html#aae29ebfc63282162af4e88eaf4c103c9">htgs::TaskGraph::TaskGraph</a></div><div class="ttdeci">TaskGraph()</div><div class="ttdoc">Constructs a TaskGraph. </div><div class="ttdef"><b>Definition:</b> TaskGraph.hpp:127</div></div>
<div class="ttc" id="classhtgs_1_1_task_graph_html"><div class="ttname"><a href="classhtgs_1_1_task_graph.html">htgs::TaskGraph&lt; T, U &gt;</a></div></div>
<div class="ttc" id="classhtgs_1_1_any_task_scheduler_html_a4c96ed2ca3802f3a85b35e3d1006a6bf"><div class="ttname"><a href="classhtgs_1_1_any_task_scheduler.html#a4c96ed2ca3802f3a85b35e3d1006a6bf">htgs::AnyTaskScheduler::getTaskFunction</a></div><div class="ttdeci">virtual AnyITask * getTaskFunction()=0</div><div class="ttdoc">Gets the ITask function associated with the TaskScheduler. </div></div>
<div class="ttc" id="classhtgs_1_1_task_graph_html_ac60eb3eb99b077b53ff3a68eb43a5c8e"><div class="ttname"><a href="classhtgs_1_1_task_graph.html#ac60eb3eb99b077b53ff3a68eb43a5c8e">htgs::TaskGraph::graphProducerTaskManager</a></div><div class="ttdeci">AnyTaskScheduler * graphProducerTaskManager</div><div class="ttdoc">The list of producers that are outputting data to the TaskGraph&#39;s output connector. </div><div class="ttdef"><b>Definition:</b> TaskGraph.hpp:2030</div></div>
<div class="ttc" id="classhtgs_1_1_task_graph_html_a7c35ca0b3e8f5e33f276479210e28320"><div class="ttname"><a href="classhtgs_1_1_task_graph.html#a7c35ca0b3e8f5e33f276479210e28320">htgs::TaskGraph::output</a></div><div class="ttdeci">std::shared_ptr&lt; Connector&lt; U &gt; &gt; output</div><div class="ttdoc">The output connector for the TaskGraph. </div><div class="ttdef"><b>Definition:</b> TaskGraph.hpp:2033</div></div>
<div class="ttc" id="classhtgs_1_1_task_graph_html_a15b4bb176539081a1a74428aaa337ed5"><div class="ttname"><a href="classhtgs_1_1_task_graph.html#a15b4bb176539081a1a74428aaa337ed5">htgs::TaskGraph::produceData</a></div><div class="ttdeci">void produceData(T *data)</div><div class="ttdoc">Produces data for the input of the TaskGraph. </div><div class="ttdef"><b>Definition:</b> TaskGraph.hpp:499</div></div>
<div class="ttc" id="classhtgs_1_1_task_graph_html_a538cbbc552965902fec6faac67766fbf"><div class="ttname"><a href="classhtgs_1_1_task_graph.html#a538cbbc552965902fec6faac67766fbf">htgs::TaskGraph::produceData</a></div><div class="ttdeci">void produceData(std::list&lt; std::shared_ptr&lt; T &gt;&gt; *dataList)</div><div class="ttdoc">Adds a list of data into the TaskGraph Must specify the TaskGraph input using addGraphInputConsumer()...</div><div class="ttdef"><b>Definition:</b> TaskGraph.hpp:522</div></div>
<div class="ttc" id="classhtgs_1_1_any_task_graph_html_adb3a8cf583ac0b03687c2e37f85b3616"><div class="ttname"><a href="classhtgs_1_1_any_task_graph.html#adb3a8cf583ac0b03687c2e37f85b3616">htgs::AnyTaskGraph::pipelineId</a></div><div class="ttdeci">size_t pipelineId</div><div class="ttdoc">The pipelineId for the task graph. </div><div class="ttdef"><b>Definition:</b> AnyTaskGraph.hpp:333</div></div>
<div class="ttc" id="classhtgs_1_1_any_task_scheduler_html"><div class="ttname"><a href="classhtgs_1_1_any_task_scheduler.html">htgs::AnyTaskScheduler</a></div><div class="ttdoc">The parent class for a Task that removes the template arguments. </div><div class="ttdef"><b>Definition:</b> AnyTaskScheduler.hpp:35</div></div>
<div class="ttc" id="classhtgs_1_1_any_task_scheduler_html_a2b72dda29cceb6699050458cdbf473cc"><div class="ttname"><a href="classhtgs_1_1_any_task_scheduler.html#a2b72dda29cceb6699050458cdbf473cc">htgs::AnyTaskScheduler::setOutputConnector</a></div><div class="ttdeci">virtual void setOutputConnector(std::shared_ptr&lt; AnyConnector &gt; connector)=0</div><div class="ttdoc">Sets the output BaseConnector. </div></div>
<div class="ttc" id="classhtgs_1_1_task_graph_html_aa222a7e8f5d3fe0a29bfb85e90203c34"><div class="ttname"><a href="classhtgs_1_1_task_graph.html#aa222a7e8f5d3fe0a29bfb85e90203c34">htgs::TaskGraph::consumeData</a></div><div class="ttdeci">std::shared_ptr&lt; U &gt; consumeData()</div><div class="ttdoc">Consumes data from the output of a TaskGraph. </div><div class="ttdef"><b>Definition:</b> TaskGraph.hpp:537</div></div>
</div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_e66be865834cb5c8612ced50101ecfbe.html">htgs</a></li><li class="navelem"><a class="el" href="dir_cba3643586339776702906f470e9e126.html">api</a></li><li class="navelem"><a class="el" href="_task_graph_8hpp.html">TaskGraph.hpp</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.7 </li>
  </ul>
</div>
</body>
</html>
