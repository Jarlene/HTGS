<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>HTGS: htgs::ICudaTask&lt; T, U &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="image-styles.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="HTGS-Logo-color-main.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HTGS
   &#160;<span id="projectnumber">v2.0</span>
   </div>
   <div id="projectbrief">The Hybrid Task Graph Scheduler</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classhtgs_1_1_i_cuda_task.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classhtgs_1_1_i_cuda_task-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">htgs::ICudaTask&lt; T, U &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>An <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> is used to attach a task to an NVIDIA Cuda GPU.  
 <a href="classhtgs_1_1_i_cuda_task.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_i_cuda_task_8hpp_source.html">htgs/api/ICudaTask.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for htgs::ICudaTask&lt; T, U &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classhtgs_1_1_i_cuda_task__inherit__graph.png" border="0" usemap="#htgs_1_1_i_cuda_task_3_01_t_00_01_u_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="htgs_1_1_i_cuda_task_3_01_t_00_01_u_01_4_inherit__map" id="htgs_1_1_i_cuda_task_3_01_t_00_01_u_01_4_inherit__map">
<area shape="rect" id="node2" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. " alt="" coords="19,395,166,619"/>
<area shape="rect" id="node3" href="classhtgs_1_1_any_i_task.html" title="Implements the parent ITask, which removes the template arguments of an ITask. " alt="" coords="5,5,180,347"/>
</map>
</div>
<div class="dynheader">
Collaboration diagram for htgs::ICudaTask&lt; T, U &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classhtgs_1_1_i_cuda_task__coll__graph.png" border="0" usemap="#htgs_1_1_i_cuda_task_3_01_t_00_01_u_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="htgs_1_1_i_cuda_task_3_01_t_00_01_u_01_4_coll__map" id="htgs_1_1_i_cuda_task_3_01_t_00_01_u_01_4_coll__map">
<area shape="rect" id="node2" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. " alt="" coords="309,1353,455,1577"/>
<area shape="rect" id="node3" href="classhtgs_1_1_any_i_task.html" title="Implements the parent ITask, which removes the template arguments of an ITask. " alt="" coords="304,977,460,1304"/>
<area shape="rect" id="node4" href="classhtgs_1_1_task_graph_communicator.html" title="Implements the task graph communicator where a task&#39;s address and name are mapped to their input conn..." alt="" coords="267,632,497,915"/>
<area shape="rect" id="node5" href="classhtgs_1_1_blocking_queue.html" title="{htgs::BlockingQueue\l\&lt; std::shared_ptr\&lt; htgs\l::DataPacket \&gt; \&gt;\n|&#45; queueSize\l&#45; mutex\l&#45; condition\l|+ BlockingQueue()\l+ BlockingQueue()\l+ ~BlockingQueue()\l+ remainingCapacity()\l+ isEmpty()\l+ size()\l+ remove()\l+ Enqueue()\l+ Dequeue()\l+ poll()\l}" alt="" coords="17,301,176,569"/>
<area shape="rect" id="node7" title="STL class. " alt="" coords="254,154,334,231"/>
<area shape="rect" id="node8" title="STL class. " alt="" coords="231,5,357,97"/>
<area shape="rect" id="node10" title="STL class. " alt="" coords="524,397,608,474"/>
<area shape="rect" id="node11" title="STL class. " alt="" coords="632,389,769,481"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac289e6e337e7ad1117d6b488789a7eb7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#ac289e6e337e7ad1117d6b488789a7eb7">ICudaTask</a> (CUcontext *<a class="el" href="classhtgs_1_1_i_cuda_task.html#ab5d204cf29330a6ebeb9b52f92a246b1">contexts</a>, int *<a class="el" href="classhtgs_1_1_i_cuda_task.html#ac8cdec43b08c6b3f92d2f77c2f76d40b">cudaIds</a>, size_t <a class="el" href="classhtgs_1_1_i_cuda_task.html#a4f51cb015f18fb3467c1e9fb3cc68b71">numGpus</a>)</td></tr>
<tr class="memdesc:ac289e6e337e7ad1117d6b488789a7eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a>.  <a href="#ac289e6e337e7ad1117d6b488789a7eb7">More...</a><br /></td></tr>
<tr class="separator:ac289e6e337e7ad1117d6b488789a7eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e48c0cb9c2f52b8539d80494a7618f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e48c0cb9c2f52b8539d80494a7618f9"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#a8e48c0cb9c2f52b8539d80494a7618f9">initializeCudaGPU</a> ()</td></tr>
<tr class="memdesc:a8e48c0cb9c2f52b8539d80494a7618f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function that is called when the <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> has been initialized and is bound to a CUDA GPU. <br /></td></tr>
<tr class="separator:a8e48c0cb9c2f52b8539d80494a7618f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d304db53e1d4ce2572e309bcf987c3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#af5d304db53e1d4ce2572e309bcf987c3">executeTask</a> (std::shared_ptr&lt; T &gt; data)=0</td></tr>
<tr class="memdesc:af5d304db53e1d4ce2572e309bcf987c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> on some data.  <a href="#af5d304db53e1d4ce2572e309bcf987c3">More...</a><br /></td></tr>
<tr class="separator:af5d304db53e1d4ce2572e309bcf987c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f66aa5e0911b851e796d6f1a7f2808"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88f66aa5e0911b851e796d6f1a7f2808"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#a88f66aa5e0911b851e796d6f1a7f2808">shutdownCuda</a> ()</td></tr>
<tr class="memdesc:a88f66aa5e0911b851e796d6f1a7f2808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function that is called when the <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> is shutting down. <br /></td></tr>
<tr class="separator:a88f66aa5e0911b851e796d6f1a7f2808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be2af6f0261358da1761fb0c0956175"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#a8be2af6f0261358da1761fb0c0956175">getName</a> () override</td></tr>
<tr class="memdesc:a8be2af6f0261358da1761fb0c0956175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function that gets the name of this <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a>.  <a href="#a8be2af6f0261358da1761fb0c0956175">More...</a><br /></td></tr>
<tr class="separator:a8be2af6f0261358da1761fb0c0956175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f7c46ae0d2b0f73dc2b051ca43b2ec"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#aa3f7c46ae0d2b0f73dc2b051ca43b2ec">getDotFillColor</a> () override</td></tr>
<tr class="memdesc:aa3f7c46ae0d2b0f73dc2b051ca43b2ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the color for filling the shape for graphviz dot.  <a href="#aa3f7c46ae0d2b0f73dc2b051ca43b2ec">More...</a><br /></td></tr>
<tr class="separator:aa3f7c46ae0d2b0f73dc2b051ca43b2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23de96615df6b88e3465b7ca98cc9a8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt; T, U &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#aa23de96615df6b88e3465b7ca98cc9a8">copy</a> ()=0</td></tr>
<tr class="memdesc:aa23de96615df6b88e3465b7ca98cc9a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pure virtual function that copies this <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a>.  <a href="#aa23de96615df6b88e3465b7ca98cc9a8">More...</a><br /></td></tr>
<tr class="separator:aa23de96615df6b88e3465b7ca98cc9a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a3b081acd7f20de7a2759c7120db04"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17a3b081acd7f20de7a2759c7120db04"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#a17a3b081acd7f20de7a2759c7120db04">debug</a> () override</td></tr>
<tr class="memdesc:a17a3b081acd7f20de7a2759c7120db04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function that can be used to provide debug information. <br /></td></tr>
<tr class="separator:a17a3b081acd7f20de7a2759c7120db04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a736f5bb2a2961d7aa6b6421e9eb70"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#af8a736f5bb2a2961d7aa6b6421e9eb70">getCudaId</a> ()</td></tr>
<tr class="memdesc:af8a736f5bb2a2961d7aa6b6421e9eb70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the Cuda Id for this cudaTask.  <a href="#af8a736f5bb2a2961d7aa6b6421e9eb70">More...</a><br /></td></tr>
<tr class="separator:af8a736f5bb2a2961d7aa6b6421e9eb70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438e9f9befc1db05c3545a05125c9f84"><td class="memItemLeft" align="right" valign="top">CUcontext&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#a438e9f9befc1db05c3545a05125c9f84">getTaskCudaContext</a> ()</td></tr>
<tr class="memdesc:a438e9f9befc1db05c3545a05125c9f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the CudaContext associated with this task.  <a href="#a438e9f9befc1db05c3545a05125c9f84">More...</a><br /></td></tr>
<tr class="separator:a438e9f9befc1db05c3545a05125c9f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab110c2bbb2e3ecc72df1ea25e4be02f3"><td class="memItemLeft" align="right" valign="top">CUcontext&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#ab110c2bbb2e3ecc72df1ea25e4be02f3">getGPUIdContext</a> (int index)</td></tr>
<tr class="memdesc:ab110c2bbb2e3ecc72df1ea25e4be02f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the cuda Context for the given cudaId.  <a href="#ab110c2bbb2e3ecc72df1ea25e4be02f3">More...</a><br /></td></tr>
<tr class="separator:ab110c2bbb2e3ecc72df1ea25e4be02f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84c6764a48c3398b293a978fb61a1c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#aa84c6764a48c3398b293a978fb61a1c4">requiresCopy</a> (size_t <a class="el" href="classhtgs_1_1_any_i_task.html#a08622ac16b7f3273702e1f665db9567a">pipelineId</a>)</td></tr>
<tr class="memdesc:aa84c6764a48c3398b293a978fb61a1c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the requested pipelineId requires GPU-to-GPU copy.  <a href="#aa84c6764a48c3398b293a978fb61a1c4">More...</a><br /></td></tr>
<tr class="separator:aa84c6764a48c3398b293a978fb61a1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed21dd37fe3fcaabcd5e69604f93c8a"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:a0ed21dd37fe3fcaabcd5e69604f93c8a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#a0ed21dd37fe3fcaabcd5e69604f93c8a">requiresCopy</a> (std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_memory_data.html">MemoryData</a>&lt; V &gt;&gt; data)</td></tr>
<tr class="memdesc:a0ed21dd37fe3fcaabcd5e69604f93c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the requested pipelineId requires GPU-to-GPU copy.  <a href="#a0ed21dd37fe3fcaabcd5e69604f93c8a">More...</a><br /></td></tr>
<tr class="separator:a0ed21dd37fe3fcaabcd5e69604f93c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2766c0114e43c0a84ed27a204ec51212"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#a2766c0114e43c0a84ed27a204ec51212">hasPeerToPeerCopy</a> (size_t <a class="el" href="classhtgs_1_1_any_i_task.html#a08622ac16b7f3273702e1f665db9567a">pipelineId</a>)</td></tr>
<tr class="memdesc:a2766c0114e43c0a84ed27a204ec51212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the requested pipelineId allows peer to peer GPU copy.  <a href="#a2766c0114e43c0a84ed27a204ec51212">More...</a><br /></td></tr>
<tr class="separator:a2766c0114e43c0a84ed27a204ec51212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4248e1d7d15fed78692de1f09d09e7"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:a4a4248e1d7d15fed78692de1f09d09e7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#a4a4248e1d7d15fed78692de1f09d09e7">autoCopy</a> (V destination, std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_memory_data.html">MemoryData</a>&lt; V &gt;&gt; data, long numElems)</td></tr>
<tr class="memdesc:a4a4248e1d7d15fed78692de1f09d09e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will automatically copy from one GPU to another (if it is required).  <a href="#a4a4248e1d7d15fed78692de1f09d09e7">More...</a><br /></td></tr>
<tr class="separator:a4a4248e1d7d15fed78692de1f09d09e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9139d923f48e4084b92be0db2b357402"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#a9139d923f48e4084b92be0db2b357402">initialize</a> () overridefinal</td></tr>
<tr class="memdesc:a9139d923f48e4084b92be0db2b357402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the CudaTask to be bound to a particular GPU.  <a href="#a9139d923f48e4084b92be0db2b357402">More...</a><br /></td></tr>
<tr class="separator:a9139d923f48e4084b92be0db2b357402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab851e15d02a2760ebb75da95011cc5bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#ab851e15d02a2760ebb75da95011cc5bc">shutdown</a> () overridefinal</td></tr>
<tr class="memdesc:ab851e15d02a2760ebb75da95011cc5bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shutsdown the <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a>.  <a href="#ab851e15d02a2760ebb75da95011cc5bc">More...</a><br /></td></tr>
<tr class="separator:ab851e15d02a2760ebb75da95011cc5bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0307be1be01945d299a0abdd3879cf2e"><td class="memItemLeft" align="right" valign="top">CUcontext *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#a0307be1be01945d299a0abdd3879cf2e">getContexts</a> ()</td></tr>
<tr class="memdesc:a0307be1be01945d299a0abdd3879cf2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the cudaContexts specified during <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> construction.  <a href="#a0307be1be01945d299a0abdd3879cf2e">More...</a><br /></td></tr>
<tr class="separator:a0307be1be01945d299a0abdd3879cf2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ccc67a7d8cd8ed89a5967bc1508d96c"><td class="memItemLeft" align="right" valign="top">const CUstream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#a6ccc67a7d8cd8ed89a5967bc1508d96c">getStream</a> () const </td></tr>
<tr class="memdesc:a6ccc67a7d8cd8ed89a5967bc1508d96c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the CUDA stream for this CUDA task.  <a href="#a6ccc67a7d8cd8ed89a5967bc1508d96c">More...</a><br /></td></tr>
<tr class="separator:a6ccc67a7d8cd8ed89a5967bc1508d96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ab6be7db24d03f6b720619e2a0a28e"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#ac2ab6be7db24d03f6b720619e2a0a28e">getCudaIds</a> ()</td></tr>
<tr class="memdesc:ac2ab6be7db24d03f6b720619e2a0a28e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the cudaIds specified during <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> construction.  <a href="#ac2ab6be7db24d03f6b720619e2a0a28e">More...</a><br /></td></tr>
<tr class="separator:ac2ab6be7db24d03f6b720619e2a0a28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d65c58e3cb8bd9385576725791a5bad"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#a1d65c58e3cb8bd9385576725791a5bad">getNumGPUs</a> ()</td></tr>
<tr class="memdesc:a1d65c58e3cb8bd9385576725791a5bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of GPUs specified during <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> construction.  <a href="#a1d65c58e3cb8bd9385576725791a5bad">More...</a><br /></td></tr>
<tr class="separator:a1d65c58e3cb8bd9385576725791a5bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa544d0fc6b744646a2e195a0a0383915"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#aa544d0fc6b744646a2e195a0a0383915">syncStream</a> ()</td></tr>
<tr class="memdesc:aa544d0fc6b744646a2e195a0a0383915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronizes the Cuda stream associated with this task.  <a href="#aa544d0fc6b744646a2e195a0a0383915">More...</a><br /></td></tr>
<tr class="separator:aa544d0fc6b744646a2e195a0a0383915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhtgs_1_1_i_task"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhtgs_1_1_i_task')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhtgs_1_1_i_task.html">htgs::ITask&lt; T, U &gt;</a></td></tr>
<tr class="memitem:ac23fa74bf05d6a86000422d989ccc5d1 inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac23fa74bf05d6a86000422d989ccc5d1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#ac23fa74bf05d6a86000422d989ccc5d1">ITask</a> ()</td></tr>
<tr class="memdesc:ac23fa74bf05d6a86000422d989ccc5d1 inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> with number of threads equal to 1. <br /></td></tr>
<tr class="separator:ac23fa74bf05d6a86000422d989ccc5d1 inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02582007e35e26b6487296102491ab8a inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#a02582007e35e26b6487296102491ab8a">ITask</a> (size_t <a class="el" href="classhtgs_1_1_any_i_task.html#a2290a388b71c586b9344eb75bd550f85">numThreads</a>)</td></tr>
<tr class="memdesc:a02582007e35e26b6487296102491ab8a inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> with a specified number of threads.  <a href="#a02582007e35e26b6487296102491ab8a">More...</a><br /></td></tr>
<tr class="separator:a02582007e35e26b6487296102491ab8a inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17481bd9a21d7e50abe2383e669eaa2 inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#aa17481bd9a21d7e50abe2383e669eaa2">ITask</a> (size_t <a class="el" href="classhtgs_1_1_any_i_task.html#a2290a388b71c586b9344eb75bd550f85">numThreads</a>, bool <a class="el" href="classhtgs_1_1_any_i_task.html#a46fe4b199fee56ce8669419562623119">isStartTask</a>, bool <a class="el" href="classhtgs_1_1_any_i_task.html#a48b25f5302f442df21bc1a1056922096">poll</a>, size_t <a class="el" href="classhtgs_1_1_any_i_task.html#afc82807100ea1a4a87f03a5cb99c3a5b">microTimeoutTime</a>)</td></tr>
<tr class="memdesc:aa17481bd9a21d7e50abe2383e669eaa2 inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> with a specified number of threads as well as additional scheduling options.  <a href="#aa17481bd9a21d7e50abe2383e669eaa2">More...</a><br /></td></tr>
<tr class="separator:aa17481bd9a21d7e50abe2383e669eaa2 inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea8be928ea7e5a1c7dab9dd889cb268 inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#a8ea8be928ea7e5a1c7dab9dd889cb268">canTerminate</a> (std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_any_connector.html">AnyConnector</a> &gt; inputConnector) override</td></tr>
<tr class="memdesc:a8ea8be928ea7e5a1c7dab9dd889cb268 inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function that is called when an <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> is checking if it can be terminated.  <a href="#a8ea8be928ea7e5a1c7dab9dd889cb268">More...</a><br /></td></tr>
<tr class="separator:a8ea8be928ea7e5a1c7dab9dd889cb268 inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0e7491b70a486b2317d7b1cf61757c inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#a4b0e7491b70a486b2317d7b1cf61757c">getDotLabelName</a> () override</td></tr>
<tr class="memdesc:a4b0e7491b70a486b2317d7b1cf61757c inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function to get the label name used for dot graph viz.  <a href="#a4b0e7491b70a486b2317d7b1cf61757c">More...</a><br /></td></tr>
<tr class="separator:a4b0e7491b70a486b2317d7b1cf61757c inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af344dfcd8cfa5bab869f09728403e323 inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#af344dfcd8cfa5bab869f09728403e323">getDotShapeColor</a> () override</td></tr>
<tr class="memdesc:af344dfcd8cfa5bab869f09728403e323 inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the color of the shape for graphviz dot.  <a href="#af344dfcd8cfa5bab869f09728403e323">More...</a><br /></td></tr>
<tr class="separator:af344dfcd8cfa5bab869f09728403e323 inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad849024295a08e3ad1d16eccebe62d0d inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#ad849024295a08e3ad1d16eccebe62d0d">getDotShape</a> () override</td></tr>
<tr class="memdesc:ad849024295a08e3ad1d16eccebe62d0d inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the shape for graphviz dot.  <a href="#ad849024295a08e3ad1d16eccebe62d0d">More...</a><br /></td></tr>
<tr class="separator:ad849024295a08e3ad1d16eccebe62d0d inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf500f783e58f78909ef01f4cc2367d9 inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#abf500f783e58f78909ef01f4cc2367d9">printProfile</a> () override</td></tr>
<tr class="memdesc:abf500f783e58f78909ef01f4cc2367d9 inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the profile data to std::out.  <a href="#abf500f783e58f78909ef01f4cc2367d9">More...</a><br /></td></tr>
<tr class="separator:abf500f783e58f78909ef01f4cc2367d9 inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c8d5d1bf48d2f00d1109072244be08 inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#a46c8d5d1bf48d2f00d1109072244be08">getNumGraphsSpawned</a> ()</td></tr>
<tr class="memdesc:a46c8d5d1bf48d2f00d1109072244be08 inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of graphs spawned by this <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a>.  <a href="#a46c8d5d1bf48d2f00d1109072244be08">More...</a><br /></td></tr>
<tr class="separator:a46c8d5d1bf48d2f00d1109072244be08 inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5eb7fcf9b6c14e3fe5c6b23b7c0cee0 inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt; T, U &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#af5eb7fcf9b6c14e3fe5c6b23b7c0cee0">copyITask</a> (bool deep) override</td></tr>
<tr class="memdesc:af5eb7fcf9b6c14e3fe5c6b23b7c0cee0 inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> (including a copy of all memory edges)  <a href="#af5eb7fcf9b6c14e3fe5c6b23b7c0cee0">More...</a><br /></td></tr>
<tr class="separator:af5eb7fcf9b6c14e3fe5c6b23b7c0cee0 inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64952b7c68e97d84c97c7b15a0b032aa inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#a64952b7c68e97d84c97c7b15a0b032aa">addResult</a> (std::shared_ptr&lt; U &gt; result)</td></tr>
<tr class="memdesc:a64952b7c68e97d84c97c7b15a0b032aa inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds results to the output list to be sent to the next connected <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> in a TaskGraph.  <a href="#a64952b7c68e97d84c97c7b15a0b032aa">More...</a><br /></td></tr>
<tr class="separator:a64952b7c68e97d84c97c7b15a0b032aa inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab8481dc44985387e35477324e263f7 inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#adab8481dc44985387e35477324e263f7">addResult</a> (U *result)</td></tr>
<tr class="memdesc:adab8481dc44985387e35477324e263f7 inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds results to the output list to be sent to the next connected <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> in a TaskGraph.  <a href="#adab8481dc44985387e35477324e263f7">More...</a><br /></td></tr>
<tr class="separator:adab8481dc44985387e35477324e263f7 inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea247c51fb5da271a55bd948f728a6a inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#a4ea247c51fb5da271a55bd948f728a6a">initialize</a> (size_t <a class="el" href="classhtgs_1_1_any_i_task.html#a08622ac16b7f3273702e1f665db9567a">pipelineId</a>, size_t numPipeline, <a class="el" href="classhtgs_1_1_task_manager.html">TaskManager</a>&lt; T, U &gt; *<a class="el" href="classhtgs_1_1_i_task.html#ac8e5df427a5bf216c86d0df3263e2888">ownerTask</a>)</td></tr>
<tr class="memdesc:a4ea247c51fb5da271a55bd948f728a6a inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that is called when an <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> is being initialized by it's owner thread.  <a href="#a4ea247c51fb5da271a55bd948f728a6a">More...</a><br /></td></tr>
<tr class="separator:a4ea247c51fb5da271a55bd948f728a6a inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5b471973ab49fc6a9cfcfbe4dacaa4 inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#a5a5b471973ab49fc6a9cfcfbe4dacaa4">inTypeName</a> () overridefinal</td></tr>
<tr class="memdesc:a5a5b471973ab49fc6a9cfcfbe4dacaa4 inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the demangled input type name of the connector.  <a href="#a5a5b471973ab49fc6a9cfcfbe4dacaa4">More...</a><br /></td></tr>
<tr class="separator:a5a5b471973ab49fc6a9cfcfbe4dacaa4 inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453698a97f2c4318a8331915f9dc94c1 inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#a453698a97f2c4318a8331915f9dc94c1">outTypeName</a> () overridefinal</td></tr>
<tr class="memdesc:a453698a97f2c4318a8331915f9dc94c1 inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the demangled output type name of the connector.  <a href="#a453698a97f2c4318a8331915f9dc94c1">More...</a><br /></td></tr>
<tr class="separator:a453698a97f2c4318a8331915f9dc94c1 inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29cf1039ab3b9d9426b67b226a42dcc inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#ae29cf1039ab3b9d9426b67b226a42dcc">getAddress</a> () overridefinal</td></tr>
<tr class="memdesc:ae29cf1039ab3b9d9426b67b226a42dcc inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the address from the owner task, which is the address of the task graph.  <a href="#ae29cf1039ab3b9d9426b67b226a42dcc">More...</a><br /></td></tr>
<tr class="separator:ae29cf1039ab3b9d9426b67b226a42dcc inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f3d9395e30b8a9a58ce012179470c1 inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#ae5f3d9395e30b8a9a58ce012179470c1">setTaskManager</a> (<a class="el" href="classhtgs_1_1_task_manager.html">TaskManager</a>&lt; T, U &gt; *<a class="el" href="classhtgs_1_1_i_task.html#ac8e5df427a5bf216c86d0df3263e2888">ownerTask</a>)</td></tr>
<tr class="memdesc:ae5f3d9395e30b8a9a58ce012179470c1 inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the owner task manager for this <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a>.  <a href="#ae5f3d9395e30b8a9a58ce012179470c1">More...</a><br /></td></tr>
<tr class="separator:ae5f3d9395e30b8a9a58ce012179470c1 inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c8a37191adfd7750f686f27ed5a1b0c inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhtgs_1_1_task_manager.html">TaskManager</a>&lt; T, U &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#a8c8a37191adfd7750f686f27ed5a1b0c">getOwnerTaskManager</a> ()</td></tr>
<tr class="memdesc:a8c8a37191adfd7750f686f27ed5a1b0c inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the owner task manager for this <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a>.  <a href="#a8c8a37191adfd7750f686f27ed5a1b0c">More...</a><br /></td></tr>
<tr class="separator:a8c8a37191adfd7750f686f27ed5a1b0c inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a081f373013ed563234b296b99047ba inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#a8a081f373013ed563234b296b99047ba">gatherProfileData</a> (std::map&lt; <a class="el" href="classhtgs_1_1_any_task_manager.html">AnyTaskManager</a> *, <a class="el" href="classhtgs_1_1_task_manager_profile.html">TaskManagerProfile</a> * &gt; *taskManagerProfiles)</td></tr>
<tr class="memdesc:a8a081f373013ed563234b296b99047ba inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers profile data.  <a href="#a8a081f373013ed563234b296b99047ba">More...</a><br /></td></tr>
<tr class="separator:a8a081f373013ed563234b296b99047ba inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhtgs_1_1_any_i_task"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhtgs_1_1_any_i_task')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhtgs_1_1_any_i_task.html">htgs::AnyITask</a></td></tr>
<tr class="memitem:af2a727eb509772d1f86a91c251a75a32 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2a727eb509772d1f86a91c251a75a32"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_i_task.html#af2a727eb509772d1f86a91c251a75a32">AnyITask</a> ()</td></tr>
<tr class="memdesc:af2a727eb509772d1f86a91c251a75a32 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> with number of threads equal to 1. <br /></td></tr>
<tr class="separator:af2a727eb509772d1f86a91c251a75a32 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921ef939941cece4f8f9fad56f5e72a6 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_i_task.html#a921ef939941cece4f8f9fad56f5e72a6">AnyITask</a> (size_t <a class="el" href="classhtgs_1_1_any_i_task.html#a2290a388b71c586b9344eb75bd550f85">numThreads</a>)</td></tr>
<tr class="memdesc:a921ef939941cece4f8f9fad56f5e72a6 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> with a specified number of threads.  <a href="#a921ef939941cece4f8f9fad56f5e72a6">More...</a><br /></td></tr>
<tr class="separator:a921ef939941cece4f8f9fad56f5e72a6 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba2ee2bcb1a71594e83d2f81a316262 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_i_task.html#a3ba2ee2bcb1a71594e83d2f81a316262">AnyITask</a> (size_t <a class="el" href="classhtgs_1_1_any_i_task.html#a2290a388b71c586b9344eb75bd550f85">numThreads</a>, bool <a class="el" href="classhtgs_1_1_any_i_task.html#a46fe4b199fee56ce8669419562623119">isStartTask</a>, bool <a class="el" href="classhtgs_1_1_any_i_task.html#a48b25f5302f442df21bc1a1056922096">poll</a>, size_t <a class="el" href="classhtgs_1_1_any_i_task.html#afc82807100ea1a4a87f03a5cb99c3a5b">microTimeoutTime</a>)</td></tr>
<tr class="memdesc:a3ba2ee2bcb1a71594e83d2f81a316262 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> with a specified number of threads as well as additional scheduling options.  <a href="#a3ba2ee2bcb1a71594e83d2f81a316262">More...</a><br /></td></tr>
<tr class="separator:a3ba2ee2bcb1a71594e83d2f81a316262 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08fc31b54062fb19c2398f9d0b937107 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08fc31b54062fb19c2398f9d0b937107"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_i_task.html#a08fc31b54062fb19c2398f9d0b937107">~AnyITask</a> ()</td></tr>
<tr class="memdesc:a08fc31b54062fb19c2398f9d0b937107 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a08fc31b54062fb19c2398f9d0b937107 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a4c99907a6b444e2c8a151e3055022 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_i_task.html#a89a4c99907a6b444e2c8a151e3055022">genDot</a> (int flags, std::string dotId, std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_any_connector.html">htgs::AnyConnector</a> &gt; input, std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_any_connector.html">htgs::AnyConnector</a> &gt; output)</td></tr>
<tr class="memdesc:a89a4c99907a6b444e2c8a151e3055022 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function that generates the input/output and per-task dot notation.  <a href="#a89a4c99907a6b444e2c8a151e3055022">More...</a><br /></td></tr>
<tr class="separator:a89a4c99907a6b444e2c8a151e3055022 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9ea546ef2f5ef08d7e579d34d0dc46 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_i_task.html#a6c9ea546ef2f5ef08d7e579d34d0dc46">debugDotNode</a> ()</td></tr>
<tr class="memdesc:a6c9ea546ef2f5ef08d7e579d34d0dc46 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides debug output for a node in the dot graph.  <a href="#a6c9ea546ef2f5ef08d7e579d34d0dc46">More...</a><br /></td></tr>
<tr class="separator:a6c9ea546ef2f5ef08d7e579d34d0dc46 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38960397af48fada4690c7ce35bde1e2 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_i_task.html#a38960397af48fada4690c7ce35bde1e2">profile</a> ()</td></tr>
<tr class="memdesc:a38960397af48fada4690c7ce35bde1e2 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function that is called to provide profile output for the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a>.  <a href="#a38960397af48fada4690c7ce35bde1e2">More...</a><br /></td></tr>
<tr class="separator:a38960397af48fada4690c7ce35bde1e2 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78302a59c8fbfba98b5254f81dd8557 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_i_task.html#af78302a59c8fbfba98b5254f81dd8557">genDot</a> (int flags, std::string dotId)</td></tr>
<tr class="memdesc:af78302a59c8fbfba98b5254f81dd8557 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function that adds additional dot attributes to this node.  <a href="#af78302a59c8fbfba98b5254f81dd8557">More...</a><br /></td></tr>
<tr class="separator:af78302a59c8fbfba98b5254f81dd8557 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9f9ee3180ecb30798850eb8162d4ff inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_i_task.html#a6b9f9ee3180ecb30798850eb8162d4ff">initialize</a> (size_t <a class="el" href="classhtgs_1_1_any_i_task.html#a08622ac16b7f3273702e1f665db9567a">pipelineId</a>, size_t numPipeline)</td></tr>
<tr class="memdesc:a6b9f9ee3180ecb30798850eb8162d4ff inherit pub_methods_classhtgs_1_1_any_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function that is called when an <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> is being initialized by it's owner thread.  <a href="#a6b9f9ee3180ecb30798850eb8162d4ff">More...</a><br /></td></tr>
<tr class="separator:a6b9f9ee3180ecb30798850eb8162d4ff inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0689f15595e3e717cd538f7d76b0d43b inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_i_task.html#a0689f15595e3e717cd538f7d76b0d43b">setPipelineId</a> (size_t <a class="el" href="classhtgs_1_1_any_i_task.html#a08622ac16b7f3273702e1f665db9567a">pipelineId</a>)</td></tr>
<tr class="memdesc:a0689f15595e3e717cd538f7d76b0d43b inherit pub_methods_classhtgs_1_1_any_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the pipeline Id for this <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a>.  <a href="#a0689f15595e3e717cd538f7d76b0d43b">More...</a><br /></td></tr>
<tr class="separator:a0689f15595e3e717cd538f7d76b0d43b inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eee31ff0a32d0ec08648edcb26ec096 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_i_task.html#a9eee31ff0a32d0ec08648edcb26ec096">getPipelineId</a> ()</td></tr>
<tr class="memdesc:a9eee31ff0a32d0ec08648edcb26ec096 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pipeline ID.  <a href="#a9eee31ff0a32d0ec08648edcb26ec096">More...</a><br /></td></tr>
<tr class="separator:a9eee31ff0a32d0ec08648edcb26ec096 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256f8715ea4a6128345fdf569effda1d inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_i_task.html#a256f8715ea4a6128345fdf569effda1d">setNumPipelines</a> (size_t <a class="el" href="classhtgs_1_1_any_i_task.html#aa11ba6af1d4527e6292d294854b1d390">numPipelines</a>)</td></tr>
<tr class="memdesc:a256f8715ea4a6128345fdf569effda1d inherit pub_methods_classhtgs_1_1_any_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of pipelines that this <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> belongs too.  <a href="#a256f8715ea4a6128345fdf569effda1d">More...</a><br /></td></tr>
<tr class="separator:a256f8715ea4a6128345fdf569effda1d inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa20eed280a1e07be28ef60f120e0c0be inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_i_task.html#aa20eed280a1e07be28ef60f120e0c0be">setTaskGraphCommunicator</a> (<a class="el" href="classhtgs_1_1_task_graph_communicator.html">TaskGraphCommunicator</a> *communicator)</td></tr>
<tr class="memdesc:aa20eed280a1e07be28ef60f120e0c0be inherit pub_methods_classhtgs_1_1_any_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the task graph communicator.  <a href="#aa20eed280a1e07be28ef60f120e0c0be">More...</a><br /></td></tr>
<tr class="separator:aa20eed280a1e07be28ef60f120e0c0be inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa693316e296982a4f31f8397586ebcc0 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhtgs_1_1_task_graph_communicator.html">TaskGraphCommunicator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_i_task.html#aa693316e296982a4f31f8397586ebcc0">getTaskGraphCommunicator</a> () const </td></tr>
<tr class="memdesc:aa693316e296982a4f31f8397586ebcc0 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the task graph communicator.  <a href="#aa693316e296982a4f31f8397586ebcc0">More...</a><br /></td></tr>
<tr class="separator:aa693316e296982a4f31f8397586ebcc0 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa897627d33f6525fe8c88ae6fe1f7827 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_i_task.html#aa897627d33f6525fe8c88ae6fe1f7827">getNumPipelines</a> () const </td></tr>
<tr class="memdesc:aa897627d33f6525fe8c88ae6fe1f7827 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of pipelines for the task's execution pipeline.  <a href="#aa897627d33f6525fe8c88ae6fe1f7827">More...</a><br /></td></tr>
<tr class="separator:aa897627d33f6525fe8c88ae6fe1f7827 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a98bd2bfb55ddffe8f0d01faa3354b inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_i_task.html#a35a98bd2bfb55ddffe8f0d01faa3354b">getNumThreads</a> () const </td></tr>
<tr class="memdesc:a35a98bd2bfb55ddffe8f0d01faa3354b inherit pub_methods_classhtgs_1_1_any_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of threads associated with this <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a>.  <a href="#a35a98bd2bfb55ddffe8f0d01faa3354b">More...</a><br /></td></tr>
<tr class="separator:a35a98bd2bfb55ddffe8f0d01faa3354b inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46fe4b199fee56ce8669419562623119 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_i_task.html#a46fe4b199fee56ce8669419562623119">isStartTask</a> () const </td></tr>
<tr class="memdesc:a46fe4b199fee56ce8669419562623119 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether this <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> is a starting task.  <a href="#a46fe4b199fee56ce8669419562623119">More...</a><br /></td></tr>
<tr class="separator:a46fe4b199fee56ce8669419562623119 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b0bf044576da33dfb3bfd4b9217abe inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_i_task.html#a92b0bf044576da33dfb3bfd4b9217abe">isPoll</a> () const </td></tr>
<tr class="memdesc:a92b0bf044576da33dfb3bfd4b9217abe inherit pub_methods_classhtgs_1_1_any_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether this <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> is polling for data or not.  <a href="#a92b0bf044576da33dfb3bfd4b9217abe">More...</a><br /></td></tr>
<tr class="separator:a92b0bf044576da33dfb3bfd4b9217abe inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e61cd4c77c1865db6f3a70822059eb5 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_i_task.html#a3e61cd4c77c1865db6f3a70822059eb5">getMicroTimeoutTime</a> () const </td></tr>
<tr class="memdesc:a3e61cd4c77c1865db6f3a70822059eb5 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the timeout time for polling.  <a href="#a3e61cd4c77c1865db6f3a70822059eb5">More...</a><br /></td></tr>
<tr class="separator:a3e61cd4c77c1865db6f3a70822059eb5 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8151861566f3566b2bfbeb4c61db8d5d inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_i_task.html#a8151861566f3566b2bfbeb4c61db8d5d">copyMemoryEdges</a> (<a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *iTaskCopy)</td></tr>
<tr class="memdesc:a8151861566f3566b2bfbeb4c61db8d5d inherit pub_methods_classhtgs_1_1_any_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the memory edges from this <a class="el" href="classhtgs_1_1_any_i_task.html" title="Implements the parent ITask, which removes the template arguments of an ITask. ">AnyITask</a> to another <a class="el" href="classhtgs_1_1_any_i_task.html" title="Implements the parent ITask, which removes the template arguments of an ITask. ">AnyITask</a>.  <a href="#a8151861566f3566b2bfbeb4c61db8d5d">More...</a><br /></td></tr>
<tr class="separator:a8151861566f3566b2bfbeb4c61db8d5d inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29719d6760e609023ffcb8e966ed3ab inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:af29719d6760e609023ffcb8e966ed3ab inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_types_8hpp.html#a3b26154a91264a0136c960befa0818e5">m_data_t</a>&lt; V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_i_task.html#af29719d6760e609023ffcb8e966ed3ab">getMemory</a> (std::string name, <a class="el" href="classhtgs_1_1_i_memory_release_rule.html">IMemoryReleaseRule</a> *releaseRule)</td></tr>
<tr class="memdesc:af29719d6760e609023ffcb8e966ed3ab inherit pub_methods_classhtgs_1_1_any_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves memory from a memory edge.  <a href="#af29719d6760e609023ffcb8e966ed3ab">More...</a><br /></td></tr>
<tr class="separator:af29719d6760e609023ffcb8e966ed3ab inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9b186c6fa6774524f5fcb5d339fb7e6 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:ad9b186c6fa6774524f5fcb5d339fb7e6 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_types_8hpp.html#a3b26154a91264a0136c960befa0818e5">m_data_t</a>&lt; V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_i_task.html#ad9b186c6fa6774524f5fcb5d339fb7e6">getDynamicMemory</a> (std::string name, <a class="el" href="classhtgs_1_1_i_memory_release_rule.html">IMemoryReleaseRule</a> *releaseRule, size_t numElems)</td></tr>
<tr class="memdesc:ad9b186c6fa6774524f5fcb5d339fb7e6 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves memory from a memory edge.  <a href="#ad9b186c6fa6774524f5fcb5d339fb7e6">More...</a><br /></td></tr>
<tr class="separator:ad9b186c6fa6774524f5fcb5d339fb7e6 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1695fa9a8bd1ff5599c1388f648fc9fa inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:a1695fa9a8bd1ff5599c1388f648fc9fa inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_i_task.html#a1695fa9a8bd1ff5599c1388f648fc9fa">releaseMemory</a> (<a class="el" href="_types_8hpp.html#a3b26154a91264a0136c960befa0818e5">m_data_t</a>&lt; V &gt; memory)</td></tr>
<tr class="memdesc:a1695fa9a8bd1ff5599c1388f648fc9fa inherit pub_methods_classhtgs_1_1_any_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases memory onto a memory edge, which is transferred by the graph communicator.  <a href="#a1695fa9a8bd1ff5599c1388f648fc9fa">More...</a><br /></td></tr>
<tr class="separator:a1695fa9a8bd1ff5599c1388f648fc9fa inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a2a3413aba1c422531a94a1177c7477 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_i_task.html#a7a2a3413aba1c422531a94a1177c7477">hasMemoryEdge</a> (std::string name)</td></tr>
<tr class="memdesc:a7a2a3413aba1c422531a94a1177c7477 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether this <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> contains a memory edge for a specified name.  <a href="#a7a2a3413aba1c422531a94a1177c7477">More...</a><br /></td></tr>
<tr class="separator:a7a2a3413aba1c422531a94a1177c7477 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b227fd650170a87eb3f15a7c291039 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_i_task.html#a07b227fd650170a87eb3f15a7c291039">attachMemoryEdge</a> (std::string name, std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_any_connector.html">AnyConnector</a> &gt; getMemoryConnector, std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_any_connector.html">AnyConnector</a> &gt; releaseMemoryConnector, <a class="el" href="_m_m_type_8hpp.html#a9cb5fbc12b3f2ecede03fd2ae6e3fa0b">MMType</a> type)</td></tr>
<tr class="memdesc:a07b227fd650170a87eb3f15a7c291039 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a memory edge to this <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> to get memory.  <a href="#a07b227fd650170a87eb3f15a7c291039">More...</a><br /></td></tr>
<tr class="separator:a07b227fd650170a87eb3f15a7c291039 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c2f4b6a35e07f87420e28af48d115a inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_i_task.html#a21c2f4b6a35e07f87420e28af48d115a">genDot</a> (int flags, std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_any_connector.html">AnyConnector</a> &gt; input, std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_any_connector.html">AnyConnector</a> &gt; output)</td></tr>
<tr class="memdesc:a21c2f4b6a35e07f87420e28af48d115a inherit pub_methods_classhtgs_1_1_any_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dot notation representation for this task.  <a href="#a21c2f4b6a35e07f87420e28af48d115a">More...</a><br /></td></tr>
<tr class="separator:a21c2f4b6a35e07f87420e28af48d115a inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab428a1870e69900ba20ffb8285ecc8f1 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_i_task.html#ab428a1870e69900ba20ffb8285ecc8f1">profileITask</a> ()</td></tr>
<tr class="memdesc:ab428a1870e69900ba20ffb8285ecc8f1 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides profile output for the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a>,.  <a href="#ab428a1870e69900ba20ffb8285ecc8f1">More...</a><br /></td></tr>
<tr class="separator:ab428a1870e69900ba20ffb8285ecc8f1 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950b031a669641923068673109f1a5d2 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_i_task.html#a950b031a669641923068673109f1a5d2">getDotId</a> ()</td></tr>
<tr class="memdesc:a950b031a669641923068673109f1a5d2 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the id used for dot nodes.  <a href="#a950b031a669641923068673109f1a5d2">More...</a><br /></td></tr>
<tr class="separator:a950b031a669641923068673109f1a5d2 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8a3558a1f0ca11acd02394de45ce8d inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_i_task.html#a4f8a3558a1f0ca11acd02394de45ce8d">getNameWithPipelineId</a> ()</td></tr>
<tr class="memdesc:a4f8a3558a1f0ca11acd02394de45ce8d inherit pub_methods_classhtgs_1_1_any_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name of the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> with it's pipeline ID.  <a href="#a4f8a3558a1f0ca11acd02394de45ce8d">More...</a><br /></td></tr>
<tr class="separator:a4f8a3558a1f0ca11acd02394de45ce8d inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95a54ad4c11cad54e072ec5c98a60e3 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; <a class="el" href="_types_8hpp.html#a2156f652394ebf22e0f38ce08fd9e50a">ConnectorMap</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_i_task.html#ae95a54ad4c11cad54e072ec5c98a60e3">getMemoryEdges</a> () const </td></tr>
<tr class="memdesc:ae95a54ad4c11cad54e072ec5c98a60e3 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the memory edges for the task.  <a href="#ae95a54ad4c11cad54e072ec5c98a60e3">More...</a><br /></td></tr>
<tr class="separator:ae95a54ad4c11cad54e072ec5c98a60e3 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182cb05b805dd9862364cffb4d9f4404 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; <a class="el" href="_types_8hpp.html#a2156f652394ebf22e0f38ce08fd9e50a">ConnectorMap</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_i_task.html#a182cb05b805dd9862364cffb4d9f4404">getReleaseMemoryEdges</a> () const </td></tr>
<tr class="memdesc:a182cb05b805dd9862364cffb4d9f4404 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the memory edges for releasing memory for the memory manager, used to shutdown the memory manager.  <a href="#a182cb05b805dd9862364cffb4d9f4404">More...</a><br /></td></tr>
<tr class="separator:a182cb05b805dd9862364cffb4d9f4404 inherit pub_methods_classhtgs_1_1_any_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a1e41aadbe037089aec99fd9805e80c39"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e41aadbe037089aec99fd9805e80c39"></a>
CUcontext&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#a1e41aadbe037089aec99fd9805e80c39">context</a></td></tr>
<tr class="memdesc:a1e41aadbe037089aec99fd9805e80c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CUDA GPU context for the <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> (set after initialize) <br /></td></tr>
<tr class="separator:a1e41aadbe037089aec99fd9805e80c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e11becef7b34a87934ea336978cf5af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e11becef7b34a87934ea336978cf5af"></a>
CUstream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#a0e11becef7b34a87934ea336978cf5af">stream</a></td></tr>
<tr class="memdesc:a0e11becef7b34a87934ea336978cf5af"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CUDA stream for the <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> (set after initialize) <br /></td></tr>
<tr class="separator:a0e11becef7b34a87934ea336978cf5af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d204cf29330a6ebeb9b52f92a246b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5d204cf29330a6ebeb9b52f92a246b1"></a>
CUcontext *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#ab5d204cf29330a6ebeb9b52f92a246b1">contexts</a></td></tr>
<tr class="memdesc:ab5d204cf29330a6ebeb9b52f92a246b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array of CUDA contexts (one per GPU) <br /></td></tr>
<tr class="separator:ab5d204cf29330a6ebeb9b52f92a246b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8cdec43b08c6b3f92d2f77c2f76d40b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8cdec43b08c6b3f92d2f77c2f76d40b"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#ac8cdec43b08c6b3f92d2f77c2f76d40b">cudaIds</a></td></tr>
<tr class="memdesc:ac8cdec43b08c6b3f92d2f77c2f76d40b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array of cuda Ids (one per GPU) <br /></td></tr>
<tr class="separator:ac8cdec43b08c6b3f92d2f77c2f76d40b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f51cb015f18fb3467c1e9fb3cc68b71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f51cb015f18fb3467c1e9fb3cc68b71"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#a4f51cb015f18fb3467c1e9fb3cc68b71">numGpus</a></td></tr>
<tr class="memdesc:a4f51cb015f18fb3467c1e9fb3cc68b71"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of GPUs. <br /></td></tr>
<tr class="separator:a4f51cb015f18fb3467c1e9fb3cc68b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857caf32854f8e04a528dbc7b0151c26"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a857caf32854f8e04a528dbc7b0151c26"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#a857caf32854f8e04a528dbc7b0151c26">cudaId</a></td></tr>
<tr class="memdesc:a857caf32854f8e04a528dbc7b0151c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CudaID for the <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> (set after initialize) <br /></td></tr>
<tr class="separator:a857caf32854f8e04a528dbc7b0151c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad487f6516fa09df975d99b2a7508a1d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad487f6516fa09df975d99b2a7508a1d3"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#ad487f6516fa09df975d99b2a7508a1d3">nonPeerDevIds</a></td></tr>
<tr class="memdesc:ad487f6516fa09df975d99b2a7508a1d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of CudaIds that do not have peer-to-peer access. <br /></td></tr>
<tr class="separator:ad487f6516fa09df975d99b2a7508a1d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52704937e46c5bf120069fa9bc3e88d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52704937e46c5bf120069fa9bc3e88d3"></a>
std::unordered_map&lt; int, CUcontext &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#a52704937e46c5bf120069fa9bc3e88d3">peerContexts</a></td></tr>
<tr class="memdesc:a52704937e46c5bf120069fa9bc3e88d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The mapping of CudaId to CUDA Context that has peer-to-peer. <br /></td></tr>
<tr class="separator:a52704937e46c5bf120069fa9bc3e88d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, class U&gt;<br />
class htgs::ICudaTask&lt; T, U &gt;</h3>

<p>An <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> is used to attach a task to an NVIDIA Cuda GPU. </p>
<p>The task that inherits from this class will automatically be attached to the GPU when launched by the TaskGraphRunTime from within a <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a>.</p>
<p>An <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> may be bound to one or more GPUs if the task is added into an <a class="el" href="classhtgs_1_1_execution_pipeline.html" title="The ExecutionPipeline class is used to duplicate task graphs, such that each duplicate executes concu...">ExecutionPipeline</a>. The number of CUContexts must match the number of pipelines specified for the <a class="el" href="classhtgs_1_1_execution_pipeline.html" title="The ExecutionPipeline class is used to duplicate task graphs, such that each duplicate executes concu...">ExecutionPipeline</a>.</p>
<p>Mechanisms to handle automatic data motion for GPU-to-GPU memories is provided to simplify peer to peer device memory copies. In order to use peer to peer copy, both GPUs must reside on the same I/O Hub (IOH) and be the same GPU model.</p>
<p>It may be necessary to copy data that resides on two different GPUs. This can be achieved by using the <a class="el" href="classhtgs_1_1_i_cuda_task.html#a4a4248e1d7d15fed78692de1f09d09e7" title="Will automatically copy from one GPU to another (if it is required). ">autoCopy(V destination, std::shared_ptr&lt;MemoryData&lt;V&gt;&gt; data, long numElems)</a> function. This occurs when there are ghost regions between data domains. If peer to peer copying is allowed between the multiple GPUs, then the autocopy function is not needed. See below for an example of using autocopy.</p>
<p>At this time it is necessary for the <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> to copy data from CPU memories to GPU memories.</p>
<p>Functions are available for getting the CUDA stream, context, pipeline ID, and number of pipelines.</p>
<dl class="section note"><dt>Note</dt><dd>It is ideal to configure a separate copy <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> to copy data asynchronously from a computation <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> for CPU-&gt;GPU or GPU-&gt;CPU copies.</dd></dl>
<p>Example implementation: </p><div class="fragment"><div class="line"><span class="preprocessor">#define SIZE 100</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>SimpleCudaTask : <span class="keyword">public</span> <a class="code" href="classhtgs_1_1_i_cuda_task.html">htgs::ICudaTask</a>&lt;MatrixData, VoidData&gt; {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">SimpleCudaTask(CUcontext *<a class="code" href="classhtgs_1_1_i_cuda_task.html#ab5d204cf29330a6ebeb9b52f92a246b1">contexts</a>, <span class="keywordtype">int</span> *<a class="code" href="classhtgs_1_1_i_cuda_task.html#ac8cdec43b08c6b3f92d2f77c2f76d40b">cudaIds</a>, <span class="keywordtype">int</span> <a class="code" href="classhtgs_1_1_i_cuda_task.html#a4f51cb015f18fb3467c1e9fb3cc68b71">numGpus</a>) : <a class="code" href="classhtgs_1_1_i_cuda_task.html#ac289e6e337e7ad1117d6b488789a7eb7">ICudaTask</a>(contexts, cudaIds, numGpus) { }</div><div class="line">~SimpleCudaTask() {}</div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classhtgs_1_1_i_cuda_task.html#a8e48c0cb9c2f52b8539d80494a7618f9">initializeCudaGPU</a>()</div><div class="line">{</div><div class="line">   <span class="comment">// Allocate local GPU memory in initialize will allocate on correct GPU</span></div><div class="line">   cudaMalloc(&amp;localMemory, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>) * SIZE);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classhtgs_1_1_i_cuda_task.html#af5d304db53e1d4ce2572e309bcf987c3">executeTask</a>(std::shared_ptr&lt;MatrixData&gt; data) {</div><div class="line">  ...</div><div class="line">  <span class="keywordtype">double</span> * memory;</div><div class="line"></div><div class="line">  <span class="comment">// Checks if the data received needs to be copied to another GPU</span></div><div class="line">  <span class="comment">// getCudaMemoryData is defined by the MatrixData class</span></div><div class="line">  <span class="keywordflow">if</span> (this-&gt;<a class="code" href="classhtgs_1_1_i_cuda_task.html#a4a4248e1d7d15fed78692de1f09d09e7">autoCopy</a>(localMemory, data-&gt;getCudaMemoryData(), SIZE))</div><div class="line">  {</div><div class="line">    <span class="comment">// Copy was required</span></div><div class="line">    memory = localMemory;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">  {</div><div class="line">    <span class="comment">// Copy was not required because of peer to peer or same GPU</span></div><div class="line">    memory = data-&gt;getMemoryData()-&gt;get();</div><div class="line"></div><div class="line">  }</div><div class="line">  ...</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classhtgs_1_1_i_cuda_task.html#a88f66aa5e0911b851e796d6f1a7f2808">shutdownCuda</a>() { cudaFree(localMemory); }</div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classhtgs_1_1_i_cuda_task.html#a17a3b081acd7f20de7a2759c7120db04">debug</a>() { ... }</div><div class="line"><span class="keyword">virtual</span> std::string <a class="code" href="classhtgs_1_1_i_cuda_task.html#a8be2af6f0261358da1761fb0c0956175">getName</a>() { <span class="keywordflow">return</span> <span class="stringliteral">&quot;SimpleCudaTask&quot;</span>; }</div><div class="line"><span class="keyword">virtual</span> <a class="code" href="classhtgs_1_1_i_task.html">htgs::ITask&lt;PCIAMData, CCFData&gt;</a> *<a class="code" href="classhtgs_1_1_i_cuda_task.html#aa23de96615df6b88e3465b7ca98cc9a8">copy</a>() { <span class="keywordflow">return</span> <span class="keyword">new</span> SimpleCudaTask(...) }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">double</span> *localMemory;</div><div class="line"></div><div class="line">};</div></div><!-- fragment --><p>Example usage: </p><div class="fragment"><div class="line"><a class="code" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf&lt;MatrixData, htgs::VoidData&gt;</a> *taskGraph = <span class="keyword">new</span> <a class="code" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf&lt;MatrixData, htgs::VoidData&gt;</a>();</div><div class="line"></div><div class="line">SimpleCudaTask *cudaTask = <span class="keyword">new</span> SimpleCudaTask(...);</div><div class="line"></div><div class="line"><span class="comment">// Adds cudaTask to process input from taskGraph, input type of cudaTask matches input type of taskGraph</span></div><div class="line">taskGraph-&gt;<a class="code" href="classhtgs_1_1_task_graph_conf.html#a23520b3b3054e16c59784b0d3a289811">setGraphConsumerTask</a>(cudaTask);</div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the input data type for the <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a>, T must derive from <a class="el" href="classhtgs_1_1_i_data.html" title="Class to hold any type of data. ">IData</a>. </td></tr>
    <tr><td class="paramname">U</td><td>the output data type for the <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a>, U must derive from <a class="el" href="classhtgs_1_1_i_data.html" title="Class to hold any type of data. ">IData</a>. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac289e6e337e7ad1117d6b488789a7eb7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhtgs_1_1_i_cuda_task.html">htgs::ICudaTask</a>&lt; T, U &gt;::<a class="el" href="classhtgs_1_1_i_cuda_task.html">ICudaTask</a> </td>
          <td>(</td>
          <td class="paramtype">CUcontext *&#160;</td>
          <td class="paramname"><em>contexts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>cudaIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numGpus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a>. </p>
<p>If this task is added into an <a class="el" href="classhtgs_1_1_execution_pipeline.html" title="The ExecutionPipeline class is used to duplicate task graphs, such that each duplicate executes concu...">ExecutionPipeline</a>, then the number of CUcontexts and cudaIds should match the number of pipelines</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">contexts</td><td>the array of CUcontexts </td></tr>
    <tr><td class="paramname">cudaIds</td><td>the array of cudaIds </td></tr>
    <tr><td class="paramname">numGpus</td><td>the number of GPUs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4a4248e1d7d15fed78692de1f09d09e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<div class="memtemplate">
template&lt;class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhtgs_1_1_i_cuda_task.html">htgs::ICudaTask</a>&lt; T, U &gt;::autoCopy </td>
          <td>(</td>
          <td class="paramtype">V&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_memory_data.html">MemoryData</a>&lt; V &gt;&gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>numElems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Will automatically copy from one GPU to another (if it is required). </p>
<p>Will check if the data being copied requires to be copied first, and then execute cudaMemcpyPeerAsync if the data requires to be copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>cuda memory that can be copied into, must be a pointer </td></tr>
    <tr><td class="paramname">data</td><td>the source <a class="el" href="classhtgs_1_1_memory_data.html" title="Describes memory allocated by a MemoryManager to manage shared memory across multiple ITask...">MemoryData</a> that is allocated using a <a class="el" href="classhtgs_1_1_cuda_memory_manager.html" title="Implements a MemoryManager that binds the thread responsible for the MemoryManager to a CUDA GPU prio...">CudaMemoryManager</a> (created using taskGraph-&gt;addCudaMemoryEdge) </td></tr>
    <tr><td class="paramname">numElems</td><td>the number of elements to be copied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the copy occurred or not </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>if the copy was needed </td></tr>
    <tr><td class="paramname">FALSE</td><td>if the copy was not needed </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>a type of <a class="el" href="classhtgs_1_1_memory_data.html" title="Describes memory allocated by a MemoryManager to manage shared memory across multiple ITask...">MemoryData</a> that is allocated using a <a class="el" href="classhtgs_1_1_cuda_memory_manager.html" title="Implements a MemoryManager that binds the thread responsible for the MemoryManager to a CUDA GPU prio...">CudaMemoryManager</a> (created using taskGraph-&gt;addCudaMemoryEdge) AND must be a pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa23de96615df6b88e3465b7ca98cc9a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt;T, U&gt;* <a class="el" href="classhtgs_1_1_i_cuda_task.html">htgs::ICudaTask</a>&lt; T, U &gt;::copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pure virtual function that copies this <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the copy of the <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> </dd></dl>

<p>Implements <a class="el" href="classhtgs_1_1_i_task.html#acaedf1466b238036d880efcbf1feafe6">htgs::ITask&lt; T, U &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="af5d304db53e1d4ce2572e309bcf987c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classhtgs_1_1_i_cuda_task.html">htgs::ICudaTask</a>&lt; T, U &gt;::executeTask </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; T &gt;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes the <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> on some data. </p>
<p>Use this-&gt;<a class="el" href="classhtgs_1_1_i_cuda_task.html#a6ccc67a7d8cd8ed89a5967bc1508d96c" title="Gets the CUDA stream for this CUDA task. ">getStream()</a> to acquire CUDA stream if needed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the data executed on </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classhtgs_1_1_i_task.html#a78776a659308572e84760e6e36a2520d">htgs::ITask&lt; T, U &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a0307be1be01945d299a0abdd3879cf2e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUcontext* <a class="el" href="classhtgs_1_1_i_cuda_task.html">htgs::ICudaTask</a>&lt; T, U &gt;::getContexts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the cudaContexts specified during <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> construction. </p>
<dl class="section return"><dt>Returns</dt><dd>the cudaContexts </dd></dl>

</div>
</div>
<a class="anchor" id="af8a736f5bb2a2961d7aa6b6421e9eb70"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhtgs_1_1_i_cuda_task.html">htgs::ICudaTask</a>&lt; T, U &gt;::getCudaId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the Cuda Id for this cudaTask. </p>
<p>Set only after this task has been bound to a thread during initialization. </p><dl class="section return"><dt>Returns</dt><dd>the cudaId associated with this cudaTask </dd></dl>

</div>
</div>
<a class="anchor" id="ac2ab6be7db24d03f6b720619e2a0a28e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int* <a class="el" href="classhtgs_1_1_i_cuda_task.html">htgs::ICudaTask</a>&lt; T, U &gt;::getCudaIds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the cudaIds specified during <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> construction. </p>
<dl class="section return"><dt>Returns</dt><dd>the cudaIds </dd></dl>

</div>
</div>
<a class="anchor" id="aa3f7c46ae0d2b0f73dc2b051ca43b2ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classhtgs_1_1_i_cuda_task.html">htgs::ICudaTask</a>&lt; T, U &gt;::getDotFillColor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the color for filling the shape for graphviz dot. </p>
<dl class="section return"><dt>Returns</dt><dd>the fill color </dd></dl>

<p>Reimplemented from <a class="el" href="classhtgs_1_1_i_task.html#ae0f0972cf9a2a828e2fdc9d21717831a">htgs::ITask&lt; T, U &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ab110c2bbb2e3ecc72df1ea25e4be02f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUcontext <a class="el" href="classhtgs_1_1_i_cuda_task.html">htgs::ICudaTask</a>&lt; T, U &gt;::getGPUIdContext </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the cuda Context for the given cudaId. </p>
<p>This can be used to copy between two Cuda GPUs by using cudaMemcpyPeerAsync</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the CudaContext at the given cudaId </dd></dl>

</div>
</div>
<a class="anchor" id="a8be2af6f0261358da1761fb0c0956175"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string <a class="el" href="classhtgs_1_1_i_cuda_task.html">htgs::ICudaTask</a>&lt; T, U &gt;::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual function that gets the name of this <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the name of the <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classhtgs_1_1_i_task.html#afe473a9b204654d331f622d1e62af5f2">htgs::ITask&lt; T, U &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a1d65c58e3cb8bd9385576725791a5bad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classhtgs_1_1_i_cuda_task.html">htgs::ICudaTask</a>&lt; T, U &gt;::getNumGPUs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of GPUs specified during <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> construction. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of GPUs </dd></dl>

</div>
</div>
<a class="anchor" id="a6ccc67a7d8cd8ed89a5967bc1508d96c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const CUstream&amp; <a class="el" href="classhtgs_1_1_i_cuda_task.html">htgs::ICudaTask</a>&lt; T, U &gt;::getStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the CUDA stream for this CUDA task. </p>
<dl class="section return"><dt>Returns</dt><dd>the CUDA stream </dd></dl>

</div>
</div>
<a class="anchor" id="a438e9f9befc1db05c3545a05125c9f84"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUcontext <a class="el" href="classhtgs_1_1_i_cuda_task.html">htgs::ICudaTask</a>&lt; T, U &gt;::getTaskCudaContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the CudaContext associated with this task. </p>
<p>Set only after this task has been bound to a thread during initialization. </p><dl class="section return"><dt>Returns</dt><dd>the Cuda Context </dd></dl>

</div>
</div>
<a class="anchor" id="a2766c0114e43c0a84ed27a204ec51212"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhtgs_1_1_i_cuda_task.html">htgs::ICudaTask</a>&lt; T, U &gt;::hasPeerToPeerCopy </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pipelineId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the requested pipelineId allows peer to peer GPU copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipelineId</td><td>the pipelineId to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the pipeline id has peer to peer GPU copy </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>if the pipeline id has peer to peer GPU copy </td></tr>
    <tr><td class="paramname">FALSE</td><td>if the pipeline id has peer to peer GPU copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9139d923f48e4084b92be0db2b357402"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_i_cuda_task.html">htgs::ICudaTask</a>&lt; T, U &gt;::initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the CudaTask to be bound to a particular GPU. </p>
<dl class="section note"><dt>Note</dt><dd>This function should only be called by the HTGS API </dd></dl>

<p>Reimplemented from <a class="el" href="classhtgs_1_1_i_task.html#af897c3050091c42e9afd364ac25c8eb6">htgs::ITask&lt; T, U &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aa84c6764a48c3398b293a978fb61a1c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhtgs_1_1_i_cuda_task.html">htgs::ICudaTask</a>&lt; T, U &gt;::requiresCopy </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pipelineId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the requested pipelineId requires GPU-to-GPU copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipelineId</td><td>the <a class="el" href="classhtgs_1_1_execution_pipeline.html" title="The ExecutionPipeline class is used to duplicate task graphs, such that each duplicate executes concu...">ExecutionPipeline</a> id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the requested pipelineId would require a GPU-to-GPU copy </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>if copy is required </td></tr>
    <tr><td class="paramname">FALSE</td><td>if copy is not required </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0ed21dd37fe3fcaabcd5e69604f93c8a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<div class="memtemplate">
template&lt;class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhtgs_1_1_i_cuda_task.html">htgs::ICudaTask</a>&lt; T, U &gt;::requiresCopy </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_memory_data.html">MemoryData</a>&lt; V &gt;&gt;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the requested pipelineId requires GPU-to-GPU copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the memory data to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the requested <a class="el" href="classhtgs_1_1_memory_data.html" title="Describes memory allocated by a MemoryManager to manage shared memory across multiple ITask...">MemoryData</a> would require GPU-to-GPU copy </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>if copy is required </td></tr>
    <tr><td class="paramname">FALSE</td><td>if copy is not required </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>a type of <a class="el" href="classhtgs_1_1_memory_data.html" title="Describes memory allocated by a MemoryManager to manage shared memory across multiple ITask...">MemoryData</a> that is allocated using a <a class="el" href="classhtgs_1_1_cuda_memory_manager.html" title="Implements a MemoryManager that binds the thread responsible for the MemoryManager to a CUDA GPU prio...">CudaMemoryManager</a> (created using taskGraph-&gt;addCudaMemoryEdge) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab851e15d02a2760ebb75da95011cc5bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_i_cuda_task.html">htgs::ICudaTask</a>&lt; T, U &gt;::shutdown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shutsdown the <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This function should only be called by the HTGS API </dd></dl>

<p>Reimplemented from <a class="el" href="classhtgs_1_1_i_task.html#acad9dd61bff4a2d2f96bbb4532a3bb82">htgs::ITask&lt; T, U &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aa544d0fc6b744646a2e195a0a0383915"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_i_cuda_task.html">htgs::ICudaTask</a>&lt; T, U &gt;::syncStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronizes the Cuda stream associated with this task. </p>
<dl class="section note"><dt>Note</dt><dd>Should only be called after initialization </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/tjb3/phd-research/HTGS/src/htgs/api/<a class="el" href="_i_cuda_task_8hpp_source.html">ICudaTask.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>htgs</b></li><li class="navelem"><a class="el" href="classhtgs_1_1_i_cuda_task.html">ICudaTask</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
