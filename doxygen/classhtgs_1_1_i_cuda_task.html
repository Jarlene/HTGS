<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>htgs: htgs::ICudaTask&lt; T, U &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">htgs
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classhtgs_1_1_i_cuda_task.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classhtgs_1_1_i_cuda_task-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">htgs::ICudaTask&lt; T, U &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>An <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> is used to attach a task to an NVIDIA Cuda GPU.  
 <a href="classhtgs_1_1_i_cuda_task.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_i_cuda_task_8hpp_source.html">htgs/api/ICudaTask.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for htgs::ICudaTask&lt; T, U &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classhtgs_1_1_i_cuda_task__inherit__graph.png" border="0" usemap="#htgs_1_1_i_cuda_task_3_01_t_00_01_u_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="htgs_1_1_i_cuda_task_3_01_t_00_01_u_01_4_inherit__map" id="htgs_1_1_i_cuda_task_3_01_t_00_01_u_01_4_inherit__map">
<area shape="rect" id="node2" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. " alt="" coords="20,80,159,107"/><area shape="rect" id="node3" href="classhtgs_1_1_base_i_task.html" title="Implements the parent ITask, which removes the template arguments of an ITask. " alt="" coords="30,5,148,32"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for htgs::ICudaTask&lt; T, U &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classhtgs_1_1_i_cuda_task__coll__graph.png" border="0" usemap="#htgs_1_1_i_cuda_task_3_01_t_00_01_u_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="htgs_1_1_i_cuda_task_3_01_t_00_01_u_01_4_coll__map" id="htgs_1_1_i_cuda_task_3_01_t_00_01_u_01_4_coll__map">
<area shape="rect" id="node2" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. " alt="" coords="44,309,183,336"/><area shape="rect" id="node3" href="classhtgs_1_1_base_i_task.html" title="Implements the parent ITask, which removes the template arguments of an ITask. " alt="" coords="5,211,123,237"/><area shape="rect" id="node4" href="classhtgs_1_1_task_scheduler.html" title="htgs::TaskScheduler\l\&lt; T, U \&gt;" alt="" coords="147,203,289,245"/><area shape="rect" id="node5" href="classhtgs_1_1_base_task_scheduler.html" title="The parent class for a Task that removes the template arguments. " alt="" coords="106,5,277,32"/><area shape="rect" id="node6" href="classhtgs_1_1_base_task_scheduler_runtime_thread.html" title="Manages a BaseTaskScheduler that is bound to a thread for execution. " alt="" coords="181,97,403,138"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8da1bfa99b2dd2337e8ba4f70637060a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#a8da1bfa99b2dd2337e8ba4f70637060a">ICudaTask</a> (CUcontext *<a class="el" href="classhtgs_1_1_i_cuda_task.html#ab5d204cf29330a6ebeb9b52f92a246b1">contexts</a>, int *<a class="el" href="classhtgs_1_1_i_cuda_task.html#ac8cdec43b08c6b3f92d2f77c2f76d40b">cudaIds</a>, int <a class="el" href="classhtgs_1_1_i_cuda_task.html#ace797ef51d9c5997d89002e067b52f78">numGpus</a>)</td></tr>
<tr class="memdesc:a8da1bfa99b2dd2337e8ba4f70637060a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a>.  <a href="#a8da1bfa99b2dd2337e8ba4f70637060a">More...</a><br/></td></tr>
<tr class="separator:a8da1bfa99b2dd2337e8ba4f70637060a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a736f5bb2a2961d7aa6b6421e9eb70"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#af8a736f5bb2a2961d7aa6b6421e9eb70">getCudaId</a> ()</td></tr>
<tr class="memdesc:af8a736f5bb2a2961d7aa6b6421e9eb70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the Cuda Id for this cudaTask.  <a href="#af8a736f5bb2a2961d7aa6b6421e9eb70">More...</a><br/></td></tr>
<tr class="separator:af8a736f5bb2a2961d7aa6b6421e9eb70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438e9f9befc1db05c3545a05125c9f84"><td class="memItemLeft" align="right" valign="top">CUcontext&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#a438e9f9befc1db05c3545a05125c9f84">getTaskCudaContext</a> ()</td></tr>
<tr class="memdesc:a438e9f9befc1db05c3545a05125c9f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the CudaContext associated with this task.  <a href="#a438e9f9befc1db05c3545a05125c9f84">More...</a><br/></td></tr>
<tr class="separator:a438e9f9befc1db05c3545a05125c9f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab110c2bbb2e3ecc72df1ea25e4be02f3"><td class="memItemLeft" align="right" valign="top">CUcontext&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#ab110c2bbb2e3ecc72df1ea25e4be02f3">getGPUIdContext</a> (int index)</td></tr>
<tr class="memdesc:ab110c2bbb2e3ecc72df1ea25e4be02f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the cuda Context for the given cudaId.  <a href="#ab110c2bbb2e3ecc72df1ea25e4be02f3">More...</a><br/></td></tr>
<tr class="separator:ab110c2bbb2e3ecc72df1ea25e4be02f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70470776641d6134e2dd9bd1bbe2d226"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#a70470776641d6134e2dd9bd1bbe2d226">requiresCopy</a> (int <a class="el" href="classhtgs_1_1_i_task.html#a5da9d90a63af4d99a510f6fbb1d8c803">pipelineId</a>)</td></tr>
<tr class="memdesc:a70470776641d6134e2dd9bd1bbe2d226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the requested pipelineId requires GPU-to-GPU copy.  <a href="#a70470776641d6134e2dd9bd1bbe2d226">More...</a><br/></td></tr>
<tr class="separator:a70470776641d6134e2dd9bd1bbe2d226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed21dd37fe3fcaabcd5e69604f93c8a"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:a0ed21dd37fe3fcaabcd5e69604f93c8a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#a0ed21dd37fe3fcaabcd5e69604f93c8a">requiresCopy</a> (std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_memory_data.html">MemoryData</a>&lt; V &gt;&gt; data)</td></tr>
<tr class="memdesc:a0ed21dd37fe3fcaabcd5e69604f93c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the requested pipelineId requires GPU-to-GPU copy.  <a href="#a0ed21dd37fe3fcaabcd5e69604f93c8a">More...</a><br/></td></tr>
<tr class="separator:a0ed21dd37fe3fcaabcd5e69604f93c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5770e50a2e5c9fc669386dc40f6502"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#a2d5770e50a2e5c9fc669386dc40f6502">hasPeerToPeerCopy</a> (int <a class="el" href="classhtgs_1_1_i_task.html#a5da9d90a63af4d99a510f6fbb1d8c803">pipelineId</a>)</td></tr>
<tr class="memdesc:a2d5770e50a2e5c9fc669386dc40f6502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the requested pipelineId allows peer to peer GPU copy.  <a href="#a2d5770e50a2e5c9fc669386dc40f6502">More...</a><br/></td></tr>
<tr class="separator:a2d5770e50a2e5c9fc669386dc40f6502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4248e1d7d15fed78692de1f09d09e7"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:a4a4248e1d7d15fed78692de1f09d09e7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#a4a4248e1d7d15fed78692de1f09d09e7">autoCopy</a> (V destination, std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_memory_data.html">MemoryData</a>&lt; V &gt;&gt; data, long numElems)</td></tr>
<tr class="memdesc:a4a4248e1d7d15fed78692de1f09d09e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will automatically copy from one GPU to another (if it is required).  <a href="#a4a4248e1d7d15fed78692de1f09d09e7">More...</a><br/></td></tr>
<tr class="separator:a4a4248e1d7d15fed78692de1f09d09e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc639a73a9a4974f5e5f5a66a5cf5c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#a2bc639a73a9a4974f5e5f5a66a5cf5c5">initialize</a> (int <a class="el" href="classhtgs_1_1_i_task.html#a5da9d90a63af4d99a510f6fbb1d8c803">pipelineId</a>, int numPipeline, <a class="el" href="classhtgs_1_1_task_scheduler.html">TaskScheduler</a>&lt; T, U &gt; *<a class="el" href="classhtgs_1_1_i_task.html#a055a0bcd8059a79129dd0367c0ef9ee6">ownerTask</a>, std::shared_ptr&lt; std::vector&lt; std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_base_connector.html">BaseConnector</a> &gt;&gt;&gt; pipelineConnectorList)</td></tr>
<tr class="memdesc:a2bc639a73a9a4974f5e5f5a66a5cf5c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the CudaTask to be bound to a particular GPU.  <a href="#a2bc639a73a9a4974f5e5f5a66a5cf5c5">More...</a><br/></td></tr>
<tr class="separator:a2bc639a73a9a4974f5e5f5a66a5cf5c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385f5cff3117b8a774e67fea02a12922"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#a385f5cff3117b8a774e67fea02a12922">shutdown</a> ()</td></tr>
<tr class="memdesc:a385f5cff3117b8a774e67fea02a12922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shutsdown the <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a>.  <a href="#a385f5cff3117b8a774e67fea02a12922">More...</a><br/></td></tr>
<tr class="separator:a385f5cff3117b8a774e67fea02a12922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d73cdcbd460a8d7bb99e243577a2f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#a87d73cdcbd460a8d7bb99e243577a2f6">executeTask</a> (std::shared_ptr&lt; T &gt; data)</td></tr>
<tr class="memdesc:a87d73cdcbd460a8d7bb99e243577a2f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> on some data.  <a href="#a87d73cdcbd460a8d7bb99e243577a2f6">More...</a><br/></td></tr>
<tr class="separator:a87d73cdcbd460a8d7bb99e243577a2f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0307be1be01945d299a0abdd3879cf2e"><td class="memItemLeft" align="right" valign="top">CUcontext *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#a0307be1be01945d299a0abdd3879cf2e">getContexts</a> ()</td></tr>
<tr class="memdesc:a0307be1be01945d299a0abdd3879cf2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the cudaContexts specified during <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> construction.  <a href="#a0307be1be01945d299a0abdd3879cf2e">More...</a><br/></td></tr>
<tr class="separator:a0307be1be01945d299a0abdd3879cf2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ab6be7db24d03f6b720619e2a0a28e"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#ac2ab6be7db24d03f6b720619e2a0a28e">getCudaIds</a> ()</td></tr>
<tr class="memdesc:ac2ab6be7db24d03f6b720619e2a0a28e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the cudaIds specified during <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> construction.  <a href="#ac2ab6be7db24d03f6b720619e2a0a28e">More...</a><br/></td></tr>
<tr class="separator:ac2ab6be7db24d03f6b720619e2a0a28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d4a6b432c5db024c00320674d4a71d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#a68d4a6b432c5db024c00320674d4a71d">getNumGPUs</a> ()</td></tr>
<tr class="memdesc:a68d4a6b432c5db024c00320674d4a71d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of GPUs specified during <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> construction.  <a href="#a68d4a6b432c5db024c00320674d4a71d">More...</a><br/></td></tr>
<tr class="separator:a68d4a6b432c5db024c00320674d4a71d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa544d0fc6b744646a2e195a0a0383915"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#aa544d0fc6b744646a2e195a0a0383915">syncStream</a> ()</td></tr>
<tr class="memdesc:aa544d0fc6b744646a2e195a0a0383915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronizes the Cuda stream associated with this task.  <a href="#aa544d0fc6b744646a2e195a0a0383915">More...</a><br/></td></tr>
<tr class="separator:aa544d0fc6b744646a2e195a0a0383915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e2383c154857534d79364af6d495e8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#a92e2383c154857534d79364af6d495e8">initializeCudaGPU</a> (CUcontext <a class="el" href="classhtgs_1_1_i_cuda_task.html#a1e41aadbe037089aec99fd9805e80c39">context</a>, CUstream <a class="el" href="classhtgs_1_1_i_cuda_task.html#a0e11becef7b34a87934ea336978cf5af">stream</a>, int <a class="el" href="classhtgs_1_1_i_cuda_task.html#a857caf32854f8e04a528dbc7b0151c26">cudaId</a>, int numGPUs, int <a class="el" href="classhtgs_1_1_i_task.html#a5da9d90a63af4d99a510f6fbb1d8c803">pipelineId</a>, int numPipelines)</td></tr>
<tr class="memdesc:a92e2383c154857534d79364af6d495e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function that is called when the <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> has been initialized.  <a href="#a92e2383c154857534d79364af6d495e8">More...</a><br/></td></tr>
<tr class="separator:a92e2383c154857534d79364af6d495e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf1df3dd8bb5a0c33222aabc65dc629"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#a4cf1df3dd8bb5a0c33222aabc65dc629">executeGPUTask</a> (std::shared_ptr&lt; T &gt; data, CUstream <a class="el" href="classhtgs_1_1_i_cuda_task.html#a0e11becef7b34a87934ea336978cf5af">stream</a>)=0</td></tr>
<tr class="memdesc:a4cf1df3dd8bb5a0c33222aabc65dc629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pure virtual function that is called when the <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> is executing on data.  <a href="#a4cf1df3dd8bb5a0c33222aabc65dc629">More...</a><br/></td></tr>
<tr class="separator:a4cf1df3dd8bb5a0c33222aabc65dc629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f66aa5e0911b851e796d6f1a7f2808"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88f66aa5e0911b851e796d6f1a7f2808"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#a88f66aa5e0911b851e796d6f1a7f2808">shutdownCuda</a> ()</td></tr>
<tr class="memdesc:a88f66aa5e0911b851e796d6f1a7f2808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function that is called when the <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> is shutting down. <br/></td></tr>
<tr class="separator:a88f66aa5e0911b851e796d6f1a7f2808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09251c89aea49412169a5b602ef2ee49"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#a09251c89aea49412169a5b602ef2ee49">getName</a> ()</td></tr>
<tr class="memdesc:a09251c89aea49412169a5b602ef2ee49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function that gets the name of this <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a>.  <a href="#a09251c89aea49412169a5b602ef2ee49">More...</a><br/></td></tr>
<tr class="separator:a09251c89aea49412169a5b602ef2ee49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23de96615df6b88e3465b7ca98cc9a8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt; T, U &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#aa23de96615df6b88e3465b7ca98cc9a8">copy</a> ()=0</td></tr>
<tr class="memdesc:aa23de96615df6b88e3465b7ca98cc9a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pure virtual function that copies this <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a>.  <a href="#aa23de96615df6b88e3465b7ca98cc9a8">More...</a><br/></td></tr>
<tr class="separator:aa23de96615df6b88e3465b7ca98cc9a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2fc1acdad075a8b4e06b5c265b60b94"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#ab2fc1acdad075a8b4e06b5c265b60b94">isTerminated</a> (std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_base_connector.html">htgs::BaseConnector</a> &gt; inputConnector)=0</td></tr>
<tr class="memdesc:ab2fc1acdad075a8b4e06b5c265b60b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pure virtual function that checks whether this <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> is terminated or not.  <a href="#ab2fc1acdad075a8b4e06b5c265b60b94">More...</a><br/></td></tr>
<tr class="separator:ab2fc1acdad075a8b4e06b5c265b60b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e571a92462f5ba40f1165cc800a8bcc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e571a92462f5ba40f1165cc800a8bcc"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#a5e571a92462f5ba40f1165cc800a8bcc">debug</a> ()</td></tr>
<tr class="memdesc:a5e571a92462f5ba40f1165cc800a8bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function that can be used to provide debug information. <br/></td></tr>
<tr class="separator:a5e571a92462f5ba40f1165cc800a8bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhtgs_1_1_i_task"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhtgs_1_1_i_task')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhtgs_1_1_i_task.html">htgs::ITask&lt; T, U &gt;</a></td></tr>
<tr class="memitem:ac23fa74bf05d6a86000422d989ccc5d1 inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac23fa74bf05d6a86000422d989ccc5d1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#ac23fa74bf05d6a86000422d989ccc5d1">ITask</a> ()</td></tr>
<tr class="memdesc:ac23fa74bf05d6a86000422d989ccc5d1 inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> with number of threads equal to 1. <br/></td></tr>
<tr class="separator:ac23fa74bf05d6a86000422d989ccc5d1 inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af634cc160a862c683abd07b61d72332e inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#af634cc160a862c683abd07b61d72332e">ITask</a> (int <a class="el" href="classhtgs_1_1_i_task.html#ab2e1f133f9408f0a1340b2f682c0e54f">numThreads</a>)</td></tr>
<tr class="memdesc:af634cc160a862c683abd07b61d72332e inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> with a specified number of threads.  <a href="#af634cc160a862c683abd07b61d72332e">More...</a><br/></td></tr>
<tr class="separator:af634cc160a862c683abd07b61d72332e inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989523e7239586ec9999384ebb0b4174 inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#a989523e7239586ec9999384ebb0b4174">ITask</a> (int <a class="el" href="classhtgs_1_1_i_task.html#ab2e1f133f9408f0a1340b2f682c0e54f">numThreads</a>, bool <a class="el" href="classhtgs_1_1_i_task.html#a0ce9a193a938edf4b6862926ff741511">isStartTask</a>, bool <a class="el" href="classhtgs_1_1_i_task.html#a0757403bce3b40d369330af6398e7fd9">poll</a>, long <a class="el" href="classhtgs_1_1_i_task.html#a3c12d83f5a2f87fd71453eaaac3feed8">microTimeoutTime</a>)</td></tr>
<tr class="memdesc:a989523e7239586ec9999384ebb0b4174 inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> with a specified number of threads as well as additional scheduling options.  <a href="#a989523e7239586ec9999384ebb0b4174">More...</a><br/></td></tr>
<tr class="separator:a989523e7239586ec9999384ebb0b4174 inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cebc4dc6ff74eeb0d27b076a642bb80 inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0cebc4dc6ff74eeb0d27b076a642bb80"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#a0cebc4dc6ff74eeb0d27b076a642bb80">~ITask</a> ()</td></tr>
<tr class="memdesc:a0cebc4dc6ff74eeb0d27b076a642bb80 inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="separator:a0cebc4dc6ff74eeb0d27b076a642bb80 inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb07ef40eb479d07e3a8379320a28840 inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#aeb07ef40eb479d07e3a8379320a28840">setPipelineId</a> (int <a class="el" href="classhtgs_1_1_i_task.html#a5da9d90a63af4d99a510f6fbb1d8c803">pipelineId</a>)</td></tr>
<tr class="memdesc:aeb07ef40eb479d07e3a8379320a28840 inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the pipeline Id for this <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a>.  <a href="#aeb07ef40eb479d07e3a8379320a28840">More...</a><br/></td></tr>
<tr class="separator:aeb07ef40eb479d07e3a8379320a28840 inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a67cc24e70396b6db89abc11bf3dd32 inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#a8a67cc24e70396b6db89abc11bf3dd32">setNumThreads</a> (int <a class="el" href="classhtgs_1_1_i_task.html#ab2e1f133f9408f0a1340b2f682c0e54f">numThreads</a>)</td></tr>
<tr class="memdesc:a8a67cc24e70396b6db89abc11bf3dd32 inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of threads associated with this <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a>.  <a href="#a8a67cc24e70396b6db89abc11bf3dd32">More...</a><br/></td></tr>
<tr class="separator:a8a67cc24e70396b6db89abc11bf3dd32 inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a2c1ab7f3db3e69458d2cf0e708435 inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#af5a2c1ab7f3db3e69458d2cf0e708435">setIsStartTask</a> (bool <a class="el" href="classhtgs_1_1_i_task.html#a0ce9a193a938edf4b6862926ff741511">isStartTask</a>)</td></tr>
<tr class="memdesc:af5a2c1ab7f3db3e69458d2cf0e708435 inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether this task is a start task or not.  <a href="#af5a2c1ab7f3db3e69458d2cf0e708435">More...</a><br/></td></tr>
<tr class="separator:af5a2c1ab7f3db3e69458d2cf0e708435 inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e97a5b81e7e9c99ae369f94f3ae7364 inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#a5e97a5b81e7e9c99ae369f94f3ae7364">setPoll</a> (bool <a class="el" href="classhtgs_1_1_i_task.html#a0757403bce3b40d369330af6398e7fd9">poll</a>)</td></tr>
<tr class="memdesc:a5e97a5b81e7e9c99ae369f94f3ae7364 inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether this task is polling for data or not.  <a href="#a5e97a5b81e7e9c99ae369f94f3ae7364">More...</a><br/></td></tr>
<tr class="separator:a5e97a5b81e7e9c99ae369f94f3ae7364 inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18dbd35950af39c9f204116c2bf3370a inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#a18dbd35950af39c9f204116c2bf3370a">setMicroTimeoutTime</a> (long <a class="el" href="classhtgs_1_1_i_task.html#a3c12d83f5a2f87fd71453eaaac3feed8">microTimeoutTime</a>)</td></tr>
<tr class="memdesc:a18dbd35950af39c9f204116c2bf3370a inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the timeout time for polling in microseconds.  <a href="#a18dbd35950af39c9f204116c2bf3370a">More...</a><br/></td></tr>
<tr class="separator:a18dbd35950af39c9f204116c2bf3370a inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeeada962181237186b47285ab5b8947 inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#abeeada962181237186b47285ab5b8947">getNumThreads</a> () const </td></tr>
<tr class="memdesc:abeeada962181237186b47285ab5b8947 inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of threads associated with this <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a>.  <a href="#abeeada962181237186b47285ab5b8947">More...</a><br/></td></tr>
<tr class="separator:abeeada962181237186b47285ab5b8947 inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc7328b459243cfe5f91eed69a7223e inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#a7dc7328b459243cfe5f91eed69a7223e">getIsStartTask</a> () const </td></tr>
<tr class="memdesc:a7dc7328b459243cfe5f91eed69a7223e inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether this <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> is a starting task.  <a href="#a7dc7328b459243cfe5f91eed69a7223e">More...</a><br/></td></tr>
<tr class="separator:a7dc7328b459243cfe5f91eed69a7223e inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2342f6be5d1fe4fb0eb1c9bae2dbc528 inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#a2342f6be5d1fe4fb0eb1c9bae2dbc528">isPoll</a> () const </td></tr>
<tr class="memdesc:a2342f6be5d1fe4fb0eb1c9bae2dbc528 inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether this <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> is polling for data or not.  <a href="#a2342f6be5d1fe4fb0eb1c9bae2dbc528">More...</a><br/></td></tr>
<tr class="separator:a2342f6be5d1fe4fb0eb1c9bae2dbc528 inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655b9e9bf1ac547e9c29c2e99d1f7016 inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#a655b9e9bf1ac547e9c29c2e99d1f7016">getMicroTimeoutTime</a> () const </td></tr>
<tr class="memdesc:a655b9e9bf1ac547e9c29c2e99d1f7016 inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the timeout time for polling.  <a href="#a655b9e9bf1ac547e9c29c2e99d1f7016">More...</a><br/></td></tr>
<tr class="separator:a655b9e9bf1ac547e9c29c2e99d1f7016 inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64952b7c68e97d84c97c7b15a0b032aa inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#a64952b7c68e97d84c97c7b15a0b032aa">addResult</a> (std::shared_ptr&lt; U &gt; result)</td></tr>
<tr class="memdesc:a64952b7c68e97d84c97c7b15a0b032aa inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds results to the output list to be sent to the next connected <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> in a <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a>.  <a href="#a64952b7c68e97d84c97c7b15a0b032aa">More...</a><br/></td></tr>
<tr class="separator:a64952b7c68e97d84c97c7b15a0b032aa inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab8481dc44985387e35477324e263f7 inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#adab8481dc44985387e35477324e263f7">addResult</a> (U *result)</td></tr>
<tr class="memdesc:adab8481dc44985387e35477324e263f7 inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds results to the output list to be sent to the next connected <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> in a <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a>.  <a href="#adab8481dc44985387e35477324e263f7">More...</a><br/></td></tr>
<tr class="separator:adab8481dc44985387e35477324e263f7 inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ddfa059fc5891ce19a4690aaa2f294 inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt; T, U &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#a50ddfa059fc5891ce19a4690aaa2f294">copyITask</a> ()</td></tr>
<tr class="memdesc:a50ddfa059fc5891ce19a4690aaa2f294 inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> including its list of memGetters and memReleasers.  <a href="#a50ddfa059fc5891ce19a4690aaa2f294">More...</a><br/></td></tr>
<tr class="separator:a50ddfa059fc5891ce19a4690aaa2f294 inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29e3c78e0079017d17fb3e39e05fd41 inherit pub_methods_classhtgs_1_1_i_task"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:ac29e3c78e0079017d17fb3e39e05fd41 inherit pub_methods_classhtgs_1_1_i_task"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_memory_data.html">MemoryData</a>&lt; V &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#ac29e3c78e0079017d17fb3e39e05fd41">memGet</a> (std::string name, <a class="el" href="classhtgs_1_1_i_memory_release_rule.html">IMemoryReleaseRule</a> *releaseRule)</td></tr>
<tr class="memdesc:ac29e3c78e0079017d17fb3e39e05fd41 inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves memory from a memory edge.  <a href="#ac29e3c78e0079017d17fb3e39e05fd41">More...</a><br/></td></tr>
<tr class="separator:ac29e3c78e0079017d17fb3e39e05fd41 inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f8ea35e515b324518e3607e9a4e3e2 inherit pub_methods_classhtgs_1_1_i_task"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:a63f8ea35e515b324518e3607e9a4e3e2 inherit pub_methods_classhtgs_1_1_i_task"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_memory_data.html">MemoryData</a>&lt; V &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#a63f8ea35e515b324518e3607e9a4e3e2">memGet</a> (std::string name, <a class="el" href="classhtgs_1_1_i_memory_release_rule.html">IMemoryReleaseRule</a> *releaseRule, size_t numElems)</td></tr>
<tr class="memdesc:a63f8ea35e515b324518e3607e9a4e3e2 inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves memory from a memory edge.  <a href="#a63f8ea35e515b324518e3607e9a4e3e2">More...</a><br/></td></tr>
<tr class="separator:a63f8ea35e515b324518e3607e9a4e3e2 inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322b23d307ce1b12d302ce2d622f8308 inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#a322b23d307ce1b12d302ce2d622f8308">allocUserManagedMemory</a> (std::string name)</td></tr>
<tr class="memdesc:a322b23d307ce1b12d302ce2d622f8308 inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves memory from a memory edge that is managed by the user.  <a href="#a322b23d307ce1b12d302ce2d622f8308">More...</a><br/></td></tr>
<tr class="separator:a322b23d307ce1b12d302ce2d622f8308 inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc611d4a0883c5ba28f740dc89377f6 inherit pub_methods_classhtgs_1_1_i_task"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:a6dc611d4a0883c5ba28f740dc89377f6 inherit pub_methods_classhtgs_1_1_i_task"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#a6dc611d4a0883c5ba28f740dc89377f6">memRelease</a> (std::string name, std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_memory_data.html">MemoryData</a>&lt; V &gt;&gt; memory)</td></tr>
<tr class="memdesc:a6dc611d4a0883c5ba28f740dc89377f6 inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases memory onto a memory edge.  <a href="#a6dc611d4a0883c5ba28f740dc89377f6">More...</a><br/></td></tr>
<tr class="separator:a6dc611d4a0883c5ba28f740dc89377f6 inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed8c21d5fb4315b425c5865f768f7d0 inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#afed8c21d5fb4315b425c5865f768f7d0">memRelease</a> (std::string name, int <a class="el" href="classhtgs_1_1_i_task.html#a5da9d90a63af4d99a510f6fbb1d8c803">pipelineId</a>)</td></tr>
<tr class="memdesc:afed8c21d5fb4315b425c5865f768f7d0 inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases memory onto a memory edge.  <a href="#afed8c21d5fb4315b425c5865f768f7d0">More...</a><br/></td></tr>
<tr class="separator:afed8c21d5fb4315b425c5865f768f7d0 inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab5b1e090cf381b91dca983665bae2b inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#abab5b1e090cf381b91dca983665bae2b">hasMemGetter</a> (std::string name)</td></tr>
<tr class="memdesc:abab5b1e090cf381b91dca983665bae2b inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether this <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> contains a memGetter for a specified name.  <a href="#abab5b1e090cf381b91dca983665bae2b">More...</a><br/></td></tr>
<tr class="separator:abab5b1e090cf381b91dca983665bae2b inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f3f2adfcd1d95465f343aab9a63662 inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#aa1f3f2adfcd1d95465f343aab9a63662">hasMemReleaser</a> (std::string name)</td></tr>
<tr class="memdesc:aa1f3f2adfcd1d95465f343aab9a63662 inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether this <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> contains a memReleaser for a specified name.  <a href="#aa1f3f2adfcd1d95465f343aab9a63662">More...</a><br/></td></tr>
<tr class="separator:aa1f3f2adfcd1d95465f343aab9a63662 inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f87e2851725015f5a01fbe75dfd9ed inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#af7f87e2851725015f5a01fbe75dfd9ed">isMemReleaserOutsideGraph</a> (std::string name)</td></tr>
<tr class="memdesc:af7f87e2851725015f5a01fbe75dfd9ed inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether this <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> contains a memReleaser that exists outside of the graph that the memory edge exists.  <a href="#af7f87e2851725015f5a01fbe75dfd9ed">More...</a><br/></td></tr>
<tr class="separator:af7f87e2851725015f5a01fbe75dfd9ed inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4d5c51e177c5c87e08b50977bdc095 inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#a6c4d5c51e177c5c87e08b50977bdc095">attachMemGetter</a> (std::string name, std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_base_connector.html">BaseConnector</a> &gt; connector, MMType type)</td></tr>
<tr class="memdesc:a6c4d5c51e177c5c87e08b50977bdc095 inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a memGetter to this <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a>.  <a href="#a6c4d5c51e177c5c87e08b50977bdc095">More...</a><br/></td></tr>
<tr class="separator:a6c4d5c51e177c5c87e08b50977bdc095 inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55abce7b871a6a181136ba20bbae8659 inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#a55abce7b871a6a181136ba20bbae8659">attachMemReleaser</a> (std::string name, std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_base_connector.html">BaseConnector</a> &gt; connector, MMType type, bool outsideMemManGraph)</td></tr>
<tr class="memdesc:a55abce7b871a6a181136ba20bbae8659 inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a memReleaser to this <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a>.  <a href="#a55abce7b871a6a181136ba20bbae8659">More...</a><br/></td></tr>
<tr class="separator:a55abce7b871a6a181136ba20bbae8659 inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40440dd567664a09d4d502f62217eea7 inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">std::shared_ptr<br class="typebreak"/>
&lt; ConnectorVectorMap &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#a40440dd567664a09d4d502f62217eea7">getMemReleasers</a> ()</td></tr>
<tr class="memdesc:a40440dd567664a09d4d502f62217eea7 inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the memReleaser mapping.  <a href="#a40440dd567664a09d4d502f62217eea7">More...</a><br/></td></tr>
<tr class="separator:a40440dd567664a09d4d502f62217eea7 inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d67a539ea8ae881c9c7b7f5a41cd85 inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#aa4d67a539ea8ae881c9c7b7f5a41cd85">initializeITask</a> (int <a class="el" href="classhtgs_1_1_i_task.html#a5da9d90a63af4d99a510f6fbb1d8c803">pipelineId</a>, int numPipeline, <a class="el" href="classhtgs_1_1_task_scheduler.html">TaskScheduler</a>&lt; T, U &gt; *<a class="el" href="classhtgs_1_1_i_task.html#a055a0bcd8059a79129dd0367c0ef9ee6">ownerTask</a>, std::shared_ptr&lt; ConnectorVector &gt; pipelineConnectorList)</td></tr>
<tr class="memdesc:aa4d67a539ea8ae881c9c7b7f5a41cd85 inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a>.  <a href="#aa4d67a539ea8ae881c9c7b7f5a41cd85">More...</a><br/></td></tr>
<tr class="separator:aa4d67a539ea8ae881c9c7b7f5a41cd85 inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ef48478a2c1a71664aabfedec0fe91 inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#ab5ef48478a2c1a71664aabfedec0fe91">profileITask</a> ()</td></tr>
<tr class="memdesc:ab5ef48478a2c1a71664aabfedec0fe91 inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides profile output for the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a>,.  <a href="#ab5ef48478a2c1a71664aabfedec0fe91">More...</a><br/></td></tr>
<tr class="separator:ab5ef48478a2c1a71664aabfedec0fe91 inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe832ff8732822f3fcbf72314d3bf109 inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#abe832ff8732822f3fcbf72314d3bf109">initialize</a> (int <a class="el" href="classhtgs_1_1_i_task.html#a5da9d90a63af4d99a510f6fbb1d8c803">pipelineId</a>, int numPipeline, <a class="el" href="classhtgs_1_1_task_scheduler.html">TaskScheduler</a>&lt; T, U &gt; *<a class="el" href="classhtgs_1_1_i_task.html#a055a0bcd8059a79129dd0367c0ef9ee6">ownerTask</a>, std::shared_ptr&lt; ConnectorVector &gt; pipelineConnectorList)</td></tr>
<tr class="memdesc:abe832ff8732822f3fcbf72314d3bf109 inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function that is called when an <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> is being initialized by it's owner thread.  <a href="#abe832ff8732822f3fcbf72314d3bf109">More...</a><br/></td></tr>
<tr class="separator:abe832ff8732822f3fcbf72314d3bf109 inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae818ab0579ae490810a560a7e4209d8f inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#ae818ab0579ae490810a560a7e4209d8f">initialize</a> (int <a class="el" href="classhtgs_1_1_i_task.html#a5da9d90a63af4d99a510f6fbb1d8c803">pipelineId</a>, int numPipeline)</td></tr>
<tr class="memdesc:ae818ab0579ae490810a560a7e4209d8f inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function that is called when an <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> is being initialized by it's owner thread.  <a href="#ae818ab0579ae490810a560a7e4209d8f">More...</a><br/></td></tr>
<tr class="separator:ae818ab0579ae490810a560a7e4209d8f inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7abe254b443b32861cea2a96531dc4f inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#ac7abe254b443b32861cea2a96531dc4f">isTerminated</a> (std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_base_connector.html">BaseConnector</a> &gt; inputConnector)=0</td></tr>
<tr class="memdesc:ac7abe254b443b32861cea2a96531dc4f inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pure virtual function that is called when an <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> is checking if it can be terminated.  <a href="#ac7abe254b443b32861cea2a96531dc4f">More...</a><br/></td></tr>
<tr class="separator:ac7abe254b443b32861cea2a96531dc4f inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f3a4eb75334b0ab6c77b9a6cc4d6dd inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#af8f3a4eb75334b0ab6c77b9a6cc4d6dd">profile</a> ()</td></tr>
<tr class="memdesc:af8f3a4eb75334b0ab6c77b9a6cc4d6dd inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function that is called to provide profile output for the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a>.  <a href="#af8f3a4eb75334b0ab6c77b9a6cc4d6dd">More...</a><br/></td></tr>
<tr class="separator:af8f3a4eb75334b0ab6c77b9a6cc4d6dd inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444e6dffca20e45abc097dafb7ec3128 inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#a444e6dffca20e45abc097dafb7ec3128">getDot</a> (std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_base_connector.html">BaseConnector</a> &gt; input, std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_base_connector.html">BaseConnector</a> &gt; output)</td></tr>
<tr class="memdesc:a444e6dffca20e45abc097dafb7ec3128 inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dot notation representation for this task.  <a href="#a444e6dffca20e45abc097dafb7ec3128">More...</a><br/></td></tr>
<tr class="separator:a444e6dffca20e45abc097dafb7ec3128 inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a30e646d8122a132e8fda7f33b7096 inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#a84a30e646d8122a132e8fda7f33b7096">genDot</a> (std::string dotId, std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_base_connector.html">BaseConnector</a> &gt; input, std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_base_connector.html">BaseConnector</a> &gt; output)</td></tr>
<tr class="memdesc:a84a30e646d8122a132e8fda7f33b7096 inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function that generates the input/output and per-task dot notation.  <a href="#a84a30e646d8122a132e8fda7f33b7096">More...</a><br/></td></tr>
<tr class="separator:a84a30e646d8122a132e8fda7f33b7096 inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12454ede68b7d54ae0cc5c75b873145 inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#ad12454ede68b7d54ae0cc5c75b873145">genDot</a> (std::string dotId)</td></tr>
<tr class="memdesc:ad12454ede68b7d54ae0cc5c75b873145 inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function that adds additional dot attributes to this node.  <a href="#ad12454ede68b7d54ae0cc5c75b873145">More...</a><br/></td></tr>
<tr class="separator:ad12454ede68b7d54ae0cc5c75b873145 inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83825cf6f556b004dc54d342dd835714 inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83825cf6f556b004dc54d342dd835714"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#a83825cf6f556b004dc54d342dd835714">getDotId</a> ()</td></tr>
<tr class="memdesc:a83825cf6f556b004dc54d342dd835714 inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the id used for dot nodes. <br/></td></tr>
<tr class="separator:a83825cf6f556b004dc54d342dd835714 inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2939d44f40120253180f74207344d9e8 inherit pub_methods_classhtgs_1_1_i_task"><td class="memItemLeft" align="right" valign="top">MMType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_task.html#a2939d44f40120253180f74207344d9e8">getMemoryManagerType</a> (std::string name)</td></tr>
<tr class="memdesc:a2939d44f40120253180f74207344d9e8 inherit pub_methods_classhtgs_1_1_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the memory manager type for the specified memory manager edge name.  <a href="#a2939d44f40120253180f74207344d9e8">More...</a><br/></td></tr>
<tr class="separator:a2939d44f40120253180f74207344d9e8 inherit pub_methods_classhtgs_1_1_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhtgs_1_1_base_i_task"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhtgs_1_1_base_i_task')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhtgs_1_1_base_i_task.html">htgs::BaseITask</a></td></tr>
<tr class="memitem:a77eee9118c44ea974291cfe1693d7525 inherit pub_methods_classhtgs_1_1_base_i_task"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77eee9118c44ea974291cfe1693d7525"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_base_i_task.html#a77eee9118c44ea974291cfe1693d7525">~BaseITask</a> ()</td></tr>
<tr class="memdesc:a77eee9118c44ea974291cfe1693d7525 inherit pub_methods_classhtgs_1_1_base_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="separator:a77eee9118c44ea974291cfe1693d7525 inherit pub_methods_classhtgs_1_1_base_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef40aa7d96fcc7b3f758be2d62eda94 inherit pub_methods_classhtgs_1_1_base_i_task"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_base_i_task.html#aaef40aa7d96fcc7b3f758be2d62eda94">addRuleManager</a> (<a class="el" href="classhtgs_1_1_base_base_rule_manager.html">BaseBaseRuleManager</a> *ruleManager)</td></tr>
<tr class="memdesc:aaef40aa7d96fcc7b3f758be2d62eda94 inherit pub_methods_classhtgs_1_1_base_i_task"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function used for <a class="el" href="classhtgs_1_1_bookkeeper.html" title="Special task used to manage rules. ">Bookkeeper</a>.  <a href="#aaef40aa7d96fcc7b3f758be2d62eda94">More...</a><br/></td></tr>
<tr class="separator:aaef40aa7d96fcc7b3f758be2d62eda94 inherit pub_methods_classhtgs_1_1_base_i_task"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a1e41aadbe037089aec99fd9805e80c39"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e41aadbe037089aec99fd9805e80c39"></a>
CUcontext&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#a1e41aadbe037089aec99fd9805e80c39">context</a></td></tr>
<tr class="memdesc:a1e41aadbe037089aec99fd9805e80c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CUDA GPU context for the <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> (set after initialize) <br/></td></tr>
<tr class="separator:a1e41aadbe037089aec99fd9805e80c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e11becef7b34a87934ea336978cf5af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e11becef7b34a87934ea336978cf5af"></a>
CUstream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#a0e11becef7b34a87934ea336978cf5af">stream</a></td></tr>
<tr class="memdesc:a0e11becef7b34a87934ea336978cf5af"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CUDA stream for the <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> (set after initialize) <br/></td></tr>
<tr class="separator:a0e11becef7b34a87934ea336978cf5af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d204cf29330a6ebeb9b52f92a246b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5d204cf29330a6ebeb9b52f92a246b1"></a>
CUcontext *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#ab5d204cf29330a6ebeb9b52f92a246b1">contexts</a></td></tr>
<tr class="memdesc:ab5d204cf29330a6ebeb9b52f92a246b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array of CUDA contexts (one per GPU) <br/></td></tr>
<tr class="separator:ab5d204cf29330a6ebeb9b52f92a246b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8cdec43b08c6b3f92d2f77c2f76d40b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8cdec43b08c6b3f92d2f77c2f76d40b"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#ac8cdec43b08c6b3f92d2f77c2f76d40b">cudaIds</a></td></tr>
<tr class="memdesc:ac8cdec43b08c6b3f92d2f77c2f76d40b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array of cuda Ids (one per GPU) <br/></td></tr>
<tr class="separator:ac8cdec43b08c6b3f92d2f77c2f76d40b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace797ef51d9c5997d89002e067b52f78"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace797ef51d9c5997d89002e067b52f78"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#ace797ef51d9c5997d89002e067b52f78">numGpus</a></td></tr>
<tr class="memdesc:ace797ef51d9c5997d89002e067b52f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of GPUs. <br/></td></tr>
<tr class="separator:ace797ef51d9c5997d89002e067b52f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857caf32854f8e04a528dbc7b0151c26"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a857caf32854f8e04a528dbc7b0151c26"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#a857caf32854f8e04a528dbc7b0151c26">cudaId</a></td></tr>
<tr class="memdesc:a857caf32854f8e04a528dbc7b0151c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CudaID for the <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> (set after initialize) <br/></td></tr>
<tr class="separator:a857caf32854f8e04a528dbc7b0151c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad487f6516fa09df975d99b2a7508a1d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad487f6516fa09df975d99b2a7508a1d3"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#ad487f6516fa09df975d99b2a7508a1d3">nonPeerDevIds</a></td></tr>
<tr class="memdesc:ad487f6516fa09df975d99b2a7508a1d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of CudaIds that do not have peer-to-peer access. <br/></td></tr>
<tr class="separator:ad487f6516fa09df975d99b2a7508a1d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52704937e46c5bf120069fa9bc3e88d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52704937e46c5bf120069fa9bc3e88d3"></a>
std::unordered_map&lt; int, <br class="typebreak"/>
CUcontext &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_i_cuda_task.html#a52704937e46c5bf120069fa9bc3e88d3">peerContexts</a></td></tr>
<tr class="memdesc:a52704937e46c5bf120069fa9bc3e88d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The mapping of CudaId to CUDA Context that has peer-to-peer. <br/></td></tr>
<tr class="separator:a52704937e46c5bf120069fa9bc3e88d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, class U&gt;<br/>
class htgs::ICudaTask&lt; T, U &gt;</h3>

<p>An <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> is used to attach a task to an NVIDIA Cuda GPU. </p>
<p>The task that inherits from this class will automatically be attached to the GPU when launched by the RunTime from within a <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a>.</p>
<p>An <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> may be bound to one or more GPUs if the task is added into an <a class="el" href="classhtgs_1_1_execution_pipeline.html" title="The ExecutionPipeline class is used to duplicate task graphs, such that each duplicate executes concu...">ExecutionPipeline</a>. The number of CUContexts must match the number of pipeline specified for the <a class="el" href="classhtgs_1_1_execution_pipeline.html" title="The ExecutionPipeline class is used to duplicate task graphs, such that each duplicate executes concu...">ExecutionPipeline</a>.</p>
<p>Mechanisms to handle automatic data motion for GPU-to-GPU memories is provided to simplify peer to peer device memory copies. In order to use peer to peer copy, both GPUs must reside on the same IOH (I/O Hub) and be the same GPU model.</p>
<p>The automatic data motion function: <a class="el" href="classhtgs_1_1_i_cuda_task.html#a4a4248e1d7d15fed78692de1f09d09e7" title="Will automatically copy from one GPU to another (if it is required). ">autoCopy(V destination, std::shared_ptr&lt;MemoryData&lt;V&gt;&gt; data, long numElems)</a></p>
<p>It may be necessary to use the autocopy function if data may reside on two different GPUs. This occurs when there are ghost regions between data domains. If peer to peer copying is allowed between the multiple GPUs, then the autocopy function is not needed. See below for an example of using autocopy.</p>
<p>At this time it is necessary for the <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> to copy data from CPU memories to GPU memories.</p>
<p>Example implementation: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#define SIZE 100</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="keyword">class </span>SimpleCudaTask : <span class="keyword">public</span> <a class="code" href="classhtgs_1_1_i_cuda_task.html">htgs::ICudaTask</a>&lt;MatrixData, VoidData&gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">SimpleCudaTask(CUcontext *<a class="code" href="classhtgs_1_1_i_cuda_task.html#ab5d204cf29330a6ebeb9b52f92a246b1">contexts</a>, <span class="keywordtype">int</span> *<a class="code" href="classhtgs_1_1_i_cuda_task.html#ac8cdec43b08c6b3f92d2f77c2f76d40b">cudaIds</a>, <span class="keywordtype">int</span> <a class="code" href="classhtgs_1_1_i_cuda_task.html#ace797ef51d9c5997d89002e067b52f78">numGpus</a>) : <a class="code" href="classhtgs_1_1_i_cuda_task.html#a8da1bfa99b2dd2337e8ba4f70637060a">ICudaTask</a>(contexts, cudaIds, numGpus) { }</div>
<div class="line">~SimpleCudaTask() {}</div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classhtgs_1_1_i_cuda_task.html#a92e2383c154857534d79364af6d495e8">initializeCudaGPU</a>(CUcontext <a class="code" href="classhtgs_1_1_i_cuda_task.html#a1e41aadbe037089aec99fd9805e80c39">context</a>, CUstream <a class="code" href="classhtgs_1_1_i_cuda_task.html#a0e11becef7b34a87934ea336978cf5af">stream</a>, <span class="keywordtype">int</span> <a class="code" href="classhtgs_1_1_i_cuda_task.html#a857caf32854f8e04a528dbc7b0151c26">cudaId</a>, <span class="keywordtype">int</span> numGPUs, <span class="keywordtype">int</span> pipelineId,</div>
<div class="line">                              <span class="keywordtype">int</span> numPipelines)</div>
<div class="line">{</div>
<div class="line">   <span class="comment">// Allocate local GPU memory in initialize will allocate on correct GPU</span></div>
<div class="line">   cudaMalloc(&amp;localMemory, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>) * SIZE);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classhtgs_1_1_i_cuda_task.html#a4cf1df3dd8bb5a0c33222aabc65dc629">executeGPUTask</a>(std::shared_ptr&lt;MatrixData&gt; data, CUstream stream) {</div>
<div class="line">  ...</div>
<div class="line">  <span class="keywordtype">double</span> * memory;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Checks if the data received needs to be copied to another GPU</span></div>
<div class="line">  <span class="comment">// getCudaMemoryData is defined by the MatrixData class</span></div>
<div class="line">  <span class="keywordflow">if</span> (this-&gt;<a class="code" href="classhtgs_1_1_i_cuda_task.html#a4a4248e1d7d15fed78692de1f09d09e7">autoCopy</a>(localMemory, data-&gt;getCudaMemoryData(), SIZE))</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Copy was required</span></div>
<div class="line">    memory = localMemory;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Copy was not required because of peer to peer or same GPU</span></div>
<div class="line">    memory = data-&gt;getMemoryData()-&gt;get();</div>
<div class="line"></div>
<div class="line">  }</div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classhtgs_1_1_i_cuda_task.html#a88f66aa5e0911b851e796d6f1a7f2808">shutdownCuda</a>() { cudaFree(localMemory); }</div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classhtgs_1_1_i_cuda_task.html#a5e571a92462f5ba40f1165cc800a8bcc">debug</a>() { ... }</div>
<div class="line"><span class="keyword">virtual</span> std::string <a class="code" href="classhtgs_1_1_i_cuda_task.html#a09251c89aea49412169a5b602ef2ee49">getName</a>() { <span class="keywordflow">return</span> <span class="stringliteral">&quot;SimpleCudaTask&quot;</span>; }</div>
<div class="line"><span class="keyword">virtual</span> <a class="code" href="classhtgs_1_1_i_task.html">htgs::ITask&lt;PCIAMData, CCFData&gt;</a> *<a class="code" href="classhtgs_1_1_i_cuda_task.html#aa23de96615df6b88e3465b7ca98cc9a8">copy</a>() { <span class="keywordflow">return</span> <span class="keyword">new</span> SimpleCudaTask(...) }</div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classhtgs_1_1_i_cuda_task.html#ab2fc1acdad075a8b4e06b5c265b60b94">isTerminated</a>(std::shared_ptr&lt;htgs::BaseConnector&gt; inputConnector) { <span class="keywordflow">return</span> inputConnector-&gt;isInputTerminated(); }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">double</span> *localMemory;</div>
<div class="line"></div>
<div class="line">};</div>
</div><!-- fragment --><p>Example usage: </p>
<div class="fragment"><div class="line"><a class="code" href="classhtgs_1_1_task_graph.html">htgs::TaskGraph&lt;MatrixData, htgs::VoidData&gt;</a> *taskGraph = <span class="keyword">new</span> <a class="code" href="classhtgs_1_1_task_graph.html">htgs::TaskGraph&lt;MatrixData, htgs::VoidData&gt;</a>();</div>
<div class="line"></div>
<div class="line">SimpleCudaTask *cudaTask = <span class="keyword">new</span> SimpleCudaTask(...);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Adds cudaTask to process input from taskGraph, input type of cudaTask matches input type of taskGraph</span></div>
<div class="line">taskGraph-&gt;<a class="code" href="classhtgs_1_1_task_graph.html#ae86df3ba7ed64101ec7523a0775b7947">addGraphInputConsumer</a>(cudaTask);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the input data type for the <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a>, T must derive from <a class="el" href="classhtgs_1_1_i_data.html" title="Class to hold any type of data. ">IData</a>. </td></tr>
    <tr><td class="paramname">U</td><td>the output data type for the <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a>, U must derive from <a class="el" href="classhtgs_1_1_i_data.html" title="Class to hold any type of data. ">IData</a>. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a8da1bfa99b2dd2337e8ba4f70637060a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhtgs_1_1_i_cuda_task.html">htgs::ICudaTask</a>&lt; T, U &gt;::<a class="el" href="classhtgs_1_1_i_cuda_task.html">ICudaTask</a> </td>
          <td>(</td>
          <td class="paramtype">CUcontext *&#160;</td>
          <td class="paramname"><em>contexts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>cudaIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numGpus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a>. </p>
<p>If this task is added into an <a class="el" href="classhtgs_1_1_execution_pipeline.html" title="The ExecutionPipeline class is used to duplicate task graphs, such that each duplicate executes concu...">ExecutionPipeline</a>, then the number of CUcontexts and cudaIds should match the number of pipelines</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">contexts</td><td>the array of CUcontexts </td></tr>
    <tr><td class="paramname">cudaIds</td><td>the array of cudaIds </td></tr>
    <tr><td class="paramname">numGpus</td><td>the number of GPUs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4a4248e1d7d15fed78692de1f09d09e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<div class="memtemplate">
template&lt;class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhtgs_1_1_i_cuda_task.html">htgs::ICudaTask</a>&lt; T, U &gt;::autoCopy </td>
          <td>(</td>
          <td class="paramtype">V&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_memory_data.html">MemoryData</a>&lt; V &gt;&gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>numElems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Will automatically copy from one GPU to another (if it is required). </p>
<p>Will check if the data being copied requires to be copied first, and then execute cudaMemcpyPeerAsync if the data requires to be copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>cuda memory that can be copied into, must be a pointer </td></tr>
    <tr><td class="paramname">data</td><td>the source <a class="el" href="classhtgs_1_1_memory_data.html" title="Describes memory allocated by a MemoryManager to manage shared memory across multiple ITask...">MemoryData</a> that is allocated using a <a class="el" href="classhtgs_1_1_cuda_memory_manager.html" title="Implements a MemoryManager that binds the thread responsible for the MemoryManager to a Cuda GPU prio...">CudaMemoryManager</a> (created using taskGraph-&gt;addCudaMemoryEdge) </td></tr>
    <tr><td class="paramname">numElems</td><td>the number of elements to be copied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the copied occurred or not </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>if the copy was needed </td></tr>
    <tr><td class="paramname">FALSE</td><td>if the copy was not needed </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>a type of <a class="el" href="classhtgs_1_1_memory_data.html" title="Describes memory allocated by a MemoryManager to manage shared memory across multiple ITask...">MemoryData</a> that is allocated using a <a class="el" href="classhtgs_1_1_cuda_memory_manager.html" title="Implements a MemoryManager that binds the thread responsible for the MemoryManager to a Cuda GPU prio...">CudaMemoryManager</a> (created using taskGraph-&gt;addCudaMemoryEdge) AND must be a pointer </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classhtgs_1_1_i_cuda_task_a4a4248e1d7d15fed78692de1f09d09e7_cgraph.png" border="0" usemap="#classhtgs_1_1_i_cuda_task_a4a4248e1d7d15fed78692de1f09d09e7_cgraph" alt=""/></div>
<map name="classhtgs_1_1_i_cuda_task_a4a4248e1d7d15fed78692de1f09d09e7_cgraph" id="classhtgs_1_1_i_cuda_task_a4a4248e1d7d15fed78692de1f09d09e7_cgraph">
<area shape="rect" id="node2" href="classhtgs_1_1_i_cuda_task.html#a70470776641d6134e2dd9bd1bbe2d226" title="Checks if the requested pipelineId requires GPU&#45;to&#45;GPU copy. " alt="" coords="238,5,442,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aa23de96615df6b88e3465b7ca98cc9a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt;T, U&gt;* <a class="el" href="classhtgs_1_1_i_cuda_task.html">htgs::ICudaTask</a>&lt; T, U &gt;::copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pure virtual function that copies this <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the copy of the <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> </dd></dl>

<p>Implements <a class="el" href="classhtgs_1_1_i_task.html#acaedf1466b238036d880efcbf1feafe6">htgs::ITask&lt; T, U &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a4cf1df3dd8bb5a0c33222aabc65dc629"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classhtgs_1_1_i_cuda_task.html">htgs::ICudaTask</a>&lt; T, U &gt;::executeGPUTask </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; T &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CUstream&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pure virtual function that is called when the <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> is executing on data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the data to be executed on </td></tr>
    <tr><td class="paramname">stream</td><td>the stream to use on the data (it is the same stream passed from initializeCudaGPU) </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classhtgs_1_1_i_cuda_task_a4cf1df3dd8bb5a0c33222aabc65dc629_icgraph.png" border="0" usemap="#classhtgs_1_1_i_cuda_task_a4cf1df3dd8bb5a0c33222aabc65dc629_icgraph" alt=""/></div>
<map name="classhtgs_1_1_i_cuda_task_a4cf1df3dd8bb5a0c33222aabc65dc629_icgraph" id="classhtgs_1_1_i_cuda_task_a4cf1df3dd8bb5a0c33222aabc65dc629_icgraph">
<area shape="rect" id="node2" href="classhtgs_1_1_i_cuda_task.html#a87d73cdcbd460a8d7bb99e243577a2f6" title="Executes the ICudaTask on some data. " alt="" coords="227,12,429,39"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a87d73cdcbd460a8d7bb99e243577a2f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_i_cuda_task.html">htgs::ICudaTask</a>&lt; T, U &gt;::executeTask </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; T &gt;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes the <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> on some data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the data executed on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function should only be called by the HTGS API </dd></dl>

<p>Implements <a class="el" href="classhtgs_1_1_i_task.html#a78776a659308572e84760e6e36a2520d">htgs::ITask&lt; T, U &gt;</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classhtgs_1_1_i_cuda_task_a87d73cdcbd460a8d7bb99e243577a2f6_cgraph.png" border="0" usemap="#classhtgs_1_1_i_cuda_task_a87d73cdcbd460a8d7bb99e243577a2f6_cgraph" alt=""/></div>
<map name="classhtgs_1_1_i_cuda_task_a87d73cdcbd460a8d7bb99e243577a2f6_cgraph" id="classhtgs_1_1_i_cuda_task_a87d73cdcbd460a8d7bb99e243577a2f6_cgraph">
<area shape="rect" id="node2" href="classhtgs_1_1_i_cuda_task.html#a4cf1df3dd8bb5a0c33222aabc65dc629" title="Pure virtual function that is called when the ICudaTask is executing on data. " alt="" coords="256,5,429,46"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a0307be1be01945d299a0abdd3879cf2e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUcontext* <a class="el" href="classhtgs_1_1_i_cuda_task.html">htgs::ICudaTask</a>&lt; T, U &gt;::getContexts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the cudaContexts specified during <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> construction. </p>
<dl class="section return"><dt>Returns</dt><dd>the cudaContexts </dd></dl>

</div>
</div>
<a class="anchor" id="af8a736f5bb2a2961d7aa6b6421e9eb70"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhtgs_1_1_i_cuda_task.html">htgs::ICudaTask</a>&lt; T, U &gt;::getCudaId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the Cuda Id for this cudaTask. </p>
<p>Set only after this task has been bound to a thread during initialization. </p>
<dl class="section return"><dt>Returns</dt><dd>the cudaId associated with this cudaTask </dd></dl>

</div>
</div>
<a class="anchor" id="ac2ab6be7db24d03f6b720619e2a0a28e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int* <a class="el" href="classhtgs_1_1_i_cuda_task.html">htgs::ICudaTask</a>&lt; T, U &gt;::getCudaIds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the cudaIds specified during <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> construction. </p>
<dl class="section return"><dt>Returns</dt><dd>the cudaIds </dd></dl>

</div>
</div>
<a class="anchor" id="ab110c2bbb2e3ecc72df1ea25e4be02f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUcontext <a class="el" href="classhtgs_1_1_i_cuda_task.html">htgs::ICudaTask</a>&lt; T, U &gt;::getGPUIdContext </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the cuda Context for the given cudaId. </p>
<p>This can be used to copy between two Cuda GPUs by using cudaMemcpyPeerAsync</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the CudaContext at the given cudaId </dd></dl>

</div>
</div>
<a class="anchor" id="a09251c89aea49412169a5b602ef2ee49"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string <a class="el" href="classhtgs_1_1_i_cuda_task.html">htgs::ICudaTask</a>&lt; T, U &gt;::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual function that gets the name of this <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the name of the <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classhtgs_1_1_i_task.html#a5dda5ecd5e72ad43cf1d76de04e89e4b">htgs::ITask&lt; T, U &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a68d4a6b432c5db024c00320674d4a71d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhtgs_1_1_i_cuda_task.html">htgs::ICudaTask</a>&lt; T, U &gt;::getNumGPUs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of GPUs specified during <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> construction. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of GPUs </dd></dl>

</div>
</div>
<a class="anchor" id="a438e9f9befc1db05c3545a05125c9f84"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CUcontext <a class="el" href="classhtgs_1_1_i_cuda_task.html">htgs::ICudaTask</a>&lt; T, U &gt;::getTaskCudaContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the CudaContext associated with this task. </p>
<p>Set only after this task has been bound to a thread during initialization. </p>
<dl class="section return"><dt>Returns</dt><dd>the Cuda Context </dd></dl>

</div>
</div>
<a class="anchor" id="a2d5770e50a2e5c9fc669386dc40f6502"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhtgs_1_1_i_cuda_task.html">htgs::ICudaTask</a>&lt; T, U &gt;::hasPeerToPeerCopy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pipelineId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the requested pipelineId allows peer to peer GPU copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipelineId</td><td>the pipelineId to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the pipeline id has peer to peer GPU copy </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>if the pipeline id has peer to peer GPU copy </td></tr>
    <tr><td class="paramname">FALSE</td><td>if the pipeline id has peer to peer GPU copy </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classhtgs_1_1_i_cuda_task_a2d5770e50a2e5c9fc669386dc40f6502_cgraph.png" border="0" usemap="#classhtgs_1_1_i_cuda_task_a2d5770e50a2e5c9fc669386dc40f6502_cgraph" alt=""/></div>
<map name="classhtgs_1_1_i_cuda_task_a2d5770e50a2e5c9fc669386dc40f6502_cgraph" id="classhtgs_1_1_i_cuda_task_a2d5770e50a2e5c9fc669386dc40f6502_cgraph">
<area shape="rect" id="node2" href="classhtgs_1_1_i_cuda_task.html#a70470776641d6134e2dd9bd1bbe2d226" title="Checks if the requested pipelineId requires GPU&#45;to&#45;GPU copy. " alt="" coords="230,12,434,39"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a2bc639a73a9a4974f5e5f5a66a5cf5c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_i_cuda_task.html">htgs::ICudaTask</a>&lt; T, U &gt;::initialize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pipelineId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numPipeline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_task_scheduler.html">TaskScheduler</a>&lt; T, U &gt; *&#160;</td>
          <td class="paramname"><em>ownerTask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; std::vector&lt; std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_base_connector.html">BaseConnector</a> &gt;&gt;&gt;&#160;</td>
          <td class="paramname"><em>pipelineConnectorList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the CudaTask to be bound to a particular GPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipelineId</td><td>the pipelineId of the task </td></tr>
    <tr><td class="paramname">numPipeline</td><td>the number of pipelines </td></tr>
    <tr><td class="paramname">ownerTask</td><td>the owner of the task </td></tr>
    <tr><td class="paramname">pipelineConnectorList</td><td>the list of connectors that connect to other duplicate <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a>'s in an execution pipeline</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function should only be called by the HTGS API </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classhtgs_1_1_i_cuda_task_a2bc639a73a9a4974f5e5f5a66a5cf5c5_cgraph.png" border="0" usemap="#classhtgs_1_1_i_cuda_task_a2bc639a73a9a4974f5e5f5a66a5cf5c5_cgraph" alt=""/></div>
<map name="classhtgs_1_1_i_cuda_task_a2bc639a73a9a4974f5e5f5a66a5cf5c5_cgraph" id="classhtgs_1_1_i_cuda_task_a2bc639a73a9a4974f5e5f5a66a5cf5c5_cgraph">
<area shape="rect" id="node2" href="classhtgs_1_1_i_cuda_task.html#a92e2383c154857534d79364af6d495e8" title="Virtual function that is called when the ICudaTask has been initialized. " alt="" coords="230,5,405,46"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a92e2383c154857534d79364af6d495e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classhtgs_1_1_i_cuda_task.html">htgs::ICudaTask</a>&lt; T, U &gt;::initializeCudaGPU </td>
          <td>(</td>
          <td class="paramtype">CUcontext&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CUstream&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cudaId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numGPUs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pipelineId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numPipelines</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual function that is called when the <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> has been initialized. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>the Cuda GPU context associated with this task </td></tr>
    <tr><td class="paramname">stream</td><td>the Cuda stream associated with this task </td></tr>
    <tr><td class="paramname">cudaId</td><td>the cuda ID associated with this task </td></tr>
    <tr><td class="paramname">numGPUs</td><td>the number GPUs available </td></tr>
    <tr><td class="paramname">pipelineId</td><td>the execution pipeline Id </td></tr>
    <tr><td class="paramname">numPipelines</td><td>the number of execution pipelines </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classhtgs_1_1_i_cuda_task_a92e2383c154857534d79364af6d495e8_icgraph.png" border="0" usemap="#classhtgs_1_1_i_cuda_task_a92e2383c154857534d79364af6d495e8_icgraph" alt=""/></div>
<map name="classhtgs_1_1_i_cuda_task_a92e2383c154857534d79364af6d495e8_icgraph" id="classhtgs_1_1_i_cuda_task_a92e2383c154857534d79364af6d495e8_icgraph">
<area shape="rect" id="node2" href="classhtgs_1_1_i_cuda_task.html#a2bc639a73a9a4974f5e5f5a66a5cf5c5" title="Initializes the CudaTask to be bound to a particular GPU. " alt="" coords="230,12,405,39"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ab2fc1acdad075a8b4e06b5c265b60b94"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classhtgs_1_1_i_cuda_task.html">htgs::ICudaTask</a>&lt; T, U &gt;::isTerminated </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_base_connector.html">htgs::BaseConnector</a> &gt;&#160;</td>
          <td class="paramname"><em>inputConnector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pure virtual function that checks whether this <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a> is terminated or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputConnector</td><td>the input <a class="el" href="classhtgs_1_1_connector.html" title="Manages the input/output of IData between Tasks. ">Connector</a> associated with this task </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the task can be terminated or not </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>if the task can be terminated </td></tr>
    <tr><td class="paramname">FALSE</td><td>if the task cannot be terminated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>inputConnector-&gt;isInputTerminated() can be used to identify if the input has finished producing data </dd></dl>

</div>
</div>
<a class="anchor" id="a70470776641d6134e2dd9bd1bbe2d226"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhtgs_1_1_i_cuda_task.html">htgs::ICudaTask</a>&lt; T, U &gt;::requiresCopy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pipelineId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the requested pipelineId requires GPU-to-GPU copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipelineId</td><td>the <a class="el" href="classhtgs_1_1_execution_pipeline.html" title="The ExecutionPipeline class is used to duplicate task graphs, such that each duplicate executes concu...">ExecutionPipeline</a> id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the requested pipelineId would require a GPU-to-GPU copy </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>if copy is required </td></tr>
    <tr><td class="paramname">FALSE</td><td>if copy is not required </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classhtgs_1_1_i_cuda_task_a70470776641d6134e2dd9bd1bbe2d226_icgraph.png" border="0" usemap="#classhtgs_1_1_i_cuda_task_a70470776641d6134e2dd9bd1bbe2d226_icgraph" alt=""/></div>
<map name="classhtgs_1_1_i_cuda_task_a70470776641d6134e2dd9bd1bbe2d226_icgraph" id="classhtgs_1_1_i_cuda_task_a70470776641d6134e2dd9bd1bbe2d226_icgraph">
<area shape="rect" id="node2" href="classhtgs_1_1_i_cuda_task.html#a0ed21dd37fe3fcaabcd5e69604f93c8a" title="Checks if the requested pipelineId requires GPU&#45;to&#45;GPU copy. " alt="" coords="259,5,463,32"/><area shape="rect" id="node3" href="classhtgs_1_1_i_cuda_task.html#a2d5770e50a2e5c9fc669386dc40f6502" title="Checks if the requested pipelineId allows peer to peer GPU copy. " alt="" coords="274,57,449,98"/><area shape="rect" id="node4" href="classhtgs_1_1_i_cuda_task.html#a4a4248e1d7d15fed78692de1f09d09e7" title="Will automatically copy from one GPU to another (if it is required). " alt="" coords="270,123,453,149"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a0ed21dd37fe3fcaabcd5e69604f93c8a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<div class="memtemplate">
template&lt;class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhtgs_1_1_i_cuda_task.html">htgs::ICudaTask</a>&lt; T, U &gt;::requiresCopy </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_memory_data.html">MemoryData</a>&lt; V &gt;&gt;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the requested pipelineId requires GPU-to-GPU copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the memory data to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the requested <a class="el" href="classhtgs_1_1_memory_data.html" title="Describes memory allocated by a MemoryManager to manage shared memory across multiple ITask...">MemoryData</a> would require GPU-to-GPU copy </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>if copy is required </td></tr>
    <tr><td class="paramname">FALSE</td><td>if copy is not required </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>a type of <a class="el" href="classhtgs_1_1_memory_data.html" title="Describes memory allocated by a MemoryManager to manage shared memory across multiple ITask...">MemoryData</a> that is allocated using a <a class="el" href="classhtgs_1_1_cuda_memory_manager.html" title="Implements a MemoryManager that binds the thread responsible for the MemoryManager to a Cuda GPU prio...">CudaMemoryManager</a> (created using taskGraph-&gt;addCudaMemoryEdge) </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classhtgs_1_1_i_cuda_task_a0ed21dd37fe3fcaabcd5e69604f93c8a_cgraph.png" border="0" usemap="#classhtgs_1_1_i_cuda_task_a0ed21dd37fe3fcaabcd5e69604f93c8a_cgraph" alt=""/></div>
<map name="classhtgs_1_1_i_cuda_task_a0ed21dd37fe3fcaabcd5e69604f93c8a_cgraph" id="classhtgs_1_1_i_cuda_task_a0ed21dd37fe3fcaabcd5e69604f93c8a_cgraph">
<area shape="rect" id="node2" href="classhtgs_1_1_i_cuda_task.html#a70470776641d6134e2dd9bd1bbe2d226" title="Checks if the requested pipelineId requires GPU&#45;to&#45;GPU copy. " alt="" coords="259,5,463,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a385f5cff3117b8a774e67fea02a12922"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_i_cuda_task.html">htgs::ICudaTask</a>&lt; T, U &gt;::shutdown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shutsdown the <a class="el" href="classhtgs_1_1_i_cuda_task.html" title="An ICudaTask is used to attach a task to an NVIDIA Cuda GPU. ">ICudaTask</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This function should only be called by the HTGS API </dd></dl>

<p>Reimplemented from <a class="el" href="classhtgs_1_1_i_task.html#a248459b62405a6ea5bb733e2ddece2ef">htgs::ITask&lt; T, U &gt;</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classhtgs_1_1_i_cuda_task_a385f5cff3117b8a774e67fea02a12922_cgraph.png" border="0" usemap="#classhtgs_1_1_i_cuda_task_a385f5cff3117b8a774e67fea02a12922_cgraph" alt=""/></div>
<map name="classhtgs_1_1_i_cuda_task_a385f5cff3117b8a774e67fea02a12922_cgraph" id="classhtgs_1_1_i_cuda_task_a385f5cff3117b8a774e67fea02a12922_cgraph">
<area shape="rect" id="node2" href="classhtgs_1_1_i_cuda_task.html#a88f66aa5e0911b851e796d6f1a7f2808" title="Virtual function that is called when the ICudaTask is shutting down. " alt="" coords="238,5,453,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aa544d0fc6b744646a2e195a0a0383915"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_i_cuda_task.html">htgs::ICudaTask</a>&lt; T, U &gt;::syncStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronizes the Cuda stream associated with this task. </p>
<dl class="section note"><dt>Note</dt><dd>Should only be called after initialization </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/tjb3/phd-research/HTGS/src/htgs/api/<a class="el" href="_i_cuda_task_8hpp_source.html">ICudaTask.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>htgs</b></li><li class="navelem"><a class="el" href="classhtgs_1_1_i_cuda_task.html">ICudaTask</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
