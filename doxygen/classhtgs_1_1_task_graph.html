<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>htgs: htgs::TaskGraph&lt; V, W &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">htgs
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classhtgs_1_1_task_graph.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classhtgs_1_1_task_graph-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">htgs::TaskGraph&lt; V, W &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Manages a group of connected ITasks and their connections.  
 <a href="classhtgs_1_1_task_graph.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_task_graph_8hpp_source.html">htgs/api/TaskGraph.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for htgs::TaskGraph&lt; V, W &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classhtgs_1_1_task_graph__inherit__graph.png" border="0" usemap="#htgs_1_1_task_graph_3_01_v_00_01_w_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="htgs_1_1_task_graph_3_01_v_00_01_w_01_4_inherit__map" id="htgs_1_1_task_graph_3_01_v_00_01_w_01_4_inherit__map">
<area shape="rect" id="node2" href="classhtgs_1_1_any_task_graph.html" title="{htgs::AnyTaskGraph\n|&#45; taskCopyMap\l&#45; taskManagers\l&#45; pipelineId\l&#45; numPipelines\l|+ AnyTaskGraph()\l+ ~AnyTaskGraph()\l+ getTaskManagers()\l+ getCopy()\l+ getCopy()\l+ getTaskManager()\l+ addTaskManager()\l+ getPipelineId()\l+ getNumPipelines()\l+ getGraphConsumerTaskManager()\land 10 more...\l&#45; createCopy()\l}" alt="" coords="19,5,261,288"/></map>
</div>
<div class="dynheader">
Collaboration diagram for htgs::TaskGraph&lt; V, W &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classhtgs_1_1_task_graph__coll__graph.png" border="0" usemap="#htgs_1_1_task_graph_3_01_v_00_01_w_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="htgs_1_1_task_graph_3_01_v_00_01_w_01_4_coll__map" id="htgs_1_1_task_graph_3_01_v_00_01_w_01_4_coll__map">
<area shape="rect" id="node2" href="classhtgs_1_1_any_task_graph.html" title="{htgs::AnyTaskGraph\n|&#45; taskCopyMap\l&#45; taskManagers\l&#45; pipelineId\l&#45; numPipelines\l|+ AnyTaskGraph()\l+ ~AnyTaskGraph()\l+ getTaskManagers()\l+ getCopy()\l+ getCopy()\l+ getTaskManager()\l+ addTaskManager()\l+ getPipelineId()\l+ getNumPipelines()\l+ getGraphConsumerTaskManager()\land 10 more...\l&#45; createCopy()\l}" alt="" coords="5,49,248,332"/><area shape="rect" id="node3" href="classhtgs_1_1_any_task_scheduler.html" title="The parent class for a Task that removes the template arguments. " alt="" coords="272,5,436,376"/></map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aae29ebfc63282162af4e88eaf4c103c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae29ebfc63282162af4e88eaf4c103c9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph.html#aae29ebfc63282162af4e88eaf4c103c9">TaskGraph</a> ()</td></tr>
<tr class="memdesc:aae29ebfc63282162af4e88eaf4c103c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a>. <br /></td></tr>
<tr class="separator:aae29ebfc63282162af4e88eaf4c103c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e88c706326e36faf5cc705c1d7ed345"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e88c706326e36faf5cc705c1d7ed345"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph.html#a5e88c706326e36faf5cc705c1d7ed345">TaskGraph</a> (size_t <a class="el" href="classhtgs_1_1_any_task_graph.html#adb3a8cf583ac0b03687c2e37f85b3616">pipelineId</a>, size_t <a class="el" href="classhtgs_1_1_any_task_graph.html#aa22ef2947e9b30e47c83701acfc06b5b">numPipelines</a>)</td></tr>
<tr class="memdesc:a5e88c706326e36faf5cc705c1d7ed345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a>. <br /></td></tr>
<tr class="separator:a5e88c706326e36faf5cc705c1d7ed345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89bcb6c378447e939df51b49a2c07ce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph.html#ad89bcb6c378447e939df51b49a2c07ce">~TaskGraph</a> () override</td></tr>
<tr class="memdesc:ad89bcb6c378447e939df51b49a2c07ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a> with the specified input and output <a class="el" href="classhtgs_1_1_connector.html" title="Manages the input/output of IData between Tasks. ">Connector</a>.  <a href="#ad89bcb6c378447e939df51b49a2c07ce">More...</a><br /></td></tr>
<tr class="separator:ad89bcb6c378447e939df51b49a2c07ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2a4e1fa69402f51f251298d7461afd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf2a4e1fa69402f51f251298d7461afd"></a>
<a class="el" href="classhtgs_1_1_task_graph.html">TaskGraph</a>&lt; T, U &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>copy</b> (size_t <a class="el" href="classhtgs_1_1_any_task_graph.html#adb3a8cf583ac0b03687c2e37f85b3616">pipelineId</a>, size_t <a class="el" href="classhtgs_1_1_any_task_graph.html#aa22ef2947e9b30e47c83701acfc06b5b">numPipelines</a>)</td></tr>
<tr class="separator:acf2a4e1fa69402f51f251298d7461afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af619fa1ac41e149ca674441ca1fdd0f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af619fa1ac41e149ca674441ca1fdd0f3"></a>
<a class="el" href="classhtgs_1_1_task_graph.html">TaskGraph</a>&lt; T, U &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>copy</b> (size_t <a class="el" href="classhtgs_1_1_any_task_graph.html#adb3a8cf583ac0b03687c2e37f85b3616">pipelineId</a>, size_t <a class="el" href="classhtgs_1_1_any_task_graph.html#aa22ef2947e9b30e47c83701acfc06b5b">numPipelines</a>, std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_connector.html">Connector</a>&lt; T &gt;&gt; <a class="el" href="classhtgs_1_1_task_graph.html#a839fa5eee17aa8dde3e25586984c5369">input</a>, std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_connector.html">Connector</a>&lt; U &gt;&gt; <a class="el" href="classhtgs_1_1_task_graph.html#a7c35ca0b3e8f5e33f276479210e28320">output</a>)</td></tr>
<tr class="separator:af619fa1ac41e149ca674441ca1fdd0f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a428a714464c9c757668d3544c4328"><td class="memTemplParams" colspan="2"><a class="anchor" id="a88a428a714464c9c757668d3544c4328"></a>
template&lt;class V , class W , class X &gt; </td></tr>
<tr class="memitem:a88a428a714464c9c757668d3544c4328"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>addEdge</b> (<a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt; V, W &gt; *producer, <a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt; W, X &gt; *consumer)</td></tr>
<tr class="separator:a88a428a714464c9c757668d3544c4328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48eb58d67c5e37c3f23d2a6d37549614"><td class="memTemplParams" colspan="2"><a class="anchor" id="a48eb58d67c5e37c3f23d2a6d37549614"></a>
template&lt;class V , class IRuleType , class W , class X &gt; </td></tr>
<tr class="memitem:a48eb58d67c5e37c3f23d2a6d37549614"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>addRuleEdge</b> (<a class="el" href="classhtgs_1_1_bookkeeper.html">Bookkeeper</a>&lt; V &gt; *bookkeeper, std::shared_ptr&lt; IRuleType &gt; rule, <a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt; W, X &gt; *consumer)</td></tr>
<tr class="separator:a48eb58d67c5e37c3f23d2a6d37549614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85eb1e4c7ffd8732046a2ec0a37a91a6"><td class="memTemplParams" colspan="2">template&lt;class IMemoryAllocatorType &gt; </td></tr>
<tr class="memitem:a85eb1e4c7ffd8732046a2ec0a37a91a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph.html#a85eb1e4c7ffd8732046a2ec0a37a91a6">addCudaMemoryManagerEdge</a> (std::string name, <a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *memoryEdges, <a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *releaseMemoryEdges, std::shared_ptr&lt; IMemoryAllocatorType &gt; allocator, size_t memoryPoolSize, MMType type, CUcontext *contexts)</td></tr>
<tr class="memdesc:a85eb1e4c7ffd8732046a2ec0a37a91a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a <a class="el" href="classhtgs_1_1_cuda_memory_manager.html" title="Implements a MemoryManager that binds the thread responsible for the MemoryManager to a Cuda GPU prio...">CudaMemoryManager</a> edge with the specified name to the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a>.  <a href="#a85eb1e4c7ffd8732046a2ec0a37a91a6">More...</a><br /></td></tr>
<tr class="separator:a85eb1e4c7ffd8732046a2ec0a37a91a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb08f2cdf202215129b6f2b2d9e59ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph.html#afeb08f2cdf202215129b6f2b2d9e59ab">addUserManagedMemoryManagerEdge</a> (std::string name, <a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *getMemoryTask, <a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *releaseMemoryTask, size_t memoryPoolSize)</td></tr>
<tr class="memdesc:afeb08f2cdf202215129b6f2b2d9e59ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">MemoryManager</a> that is managed by the user.  <a href="#afeb08f2cdf202215129b6f2b2d9e59ab">More...</a><br /></td></tr>
<tr class="separator:afeb08f2cdf202215129b6f2b2d9e59ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b84e93e1a7221ffa0d4b35b55e817f9"><td class="memTemplParams" colspan="2">template&lt;class V , class IMemoryAllocatorType &gt; </td></tr>
<tr class="memitem:a1b84e93e1a7221ffa0d4b35b55e817f9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph.html#a1b84e93e1a7221ffa0d4b35b55e817f9">addMemoryManagerEdge</a> (std::string name, <a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *getMemoryTask, <a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *releaseMemoryTask, std::shared_ptr&lt; IMemoryAllocatorType &gt; allocator, size_t memoryPoolSize, MMType type)</td></tr>
<tr class="memdesc:a1b84e93e1a7221ffa0d4b35b55e817f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">MemoryManager</a> edge with the specified name to the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a>.  <a href="#a1b84e93e1a7221ffa0d4b35b55e817f9">More...</a><br /></td></tr>
<tr class="separator:a1b84e93e1a7221ffa0d4b35b55e817f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a597efee49344940e51fd72cfb3cc5834"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a597efee49344940e51fd72cfb3cc5834"></a>
<a class="el" href="classhtgs_1_1_any_task_scheduler.html">AnyTaskScheduler</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getGraphConsumerTaskManager</b> () override</td></tr>
<tr class="separator:a597efee49344940e51fd72cfb3cc5834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1802217cc0a6af96ff897ccbd523a63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1802217cc0a6af96ff897ccbd523a63"></a>
<a class="el" href="classhtgs_1_1_any_task_scheduler.html">AnyTaskScheduler</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getGraphProducerTaskManager</b> () override</td></tr>
<tr class="separator:af1802217cc0a6af96ff897ccbd523a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a913c4977cd3aceccebcef783f0ca0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55a913c4977cd3aceccebcef783f0ca0"></a>
std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_any_connector.html">AnyConnector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getInputConnector</b> () override</td></tr>
<tr class="separator:a55a913c4977cd3aceccebcef783f0ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb58e7967da1f0a82782559b29076b75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb58e7967da1f0a82782559b29076b75"></a>
std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_any_connector.html">AnyConnector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getOutputConnector</b> () override</td></tr>
<tr class="separator:abb58e7967da1f0a82782559b29076b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb08b50ed8481daf4a3d3aa36103e2ee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb08b50ed8481daf4a3d3aa36103e2ee"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setInputConnector</b> (std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_connector.html">Connector</a>&lt; T &gt;&gt; <a class="el" href="classhtgs_1_1_task_graph.html#a839fa5eee17aa8dde3e25586984c5369">input</a>)</td></tr>
<tr class="separator:acb08b50ed8481daf4a3d3aa36103e2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1426d958ef336a6107d076fd727e7c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1426d958ef336a6107d076fd727e7c7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setOutputConnector</b> (std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_connector.html">Connector</a>&lt; T &gt;&gt; <a class="el" href="classhtgs_1_1_task_graph.html#a7c35ca0b3e8f5e33f276479210e28320">output</a>)</td></tr>
<tr class="separator:ae1426d958ef336a6107d076fd727e7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f69fd5382629917c0ea5e46dc76eec0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f69fd5382629917c0ea5e46dc76eec0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>incrementGraphProducer</b> ()</td></tr>
<tr class="separator:a9f69fd5382629917c0ea5e46dc76eec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80fa90c151d52115cec2b112fc372fb3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80fa90c151d52115cec2b112fc372fb3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>finishedProducingData</b> ()</td></tr>
<tr class="separator:a80fa90c151d52115cec2b112fc372fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa190217baa270d3e754af63aafaf78ef"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa190217baa270d3e754af63aafaf78ef"></a>
template&lt;class W &gt; </td></tr>
<tr class="memitem:aa190217baa270d3e754af63aafaf78ef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>setGraphConsumerTask</b> (<a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt; T, W &gt; *task)</td></tr>
<tr class="separator:aa190217baa270d3e754af63aafaf78ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed2a0b2e1099555ac185edcdfae1584"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2ed2a0b2e1099555ac185edcdfae1584"></a>
template&lt;class W &gt; </td></tr>
<tr class="memitem:a2ed2a0b2e1099555ac185edcdfae1584"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>setGraphProducerTask</b> (<a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt; W, U &gt; *task)</td></tr>
<tr class="separator:a2ed2a0b2e1099555ac185edcdfae1584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b4bb176539081a1a74428aaa337ed5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph.html#a15b4bb176539081a1a74428aaa337ed5">produceData</a> (T *data)</td></tr>
<tr class="memdesc:a15b4bb176539081a1a74428aaa337ed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces data for the input of the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a>.  <a href="#a15b4bb176539081a1a74428aaa337ed5">More...</a><br /></td></tr>
<tr class="separator:a15b4bb176539081a1a74428aaa337ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d896acdc5a27ed9db6340cd2b5995ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph.html#a2d896acdc5a27ed9db6340cd2b5995ed">produceData</a> (std::shared_ptr&lt; T &gt; data)</td></tr>
<tr class="memdesc:a2d896acdc5a27ed9db6340cd2b5995ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces data for the input of the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a>.  <a href="#a2d896acdc5a27ed9db6340cd2b5995ed">More...</a><br /></td></tr>
<tr class="separator:a2d896acdc5a27ed9db6340cd2b5995ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538cbbc552965902fec6faac67766fbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph.html#a538cbbc552965902fec6faac67766fbf">produceData</a> (std::list&lt; std::shared_ptr&lt; T &gt;&gt; *dataList)</td></tr>
<tr class="memdesc:a538cbbc552965902fec6faac67766fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a list of data into the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a> Must specify the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a> input using addGraphInputConsumer() and use incrementGraphInputProducer() to indicate an input stream is feeding data to the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a>.  <a href="#a538cbbc552965902fec6faac67766fbf">More...</a><br /></td></tr>
<tr class="separator:a538cbbc552965902fec6faac67766fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa222a7e8f5d3fe0a29bfb85e90203c34"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; U &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph.html#aa222a7e8f5d3fe0a29bfb85e90203c34">consumeData</a> ()</td></tr>
<tr class="memdesc:aa222a7e8f5d3fe0a29bfb85e90203c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumes data from the output of a <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a>.  <a href="#aa222a7e8f5d3fe0a29bfb85e90203c34">More...</a><br /></td></tr>
<tr class="separator:aa222a7e8f5d3fe0a29bfb85e90203c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994884edaae94574d64ee9fd5d0fd7a4"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; U &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph.html#a994884edaae94574d64ee9fd5d0fd7a4">pollData</a> (long microTimeout)</td></tr>
<tr class="memdesc:a994884edaae94574d64ee9fd5d0fd7a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polls for data from the output of the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a>.  <a href="#a994884edaae94574d64ee9fd5d0fd7a4">More...</a><br /></td></tr>
<tr class="separator:a994884edaae94574d64ee9fd5d0fd7a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad46b99c6a98747464100e1a739a419"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph.html#a0ad46b99c6a98747464100e1a739a419">isOutputTerminated</a> ()</td></tr>
<tr class="memdesc:a0ad46b99c6a98747464100e1a739a419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the output of the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a> has finished producing data.  <a href="#a0ad46b99c6a98747464100e1a739a419">More...</a><br /></td></tr>
<tr class="separator:a0ad46b99c6a98747464100e1a739a419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhtgs_1_1_any_task_graph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhtgs_1_1_any_task_graph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhtgs_1_1_any_task_graph.html">htgs::AnyTaskGraph</a></td></tr>
<tr class="memitem:a40ec30f59265136813fd6ced92620560 inherit pub_methods_classhtgs_1_1_any_task_graph"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40ec30f59265136813fd6ced92620560"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AnyTaskGraph</b> (size_t <a class="el" href="classhtgs_1_1_any_task_graph.html#adb3a8cf583ac0b03687c2e37f85b3616">pipelineId</a>, size_t <a class="el" href="classhtgs_1_1_any_task_graph.html#aa22ef2947e9b30e47c83701acfc06b5b">numPipelines</a>)</td></tr>
<tr class="separator:a40ec30f59265136813fd6ced92620560 inherit pub_methods_classhtgs_1_1_any_task_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e2c111406e04640fd8841658cca55a0 inherit pub_methods_classhtgs_1_1_any_task_graph"><td class="memItemLeft" align="right" valign="top">virtual std::list<br class="typebreak" />
&lt; <a class="el" href="classhtgs_1_1_any_task_scheduler.html">AnyTaskScheduler</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph.html#a5e2c111406e04640fd8841658cca55a0">getTaskManagers</a> ()</td></tr>
<tr class="memdesc:a5e2c111406e04640fd8841658cca55a0 inherit pub_methods_classhtgs_1_1_any_task_graph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pure virtual function to get the vertices of the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a>.  <a href="#a5e2c111406e04640fd8841658cca55a0">More...</a><br /></td></tr>
<tr class="separator:a5e2c111406e04640fd8841658cca55a0 inherit pub_methods_classhtgs_1_1_any_task_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15416adde567e024913e2132d63f565 inherit pub_methods_classhtgs_1_1_any_task_graph"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa15416adde567e024913e2132d63f565"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:aa15416adde567e024913e2132d63f565 inherit pub_methods_classhtgs_1_1_any_task_graph"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt; T, U &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getCopy</b> (<a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt; T, U &gt; *orig)</td></tr>
<tr class="separator:aa15416adde567e024913e2132d63f565 inherit pub_methods_classhtgs_1_1_any_task_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87ef4d9e12af0a9f50f6a24f02deefb inherit pub_methods_classhtgs_1_1_any_task_graph"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab87ef4d9e12af0a9f50f6a24f02deefb"></a>
<a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getCopy</b> (<a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *orig)</td></tr>
<tr class="separator:ab87ef4d9e12af0a9f50f6a24f02deefb inherit pub_methods_classhtgs_1_1_any_task_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e351bfe7021489eb38e207fea8e9e82 inherit pub_methods_classhtgs_1_1_any_task_graph"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9e351bfe7021489eb38e207fea8e9e82"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a9e351bfe7021489eb38e207fea8e9e82 inherit pub_methods_classhtgs_1_1_any_task_graph"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhtgs_1_1_task_scheduler.html">TaskScheduler</a>&lt; T, U &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getTaskManager</b> (<a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt; T, U &gt; *task)</td></tr>
<tr class="separator:a9e351bfe7021489eb38e207fea8e9e82 inherit pub_methods_classhtgs_1_1_any_task_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95fa40064b78f9cb0e7a871d92ad6273 inherit pub_methods_classhtgs_1_1_any_task_graph"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95fa40064b78f9cb0e7a871d92ad6273"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addTaskManager</b> (<a class="el" href="classhtgs_1_1_any_task_scheduler.html">AnyTaskScheduler</a> *taskScheduler)</td></tr>
<tr class="separator:a95fa40064b78f9cb0e7a871d92ad6273 inherit pub_methods_classhtgs_1_1_any_task_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be17d4d4230d5d1d4cf837f8343d2a0 inherit pub_methods_classhtgs_1_1_any_task_graph"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0be17d4d4230d5d1d4cf837f8343d2a0"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>getPipelineId</b> ()</td></tr>
<tr class="separator:a0be17d4d4230d5d1d4cf837f8343d2a0 inherit pub_methods_classhtgs_1_1_any_task_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912591c29b6fc557da34d07493946deb inherit pub_methods_classhtgs_1_1_any_task_graph"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a912591c29b6fc557da34d07493946deb"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>getNumPipelines</b> ()</td></tr>
<tr class="separator:a912591c29b6fc557da34d07493946deb inherit pub_methods_classhtgs_1_1_any_task_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ce9a303fbd7087d0843a8e9034cc62 inherit pub_methods_classhtgs_1_1_any_task_graph"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph.html#a83ce9a303fbd7087d0843a8e9034cc62">writeDotToFile</a> (std::string file)</td></tr>
<tr class="memdesc:a83ce9a303fbd7087d0843a8e9034cc62 inherit pub_methods_classhtgs_1_1_any_task_graph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the dot representation of the task graph to disk.  <a href="#a83ce9a303fbd7087d0843a8e9034cc62">More...</a><br /></td></tr>
<tr class="separator:a83ce9a303fbd7087d0843a8e9034cc62 inherit pub_methods_classhtgs_1_1_any_task_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbed0cc1cadeef9c845de8050be1a254 inherit pub_methods_classhtgs_1_1_any_task_graph"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abbed0cc1cadeef9c845de8050be1a254"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>writeDotToFile</b> (std::string file, int flags)</td></tr>
<tr class="separator:abbed0cc1cadeef9c845de8050be1a254 inherit pub_methods_classhtgs_1_1_any_task_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a94e3fe7c1b62ac5eab1e2eb91c573 inherit pub_methods_classhtgs_1_1_any_task_graph"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53a94e3fe7c1b62ac5eab1e2eb91c573"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph.html#a53a94e3fe7c1b62ac5eab1e2eb91c573">genDotGraphContent</a> (int flags)</td></tr>
<tr class="memdesc:a53a94e3fe7c1b62ac5eab1e2eb91c573 inherit pub_methods_classhtgs_1_1_any_task_graph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the content only of the graph (excludes all graph definitions and attributes) <br /></td></tr>
<tr class="separator:a53a94e3fe7c1b62ac5eab1e2eb91c573 inherit pub_methods_classhtgs_1_1_any_task_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69618bf97f0cd06ab6344e1c998323b1 inherit pub_methods_classhtgs_1_1_any_task_graph"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69618bf97f0cd06ab6344e1c998323b1"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph.html#a69618bf97f0cd06ab6344e1c998323b1">genDotGraph</a> (int flags)</td></tr>
<tr class="memdesc:a69618bf97f0cd06ab6344e1c998323b1 inherit pub_methods_classhtgs_1_1_any_task_graph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the dot graph as a string. <br /></td></tr>
<tr class="separator:a69618bf97f0cd06ab6344e1c998323b1 inherit pub_methods_classhtgs_1_1_any_task_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae007a83d57ccaa22720b9b40c8b18e28 inherit pub_methods_classhtgs_1_1_any_task_graph"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae007a83d57ccaa22720b9b40c8b18e28"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>copyTasks</b> (std::list&lt; <a class="el" href="classhtgs_1_1_any_task_scheduler.html">AnyTaskScheduler</a> * &gt; *tasks)</td></tr>
<tr class="separator:ae007a83d57ccaa22720b9b40c8b18e28 inherit pub_methods_classhtgs_1_1_any_task_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462eedea1889f22fc3a3c5cd730af2b3 inherit pub_methods_classhtgs_1_1_any_task_graph"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a462eedea1889f22fc3a3c5cd730af2b3"></a>
<a class="el" href="classhtgs_1_1_any_task_scheduler.html">AnyTaskScheduler</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getTaskManagerCopy</b> (<a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *iTask)</td></tr>
<tr class="separator:a462eedea1889f22fc3a3c5cd730af2b3 inherit pub_methods_classhtgs_1_1_any_task_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6febb0cd575f0e1dad4e55ee085dbad4 inherit pub_methods_classhtgs_1_1_any_task_graph"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6febb0cd575f0e1dad4e55ee085dbad4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasTask</b> (<a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *task)</td></tr>
<tr class="separator:a6febb0cd575f0e1dad4e55ee085dbad4 inherit pub_methods_classhtgs_1_1_any_task_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a9530b9db723598005535c53049a9c24e"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="classhtgs_1_1_edge_descriptor.html">EdgeDescriptor</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph.html#a9530b9db723598005535c53049a9c24e">edges</a></td></tr>
<tr class="memdesc:a9530b9db723598005535c53049a9c24e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the dot representation of the task graph to disk.  <a href="#a9530b9db723598005535c53049a9c24e">More...</a><br /></td></tr>
<tr class="separator:a9530b9db723598005535c53049a9c24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c039d4e4517f84d5b311871157584e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73c039d4e4517f84d5b311871157584e"></a>
<a class="el" href="classhtgs_1_1_any_task_scheduler.html">AnyTaskScheduler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph.html#a73c039d4e4517f84d5b311871157584e">graphConsumerTaskManager</a></td></tr>
<tr class="memdesc:a73c039d4e4517f84d5b311871157584e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of consumers accessing the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a>'s input connector. <br /></td></tr>
<tr class="separator:a73c039d4e4517f84d5b311871157584e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60eb3eb99b077b53ff3a68eb43a5c8e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac60eb3eb99b077b53ff3a68eb43a5c8e"></a>
<a class="el" href="classhtgs_1_1_any_task_scheduler.html">AnyTaskScheduler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph.html#ac60eb3eb99b077b53ff3a68eb43a5c8e">graphProducerTaskManager</a></td></tr>
<tr class="memdesc:ac60eb3eb99b077b53ff3a68eb43a5c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of producers that are outputting data to the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a>'s output connector. <br /></td></tr>
<tr class="separator:ac60eb3eb99b077b53ff3a68eb43a5c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839fa5eee17aa8dde3e25586984c5369"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a839fa5eee17aa8dde3e25586984c5369"></a>
std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_connector.html">Connector</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph.html#a839fa5eee17aa8dde3e25586984c5369">input</a></td></tr>
<tr class="memdesc:a839fa5eee17aa8dde3e25586984c5369"><td class="mdescLeft">&#160;</td><td class="mdescRight">The input connector for the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a>. <br /></td></tr>
<tr class="separator:a839fa5eee17aa8dde3e25586984c5369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c35ca0b3e8f5e33f276479210e28320"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c35ca0b3e8f5e33f276479210e28320"></a>
std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_connector.html">Connector</a>&lt; U &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph.html#a7c35ca0b3e8f5e33f276479210e28320">output</a></td></tr>
<tr class="memdesc:a7c35ca0b3e8f5e33f276479210e28320"><td class="mdescLeft">&#160;</td><td class="mdescRight">The output connector for the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a>. <br /></td></tr>
<tr class="separator:a7c35ca0b3e8f5e33f276479210e28320"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class V, class W&gt;<br />
class htgs::TaskGraph&lt; V, W &gt;</h3>

<p>Manages a group of connected ITasks and their connections. </p>
<p>Each <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> that is added into the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a> is stored in the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a>'s metadata to allow for quick copying using copy().</p>
<p>The main methods for adding each <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> into the graph are addEdge(), addGraphInputConsumer(), addGraphOutputProducer(), and addRule()</p>
<p>When using these methods, the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a> builds a Task, which is used to process an <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a>'s functionality. Parameters for customizing the thread pool, polling abilities, etc., are specified in the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> constructors: <a class="el" href="classhtgs_1_1_i_task.html#ac23fa74bf05d6a86000422d989ccc5d1" title="Creates an ITask with number of threads equal to 1. ">ITask::ITask()</a></p>
<p>Special memory edge functions are provided. For normal CPU memory edges use: <a class="el" href="classhtgs_1_1_task_graph.html#a1b84e93e1a7221ffa0d4b35b55e817f9" title="Adds a MemoryManager edge with the specified name to the TaskGraph. ">addMemoryManagerEdge()</a></p>
<p>For Cuda memory use: <a class="el" href="classhtgs_1_1_task_graph.html#a85eb1e4c7ffd8732046a2ec0a37a91a6" title="Adds a CudaMemoryManager edge with the specified name to the TaskGraph. ">addCudaMemoryManagerEdge()</a></p>
<p>Every <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a> has an input and output type (T and U). If a <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a> does not have an input or output type, then the type can be specified as <a class="el" href="classhtgs_1_1_void_data.html" title="VoidData is used for data that is empty/void. ">VoidData</a>.</p>
<p>To add data into the input of a <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a> use the <a class="el" href="classhtgs_1_1_task_graph.html#a15b4bb176539081a1a74428aaa337ed5" title="Produces data for the input of the TaskGraph. ">produceData()</a> functions. These must be used in conjunction with the incrementGraphInputProducer() and finishedProducingData() functions to indicate a data input stream is active and when that input stream is closing, respectively.</p>
<p>To process the output of a <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a> use the <a class="el" href="classhtgs_1_1_task_graph.html#aa222a7e8f5d3fe0a29bfb85e90203c34" title="Consumes data from the output of a TaskGraph. ">consumeData()</a> function. To determine if data is no longer being produced by a <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a> use the <a class="el" href="classhtgs_1_1_task_graph.html#a0ad46b99c6a98747464100e1a739a419" title="Checks if the output of the TaskGraph has finished producing data. ">isOutputTerminated()</a> function.</p>
<p>Example Usage: </p><div class="fragment"><div class="line"><a class="code" href="classhtgs_1_1_task_graph.html">htgs::TaskGraph&lt;MatrixBlockRequest, MatrixBlockRequest&gt;</a> *taskGraph = <span class="keyword">new</span> <a class="code" href="classhtgs_1_1_task_graph.html">htgs::TaskGraph&lt;MatrixBlockRequest, MatrixBlockRequest&gt;</a>();</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> numLoadThreads = 2;</div>
<div class="line"><span class="keywordtype">int</span> numMulThreads = 20;</div>
<div class="line"></div>
<div class="line">LoadMatrixTask *loadMatrixTask = <span class="keyword">new</span> LoadMatrixTask(numLoadThreads, blockSize, width, height);</div>
<div class="line">ScalarMultiplyTask *scalMulTask = <span class="keyword">new</span> ScalarMultiplyTask(numMulThreads, blockSize, width, height);</div>
<div class="line"><a class="code" href="classhtgs_1_1_bookkeeper.html">htgs::Bookkeeper&lt;MatrixBlockData&gt;</a> *bkTask = <span class="keyword">new</span> <a class="code" href="classhtgs_1_1_bookkeeper.html">htgs::Bookkeeper&lt;MatrixBlockData&gt;</a>();</div>
<div class="line"></div>
<div class="line">MatrixLoadRule *loadRule = <span class="keyword">new</span> MatrixLoadRule(width/blockSize, height/blockSize);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Add tasks to graph</span></div>
<div class="line">taskGraph-&gt;addEdge(loadMatrixTask, bkTask);</div>
<div class="line">taskGraph-&gt;addRule(bkTask, scalMulTask, loadRule);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Add memory edges</span></div>
<div class="line">MatrixAllocator *matrixAlloc = <span class="keyword">new</span> MatrixAllocator(blockSize, blockSize);</div>
<div class="line"><span class="keywordtype">int</span> poolSize = 50;</div>
<div class="line">taskGraph-&gt;<a class="code" href="classhtgs_1_1_task_graph.html#a1b84e93e1a7221ffa0d4b35b55e817f9">addMemoryManagerEdge</a>(<span class="stringliteral">&quot;MatrixA&quot;</span>, loadMatrixTask, scalMulTask, matrixAlloc, 50);</div>
<div class="line">taskGraph-&gt;<a class="code" href="classhtgs_1_1_task_graph.html#a1b84e93e1a7221ffa0d4b35b55e817f9">addMemoryManagerEdge</a>(<span class="stringliteral">&quot;MatrixB&quot;</span>, loadMatrixTask, scalMulTask, matrixAlloc, 50);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Setup graph input/output</span></div>
<div class="line">taskGraph-&gt;addGraphInputConsumer(loadMatrixTask);</div>
<div class="line">taskGraph-&gt;addGraphOutputProducer(scalMulTask);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Indicate input data stream</span></div>
<div class="line">taskGraph-&gt;incrementGraphInputProducer();</div>
<div class="line"></div>
<div class="line"><span class="comment">// Setup runtime and execute</span></div>
<div class="line"><a class="code" href="classhtgs_1_1_runtime.html">htgs::Runtime</a> *runtime = <span class="keyword">new</span> <a class="code" href="classhtgs_1_1_runtime.html">htgs::Runtime</a>(taskGraph);</div>
<div class="line">runtime-&gt;<a class="code" href="classhtgs_1_1_runtime.html#a7f6f3656b206a43d9499e27241c592a7">executeRuntime</a>();</div>
<div class="line"></div>
<div class="line"><span class="comment">// Add input to graph</span></div>
<div class="line"><span class="keywordflow">for</span> (blockRow = 0; blockRow &lt; blockHeight; blockRow++)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">for</span>(blockCol = 0; blockCol &lt; blockWidth; blockCol++)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Request to multiply BlockedA[blockRow, blockCol] .* BlockedB[blockRow, blockCol]</span></div>
<div class="line">    taskGraph-&gt;<a class="code" href="classhtgs_1_1_task_graph.html#a15b4bb176539081a1a74428aaa337ed5">produceData</a>(<span class="keyword">new</span> MatrixBlockRequest(blockRow, blockCol, <span class="stringliteral">&quot;MatrixA&quot;</span>));</div>
<div class="line">    taskGraph-&gt;<a class="code" href="classhtgs_1_1_task_graph.html#a15b4bb176539081a1a74428aaa337ed5">produceData</a>(<span class="keyword">new</span> MatrixBlockRequest(blockRow, blockCol, <span class="stringliteral">&quot;MatrixB&quot;</span>));</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Indicate finished producing data</span></div>
<div class="line">taskGraph-&gt;finishedProducingData();</div>
<div class="line"></div>
<div class="line"><span class="comment">// Process taskGraph output</span></div>
<div class="line"><span class="keywordflow">while</span> (!taskGraph-&gt;<a class="code" href="classhtgs_1_1_task_graph.html#a0ad46b99c6a98747464100e1a739a419">isOutputTerminated</a>())</div>
<div class="line">{</div>
<div class="line">  std::shared_ptr&lt;MatrixBlockRquest&gt; mbr = taskGraph-&gt;<a class="code" href="classhtgs_1_1_task_graph.html#aa222a7e8f5d3fe0a29bfb85e90203c34">consumeData</a>();</div>
<div class="line">  <span class="keywordflow">if</span> (mbr != <span class="keyword">nullptr</span>)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// ... apply post-processing</span></div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">runtime-&gt;<a class="code" href="classhtgs_1_1_runtime.html#a60e330b39a84d4767e3c757f4728dcb1">waitForRuntime</a>();</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the input data type for the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a>, T must derive from <a class="el" href="classhtgs_1_1_i_data.html" title="Class to hold any type of data. ">IData</a>. </td></tr>
    <tr><td class="paramname">U</td><td>the output data type for the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a>, U must derive from <a class="el" href="classhtgs_1_1_i_data.html" title="Class to hold any type of data. ">IData</a>. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad89bcb6c378447e939df51b49a2c07ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V, class W&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhtgs_1_1_task_graph.html">htgs::TaskGraph</a>&lt; V, W &gt;::~<a class="el" href="classhtgs_1_1_task_graph.html">TaskGraph</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a> with the specified input and output <a class="el" href="classhtgs_1_1_connector.html" title="Manages the input/output of IData between Tasks. ">Connector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td></td></tr>
    <tr><td class="paramname">output</td><td>Destructor, handles releasing all <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> memory that is managed by the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a85eb1e4c7ffd8732046a2ec0a37a91a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V, class W&gt; </div>
<div class="memtemplate">
template&lt;class IMemoryAllocatorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph.html">htgs::TaskGraph</a>&lt; V, W &gt;::addCudaMemoryManagerEdge </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *&#160;</td>
          <td class="paramname"><em>memoryEdges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *&#160;</td>
          <td class="paramname"><em>releaseMemoryEdges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; IMemoryAllocatorType &gt;&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>memoryPoolSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MMType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CUcontext *&#160;</td>
          <td class="paramname"><em>contexts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a <a class="el" href="classhtgs_1_1_cuda_memory_manager.html" title="Implements a MemoryManager that binds the thread responsible for the MemoryManager to a Cuda GPU prio...">CudaMemoryManager</a> edge with the specified name to the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a>. </p>
<p>This will create a <a class="el" href="classhtgs_1_1_cuda_memory_manager.html" title="Implements a MemoryManager that binds the thread responsible for the MemoryManager to a Cuda GPU prio...">CudaMemoryManager</a> that is bound to some Cuda GPU based on the pipelineId of the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the memory edge </td></tr>
    <tr><td class="paramname">memoryEdges</td><td>the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> that is getting memory </td></tr>
    <tr><td class="paramname">releaseMemoryEdges</td><td>the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> that is releasing memory </td></tr>
    <tr><td class="paramname">allocator</td><td>the allocator describing how memory is allocated (should allocate Cuda memory) </td></tr>
    <tr><td class="paramname">memoryPoolSize</td><td>the size of the memory pool that is allocated by the <a class="el" href="classhtgs_1_1_cuda_memory_manager.html" title="Implements a MemoryManager that binds the thread responsible for the MemoryManager to a Cuda GPU prio...">CudaMemoryManager</a> </td></tr>
    <tr><td class="paramname">type</td><td>the type of memory manager </td></tr>
    <tr><td class="paramname">contexts</td><td>the array of all Cuda contexts </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the memoryPoolSize can cause out of memory errors for the GPU if the allocator-&gt;size() * memoryPoolSize exceeds the total GPU memory </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>the type of memory; i.e. 'cufftDoubleComplex *' </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1b84e93e1a7221ffa0d4b35b55e817f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V, class W&gt; </div>
<div class="memtemplate">
template&lt;class V , class IMemoryAllocatorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph.html">htgs::TaskGraph</a>&lt; V, W &gt;::addMemoryManagerEdge </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *&#160;</td>
          <td class="paramname"><em>getMemoryTask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *&#160;</td>
          <td class="paramname"><em>releaseMemoryTask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; IMemoryAllocatorType &gt;&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>memoryPoolSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MMType&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">MemoryManager</a> edge with the specified name to the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the memory edge </td></tr>
    <tr><td class="paramname">getMemoryTask</td><td>the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> that is getting memory </td></tr>
    <tr><td class="paramname">releaseMemoryTask</td><td>the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> that is releasing memory </td></tr>
    <tr><td class="paramname">allocator</td><td>the allocator describing how memory is allocated (should allocate Cuda memory) </td></tr>
    <tr><td class="paramname">memoryPoolSize</td><td>the size of the memory pool that is allocated by the <a class="el" href="classhtgs_1_1_cuda_memory_manager.html" title="Implements a MemoryManager that binds the thread responsible for the MemoryManager to a Cuda GPU prio...">CudaMemoryManager</a> </td></tr>
    <tr><td class="paramname">type</td><td>the type of memory manager </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the memoryPoolSize can cause out of memory errors for the system if the allocator-&gt;size() * memoryPoolSize exceeds the total system memory </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>the type of memory; i.e., 'double *' </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afeb08f2cdf202215129b6f2b2d9e59ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V, class W&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph.html">htgs::TaskGraph</a>&lt; V, W &gt;::addUserManagedMemoryManagerEdge </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *&#160;</td>
          <td class="paramname"><em>getMemoryTask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *&#160;</td>
          <td class="paramname"><em>releaseMemoryTask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>memoryPoolSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">MemoryManager</a> that is managed by the user. </p>
<p>This edge will enable an <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> to use the <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">MemoryManager</a> to throttle how much data is allocated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the memory edge </td></tr>
    <tr><td class="paramname">memGetter</td><td>the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> that will be getting memory </td></tr>
    <tr><td class="paramname">memReleaser</td><td>the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> that will be releasing memory </td></tr>
    <tr><td class="paramname">memoryPoolSize</td><td>the size of the memory pool </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa222a7e8f5d3fe0a29bfb85e90203c34"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V, class W&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;U&gt; <a class="el" href="classhtgs_1_1_task_graph.html">htgs::TaskGraph</a>&lt; V, W &gt;::consumeData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consumes data from the output of a <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a>. </p>
<p>It is possible for consumeData to return nullptr if the last Task has finished. Therefore, when consuming data from a <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a> it is important to have a check for nullptr prior to processing that data. </p><dl class="section return"><dt>Returns</dt><dd>one data element from the output of the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a> or nullptr if the last task is closing. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The task producing data for the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a> will send nullptr to the connector, so the thread consuming data should check for nullptr prior to processing the data. </dd></dl>

</div>
</div>
<a class="anchor" id="a0ad46b99c6a98747464100e1a739a419"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V, class W&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhtgs_1_1_task_graph.html">htgs::TaskGraph</a>&lt; V, W &gt;::isOutputTerminated </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the output of the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a> has finished producing data. </p>
<dl class="section return"><dt>Returns</dt><dd>whether the output is finished or not </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>if the output is no longer producing data </td></tr>
    <tr><td class="paramname">FALSE</td><td>if the output is not finished producing data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a994884edaae94574d64ee9fd5d0fd7a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V, class W&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;U&gt; <a class="el" href="classhtgs_1_1_task_graph.html">htgs::TaskGraph</a>&lt; V, W &gt;::pollData </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>microTimeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Polls for data from the output of the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">microTimeout</td><td>the timeout time in microseconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the data or nullptr if the timeout period expires. </dd></dl>

</div>
</div>
<a class="anchor" id="a15b4bb176539081a1a74428aaa337ed5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V, class W&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph.html">htgs::TaskGraph</a>&lt; V, W &gt;::produceData </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Produces data for the input of the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a>. </p>
<p>Must specify the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a> input using addGraphInputConsumer() and use incrementGraphInputProducer() to indicate an input stream is feeding data to the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the data being added to the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a> input</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The data being passed will be wrapped into a std::shared_ptr&lt;T&gt;(data) </dd></dl>

</div>
</div>
<a class="anchor" id="a2d896acdc5a27ed9db6340cd2b5995ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V, class W&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph.html">htgs::TaskGraph</a>&lt; V, W &gt;::produceData </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; T &gt;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Produces data for the input of the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a>. </p>
<p>Must specify the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a> input using addGraphInputConsumer() and use incrementGraphInputProducer() to indicate an input stream is feeding data to the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the data being added to the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a> input </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a538cbbc552965902fec6faac67766fbf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V, class W&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph.html">htgs::TaskGraph</a>&lt; V, W &gt;::produceData </td>
          <td>(</td>
          <td class="paramtype">std::list&lt; std::shared_ptr&lt; T &gt;&gt; *&#160;</td>
          <td class="paramname"><em>dataList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a list of data into the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a> Must specify the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a> input using addGraphInputConsumer() and use incrementGraphInputProducer() to indicate an input stream is feeding data to the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataList</td><td>the list of data to be added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a9530b9db723598005535c53049a9c24e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V, class W&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;<a class="el" href="classhtgs_1_1_edge_descriptor.html">EdgeDescriptor</a> *&gt;* <a class="el" href="classhtgs_1_1_task_graph.html">htgs::TaskGraph</a>&lt; V, W &gt;::edges</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the dot representation of the task graph to disk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>the file path (will not create directories) Generate the content only of the graph (excludes all graph definitions and attributes) Generates the dot graph as a string Gets the output producers associated with this <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output producers for the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a> Adds a graph input consumer to process the input of the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iTask</td><td>the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> that will process the input Adds a graph output producer to produce output for the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a> </td></tr>
    <tr><td class="paramname">iTask</td><td>the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> that will produce output Increments the number of producers sending data into the input for the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Specify the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a> input using addGraphInputConsumer() and when the input stream has finished producing data use finishedProducingData() Indicates that the input stream has finished producing data for the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a>. </dd>
<dd>
Must have a matching call to incrementGraphInputProducer() Creates a copy of the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a> with the specified pipeline Id and number of pipelines. The copy contains the same structure as the original <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a>, but with new instances of every Task, <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a>, and <a class="el" href="classhtgs_1_1_connector.html" title="Manages the input/output of IData between Tasks. ">Connector</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipelineId</td><td>the pipeline Id </td></tr>
    <tr><td class="paramname">numPipelines</td><td>the number of pipelines </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a> Adds an edge to the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a>. The output type of the produce must match the input type of the consumer. This will create two <a class="el" href="classhtgs_1_1_task_scheduler.html" title="Encapsulates an ITask to interact with an ITask&#39;s functionality. ">TaskScheduler</a> vertices (or lookup an existing vertex for the producer or consumer if that vertex already exists in the graph) and connect the two vertices through a <a class="el" href="classhtgs_1_1_connector.html" title="Manages the input/output of IData between Tasks. ">Connector</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">producer</td><td>the producer <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> </td></tr>
    <tr><td class="paramname">consumer</td><td>the consumer <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> Adds an <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">IRule</a> to the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a> connecting a <a class="el" href="classhtgs_1_1_bookkeeper.html" title="Special task used to manage rules. ">Bookkeeper</a> with a consumer <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a>. The <a class="el" href="classhtgs_1_1_bookkeeper.html" title="Special task used to manage rules. ">Bookkeeper</a> type must match the input of the <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">IRule</a> and the output type of the <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">IRule</a> must match the input type of the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> consumer </td></tr>
    <tr><td class="paramname">bk</td><td>the <a class="el" href="classhtgs_1_1_bookkeeper.html" title="Special task used to manage rules. ">Bookkeeper</a> </td></tr>
    <tr><td class="paramname">consumer</td><td>the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> consumer </td></tr>
    <tr><td class="paramname">rule</td><td>the <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">IRule</a> to connect the <a class="el" href="classhtgs_1_1_bookkeeper.html" title="Special task used to manage rules. ">Bookkeeper</a> and the consumer <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> Adds a custom edge to the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a>. The <a class="el" href="classhtgs_1_1_i_custom_edge.html" title="Interface for defining a custom edge to be added into a TaskGraph. ">ICustomEdge</a> represents an interface to describe how to add the edge to the graph. </td></tr>
    <tr><td class="paramname">customEdge</td><td>the custom edge to be added Adds a <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">MemoryManager</a> edge with the specified name to the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a>, which connects a memory getter and releaser. This function provides the ability to specify a custom type of memory manager. </td></tr>
    <tr><td class="paramname">memGetter</td><td>the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> that is getting memory </td></tr>
    <tr><td class="paramname">memReleaser</td><td>the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> that is releasing memory </td></tr>
    <tr><td class="paramname">memoryManager</td><td>the memory manager responsible for sending/recycling memory </td></tr>
    <tr><td class="paramname">ignoreMemGetterErrors</td><td>whether to ignore errors with the memory getter, used if the memory getter is already connected to the same memory manager with the same edge name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the memoryPoolSize can cause out of memory errors for the system if the allocator-&gt;size() * memoryPoolSize exceeds the total system memory </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>the type of memory; i.e., 'double *' Adds a <a class="el" href="classhtgs_1_1_cuda_memory_manager.html" title="Implements a MemoryManager that binds the thread responsible for the MemoryManager to a Cuda GPU prio...">CudaMemoryManager</a> edge with the specified name to the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a>. This will create a <a class="el" href="classhtgs_1_1_cuda_memory_manager.html" title="Implements a MemoryManager that binds the thread responsible for the MemoryManager to a Cuda GPU prio...">CudaMemoryManager</a> that is bound to some Cuda GPU based on the pipelineId of the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the memory edge </td></tr>
    <tr><td class="paramname">memoryEdges</td><td>the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> that is getting memory </td></tr>
    <tr><td class="paramname">releaseMemoryEdges</td><td>the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> that is releasing memory </td></tr>
    <tr><td class="paramname">allocator</td><td>the allocator describing how memory is allocated (should allocate Cuda memory) </td></tr>
    <tr><td class="paramname">memoryPoolSize</td><td>the size of the memory pool that is allocated by the <a class="el" href="classhtgs_1_1_cuda_memory_manager.html" title="Implements a MemoryManager that binds the thread responsible for the MemoryManager to a Cuda GPU prio...">CudaMemoryManager</a> </td></tr>
    <tr><td class="paramname">type</td><td>the type of memory manager </td></tr>
    <tr><td class="paramname">contexts</td><td>the array of all Cuda contexts </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the memoryPoolSize can cause out of memory errors for the GPU if the allocator-&gt;size() * memoryPoolSize exceeds the total GPU memory </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>the type of memory; i.e. 'cufftDoubleComplex *' Adds a <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">MemoryManager</a> that is managed by the user. This edge will enable an <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> to use the <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">MemoryManager</a> to throttle how much data is allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the memory edge </td></tr>
    <tr><td class="paramname">memGetter</td><td>the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> that will be getting memory </td></tr>
    <tr><td class="paramname">memReleaser</td><td>the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> that will be releasing memory </td></tr>
    <tr><td class="paramname">memoryPoolSize</td><td>the size of the memory pool Adds a <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">MemoryManager</a> edge with the specified name to the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a>. </td></tr>
    <tr><td class="paramname">name</td><td>the name of the memory edge </td></tr>
    <tr><td class="paramname">memGetter</td><td>the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> that is getting memory </td></tr>
    <tr><td class="paramname">memReleaser</td><td>the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> that is releasing memory </td></tr>
    <tr><td class="paramname">allocator</td><td>the allocator describing how memory is allocated (should allocate Cuda memory) </td></tr>
    <tr><td class="paramname">memoryPoolSize</td><td>the size of the memory pool that is allocated by the <a class="el" href="classhtgs_1_1_cuda_memory_manager.html" title="Implements a MemoryManager that binds the thread responsible for the MemoryManager to a Cuda GPU prio...">CudaMemoryManager</a> </td></tr>
    <tr><td class="paramname">type</td><td>the type of memory manager </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the memoryPoolSize can cause out of memory errors for the system if the allocator-&gt;size() * memoryPoolSize exceeds the total system memory </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>the type of memory; i.e., 'double *' Adds a <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">MemoryManager</a> that is managed by the user with this graph as the memory releaser. This edge will enable an <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> to use the <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">MemoryManager</a> to throttle how much data is allocated. The throttling is achieved by adding <a class="el" href="classhtgs_1_1_memory_data.html" title="Describes memory allocated by a MemoryManager to manage shared memory across multiple ITask...">MemoryData</a> back to the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the memory edge </td></tr>
    <tr><td class="paramname">memGetter</td><td>the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> that will be getting memory </td></tr>
    <tr><td class="paramname">memoryPoolSize</td><td>the size of the memory pool Adds a <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">MemoryManager</a> edge with the specified name to the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a>. The <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a> is used to release memory using the TaskGraph::memRelease function. </td></tr>
    <tr><td class="paramname">name</td><td>the name of the memory edge </td></tr>
    <tr><td class="paramname">memGetter</td><td>the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> that is getting memory </td></tr>
    <tr><td class="paramname">allocator</td><td>the allocator describing how memory is allocated (should allocate Cuda memory) </td></tr>
    <tr><td class="paramname">memoryPoolSize</td><td>the size of the memory pool that is allocated by the <a class="el" href="classhtgs_1_1_cuda_memory_manager.html" title="Implements a MemoryManager that binds the thread responsible for the MemoryManager to a Cuda GPU prio...">CudaMemoryManager</a> </td></tr>
    <tr><td class="paramname">type</td><td>the type of memory manager </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the memoryPoolSize can cause out of memory errors for the system if the allocator-&gt;size() * memoryPoolSize exceeds the total system memory </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>the type of memory; i.e., 'double *' Checks whether this <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> contains a memReleaser for a specified name </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the memReleaser </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether this <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> has a memReleaser with the specified name </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>if the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> has a memReleaser with the specified name </td></tr>
    <tr><td class="paramname">FALSE</td><td>if the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> does not have a memReleaser with the specified name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>To add a memReleaser to this <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a> use TaskGraph::addGraphMemoryManagerEdge Releases memory onto a memory edge </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the memory edge </td></tr>
    <tr><td class="paramname">memory</td><td>the memory to be released </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>the <a class="el" href="classhtgs_1_1_memory_data.html" title="Describes memory allocated by a MemoryManager to manage shared memory across multiple ITask...">MemoryData</a> type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The name specified must have been attached to this <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> as a memReleaser using the <a class="el" href="classhtgs_1_1_task_graph.html#a1b84e93e1a7221ffa0d4b35b55e817f9" title="Adds a MemoryManager edge with the specified name to the TaskGraph. ">TaskGraph::addMemoryManagerEdge</a> routine, which can be verified using hasMemReleaser() </dd>
<dd>
Memory edge must be defined as MMType::Static OR MMType::Dynamic Releases memory onto a memory edge </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the memory edge </td></tr>
    <tr><td class="paramname">pipelineId</td><td>the pipelineId to add data to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The name specified must have been attached to this <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> as a memReleaser using the TaskGraph::addUserManagedEdge routine, which can be verified using hasMemReleaser() </dd>
<dd>
Memory edge must be defined as MMType::UserManaged by using the <a class="el" href="classhtgs_1_1_task_graph.html#afeb08f2cdf202215129b6f2b2d9e59ab" title="Adds a MemoryManager that is managed by the user. ">TaskGraph::addUserManagedMemoryManagerEdge</a> Indicates to the memory managers that are managing memory between the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a> and <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a>'s created from TaskGraph::addGraphMemoryManager can be shut down. Use this function from the thread that is interacting with the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a>'s memory manager to ensure the memory managers are shutting down. Gets the edges (<a class="el" href="classhtgs_1_1_connector.html" title="Manages the input/output of IData between Tasks. ">Connector</a>) associated with the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the list of connectors Gets the vertices (BaseTaskScheduler) associated with the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a> </dd>
<dd>
the list of tasks Pure virtual function to add a copy of a <a class="el" href="classhtgs_1_1_task_scheduler.html" title="Encapsulates an ITask to interact with an ITask&#39;s functionality. ">TaskScheduler</a> into the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskCopy</td><td>the task that was copied. Provides debug output for the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>#define DEBUG_FLAG to enable debugging Processes all of the input for the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a> until no more input is available </dd>
<dd>
#define DEBUG_FLAG to enable debugging Gets the input connector for the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the input connector Gets the output connector for the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a> </dd>
<dd>
the output connector Sets the memory manager type map </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMap</td><td>the shared pointer to the memory manager type map Sets the memory releaser mapping </td></tr>
    <tr><td class="paramname">memReleaser</td><td>the memory releaser map Sets the pipeline Id that the <a class="el" href="classhtgs_1_1_task_graph.html" title="Manages a group of connected ITasks and their connections. ">TaskGraph</a> is bound to. </td></tr>
    <tr><td class="paramname">pipelineId</td><td>the pipelineId </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/tjb3/phd-research/HTGS-dev/src/htgs/api/<a class="el" href="_execution_pipeline_8hpp_source.html">ExecutionPipeline.hpp</a></li>
<li>/home/tjb3/phd-research/HTGS-dev/src/htgs/api/<a class="el" href="_task_graph_8hpp_source.html">TaskGraph.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>htgs</b></li><li class="navelem"><a class="el" href="classhtgs_1_1_task_graph.html">TaskGraph</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.7 </li>
  </ul>
</div>
</body>
</html>
