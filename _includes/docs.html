    <!-- ******DOCS****** -->
    <section id="docs" class="docs section">
        <div class="container">
            <div class="docs-inner">
            <h2 class="title text-center">Get Started</h2>
            <div class="block">
                <h3 class="sub-title text-center">Installation</h3>
                <ul class="list-unstyled">
                    <li><strong>Dependencies:</strong></li>
                    <li>cmake v2.7+</li>
                    <li>g++/gcc v4.8.4+ (C++11)</li>
                    <li>pthreads</li>
                    <li>(Optional) doxygen</li>
                </ul>

                <ul class="list-unstyled">
                    <li><strong>CMake Options:</strong></li>
                    <li>CMAKE_INSTALL_PREFIX - Where to install HTGS (and documentation)</li>
                    <li>BUILD_DOXYGEN - Creates doxygen documentation (view online at: <a href="doxygen/index.html" target="_blank">Documentation</a>)</li>
                    <li>RUN_GTEST - Compiles and runs google unit tests for HTGS ('make run-test' to re-run)</li>
                </ul>
                <div class="code-block">
                    <!--//Use Prismjs - http://prismjs.com/index.html#basic-usage -->
                    <pre><code class="language-clike">
 :$ git clone https://github.com/usnistgov/HTGS.git
 :$ cd &ltHTGS_Directory&gt
 :&ltHTGS_Directory&gt$ mkdir build && cd build
 :&ltHTGS_Directory&gt/build$ ccmake ../         (or cmake-gui)

 'Configure' and setup cmake parameters
 'Configure' and 'Build'

 :&ltHTGS_Directory&gt/build$ make
 :&ltHTGS_Directory&gt/build$ make install
                     </code></pre>
                </div><!--//code-block-->


            </div><!--//block-->

            <div class="block">
                <h3 class="sub-title text-center">Using HTGS</h3>
                <ul class="list-unstyled">
                    <li><strong>HTGS API:</strong></li>
                    <li>htgs::IData</li>
                    <li>htgs::ITask</li>
                    <li>htgs::TaskGraph</li>
                    <li>htgs::Runtime</li>
                </ul>
                <p>Brief example of adding two numbers using HTGS; filename: "main.cpp". (As seen in <a href="doxygen/tutorial1.html" target="_blank">Tutorial 1</a>):</p>
                <div class="code-block">
                    <!--//Use Prismjs - http://prismjs.com/index.html#basic-usage -->
                    <pre><code class="language-cpp">
  #include &lthtgs/api/IData.hpp&gt
  #include &lthtgs/api/ITask.hpp&gt
  #include &lthtgs/api/TaskGraph.hpp&gt
  #include &lthtgs/api/Runtime.hpp&gt

  class InputData : public htgs::IData
  {
    public:
      InputData(int x, int y) : x(x), y(y) {}
      int getX() const { return x; }
      int getY() const { return y; }
    private:
      int x, y;
  };

  class OutputData : public htgs::IData
  {
    public:
      OutputData(int result) : result(result) {}
      int getResult() const { return result; }
    private:
      int result;
  };

  class AddTask : public htgs::ITask&ltInputData, OutputData&gt
  {
    public:
      virtual void initialize(int pipelineId, int numPipeline) { }
      virtual void shutdown() { }
      virtual bool isTerminated(std::shared_ptr&lthtgs::BaseConnector&gt inputConnector) {
        return inputConnector-&gtisInputTerminated();
      }
      virtual AddTask *copy() { return new AddTask(); }
      virtual void executeTask(std::shared_ptr&ltInputData&gt data) {
        int sum = data->getX() + data->getY();
        this-&gtaddResult(new OutputData(sum));
      }
  };

  int main() {
    AddTask *addTask = new AddTask();
    auto taskGraph = new htgs::TaskGraph&ltInputData, OutputData&gt();
    taskGraph-&gtaddGraphOutputProducer(addTask);
    taskGraph-&gtaddGraphInputConsumer(addTask);
    taskGraph-&gtincrementGraphInputProducer();

    auto runtime = new htgs::Runtime(taskGraph);
    runtime-&gtexecuteRuntime();

    int numData = 10;
    for (int i = 0; i < numData; i++) {
      auto inputData = new InputData(i, i);
      taskGraph-&gtproduceData(inputData);
    }

    taskGraph-&gtfinishedProducingData();

    runtime-&gtwaitForRuntime();

    while(!taskGraph-&gtisOutputTerminated()) {
      auto data = taskGraph->consumeData();
      std::cout << "Result: " << data-&gtgetResult() << std::endl;
    }

    delete runtime;
  }
                     </code></pre>
                </div><!--//code-block-->

                <ul class="list-unstyled">
                    <li><strong>Compile:</strong></li>
                    <li>g++ -I &ltHTGS_INSTALL_DIR&gt/include main.cpp -std=c++11 -pthread</li>
                    <br/>
                    <li><strong>Sample Output:</strong></li>
                    <li>:$./a.out</li>
                    <li>Result: 0</li>
                    <li>Result: 2</li>
                    <li>Result: 4</li>
                    <li>Result: 6</li>
                    <li>Result: 8</li>
                    <li>Result: 10</li>
                    <li>Result: 12</li>
                    <li>Result: 14</li>
                    <li>Result: 16</li>
                    <li>Result: 18</li>
                </ul>

            </div><!--//block-->

            <div class="block">
                <h3 class="sub-title text-center">Full Documentation</h3>
                <p>For full explanation of Tutorial 1 and other tutorials showing how to use all of the components, please visit the doxygen documentation below.</p>
                <ul class="list-unstyled">
                    <li><strong>HTGS API:</strong></li>
                    <li><a href="doxygen/classhtgs_1_1_bookkeeper.html" target="_blank">Bookkeeper</a> | <a href="doxygen/classhtgs_1_1_execution_pipeline.html" target="_blank">ExecutionPipeline</a> | <a href="doxygen/classhtgs_1_1_i_cuda_task.html" target="_blank">ICudaTask</a> | <a href="doxygen/classhtgs_1_1_i_custom_edge.html" target="_blank">ICustomEdge</a> | <a href="doxygen/classhtgs_1_1_i_data.html" target="_blank">IData</a> | <a href="doxygen/classhtgs_1_1_i_memory_allocator.html" target="_blank">IMemoryAllocator</a></li>
                    <li><a href="doxygen/classhtgs_1_1_i_memory_release_rule.html" target="_blank">IMemoryReleaseRule</a> | <a href="doxygen/classhtgs_1_1_i_rule.html" target="_blank">IRule</a> | <a href="doxygen/classhtgs_1_1_i_task.html" target="_blank">ITask</a> | <a href="doxygen/classhtgs_1_1_memory_data.html" target="_blank">MemoryData</a> | <a href="doxygen/classhtgs_1_1_runtime.html" target="_blank">Runtime</a> | <a href="doxygen/classhtgs_1_1_task_graph.html" target="_blank">TaskGraph</a> | <a href="doxygen/classhtgs_1_1_void_data.html" target="_blank">VoidData</a></li>
                </ul>
                <p class="text-center">
                    <a class="btn btn-cta-primary" href="doxygen/index.html" target="_blank">More on Doxygen</a>
                </p>
            </div><!--//block-->

            <div class="block">
                <h3 class="sub-title text-center">Cite Us In Your Research</h3>
                <p><blockquote>T. Blattner, W. Keyrouz, M. Halem, M. Brady and S. S. Bhattacharyya, "A hybrid task graph scheduler for high performance image processing workflows," 2015 IEEE Global Conference on Signal and Information Processing (GlobalSIP), Orlando, FL, 2015, pp. 634-637.</blockquote></p>
            </div><!--//block-->

            </div><!--//docs-inner-->
        </div><!--//container-->
    </section><!--//docs->
